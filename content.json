{"posts":[{"title":"ACM修炼指南","text":"Hi~ 转载自：bestsort 一 通用版目录数据结构栈，队列，链表,树哈希表，哈希数组堆，优先队列双端队列可并堆左偏堆二叉查找树Treap伸展树并查集集合计数问题二分图的识别平衡二叉树二叉排序树线段树一维线段树二维线段树树状数组一维树状数组N维树状数组字典树后缀数组，后缀树块状链表哈夫曼树桶，跳跃表Trie树(静态建树、动态建树)AC自动机LCA和RMQ问题KMP算法图论基本图算法图广度优先遍历深度优先遍历拓扑排序割边割点强连通分量Tarjan算法双连通分量强连通分支及其缩点图的割边和割点最小割模型、网络流规约2-SAT问题欧拉回路哈密顿回路最小生成树Prim算法Kruskal算法(稀疏图)Sollin算法次小生成树第k小生成树最优比例生成树最小树形图最小度限制生成树平面点的欧几里德最小生成树平面点的曼哈顿最小生成树最小平衡生成树最短路径有向无环图的最短路径-&gt;拓扑排序非负权值加权图的最短路径-&gt;Dijkstra算法(可使用二叉堆优化)含负权值加权图的最短路径-&gt;Bellmanford算法含负权值加权图的最短路径-&gt;Spfa算法(稠密带负权图中SPFA的效率并不如Bellman-Ford高)全源最短路弗洛伊德算法Floyd全源最短路Johnson算法次短路径第k短路径差分约束系统平面点对的最短路径(优化)双标准限制最短路径最大流增广路-&gt;Ford-Fulkerson算法预推流Dinic算法有上下界限制的最大流节点有限制的网络流无向图最小割-&gt;Stoer-Wagner算法有向图和无向图的边不交路径Ford-Fulkerson迭加算法含负费用的最小费用最大流匹配Hungary算法最小点覆盖最小路径覆盖最大独立集问题二分图最优完备匹配Kuhn-Munkras算法不带权二分匹配：匈牙利算法带权二分匹配：KM算法一般图的最大基数匹配一般图的赋权匹配问题拓扑排序弦图稳定婚姻问题广搜广搜的状态优化利用M进制数存储状态转化为串用hash表判重按位压缩存储状态双向广搜A*算法深搜深搜的优化位运算剪枝函数参数尽可能少层数不易过大双向搜索或者是轮换搜索IDA*算法记忆化搜索动态规划四边形不等式理论不完全状态记录青蛙过河问题利用区间dp背包类问题0-1背包，经典问题无限背包，经典问题判定性背包问题带附属关系的背包问题-1背包问题双背包求最优值构造三角形问题带上下界限制的背包问题(012背包)线性的动态规划问题积木游戏问题决斗（判定性问题）圆的最大多边形问题统计单词个数问题棋盘分割日程安排问题最小逼近问题(求出两数之比最接近某数/两数之和等于某数等等)方块消除游戏(某区间可以连续消去求最大效益)资源分配问题数字三角形问题漂亮的打印邮局问题与构造答案最高积木问题两段连续和最大2次幂和问题N个数的最大M段子段和交叉最大数问题判定性问题的dp(如判定整除、判定可达性等)模K问题的dp特殊的模K问题，求最大(最小)模K的数变换数问题单调性优化的动态规划1-SUM问题2-SUM问题序列划分问题(单调队列优化)剖分问题(多边形剖分/石子合并/圆的剖分/乘积最大)凸多边形的三角剖分问题乘积最大问题多边形游戏(多边形边上是操作符,顶点有权值)石子合并(N^3/N^2/NLogN各种优化)贪心的动态规划最优装载问题部分背包问题乘船问题贪心策略双机调度问题Johnson算法状态dp牛仔射击问题(博弈类)哈密顿路径的状态dp两支点天平平衡问题一个有向图的最接近二部图树形dp完美服务器问题(每个节点有3种状态)小胖守皇宫问题网络收费问题树中漫游问题树上的博弈树的最大独立集问题树的最大平衡值问题构造树的最小环数论中国剩余定理欧拉函数欧几里得定理欧几里德辗转相除法求GCD(最大公约数)扩展欧几里得大数分解与素数判定佩尔方程同余定理(大数求余)素数测试一千万以内：筛选法一千万以外：米勒测试法连分数逼近因式分解循环群生成元素数与整除问题进制位.同余模运算数学组合数学排列组合容斥原理递推关系和生成函数Polya计数法Polya计数公式Burnside定理N皇后构造解幻方的构造满足一定条件的hamilton圈的构造Catalan数Stirling数斐波拉契数调和数连分数MoBius反演偏序关系理论加法原理和乘法原理计算几何基本公式叉乘点乘常见形状的面积、周长、体积公式坐标离散化线段判断两线段（一直线、一线段）是否相交求两线段的交点多边形判定凸多边形,顶点按顺时针或逆时针给出,(不)允许相邻边共线判点在凸多边形内或多边形边上,顶点按顺时针或逆时针给出判点在凸多边形内,顶点按顺时针或逆时针给出,在多边形边上返回0判点在任意多边形内,顶点按顺时针或逆时针给出判线段在任意多边形内,顶点按顺时针或逆时针给出,与边界相交返回1多边形重心多边形切割(半平面交)扫描线算法多边形的内核三角形内心外心重心垂心费马点圆判直线和圆相交,包括相切判线段和圆相交,包括端点和相切判圆和圆相交,包括相切计算圆上到点p最近点,如p与圆心重合,返回p本身计算直线与圆的交点,保证直线与圆有交点计算线段与圆的交点可用这个函数后判点是否在线段上计算圆与圆的交点,保证圆与圆有交点,圆心不重合计算两圆的内外公切线计算线段到圆的切点点集最小圆覆盖可视图的建立对踵点经典问题平面凸包三维凸包Delaunay剖分/Voronoi图计算方法二分法二分法求解单调函数相关知识用矩阵加速的计算迭代法三分法解线性方程组LUP分解高斯消元解模线性方程组定积分计算多项式求根周期性方程线性规划快速傅立叶变换随机算法0/1分数规划三分法求解单峰(单谷)的极值迭代逼近矩阵法博弈论极大极小过程Nim博弈威佐夫博弈巴什博弈博弈树SG函数 二 个人版—————-入门—————-基本算法尺取法前缀和贪心活动安排问题筛选法素数打表同余定理快速幂GCDint gcd(int a,int b){return b?gcd(b,a%b):a;}扩展gcd查找二分查找三分查找哈希（散列表）枚举开关问题递归n皇后问题回溯法数据结构入门数据结构（自己动手实现）链表栈队列二叉树图图的基本概念拓扑排序并查集路径压缩动态规划入门简单递推斐波那契数列楼梯问题母牛问题平面分割问题简单dp数塔问题01背包最长公共子序列（LCS）最长上升子序列（LIS）其余预备知识codeblocks的使用时间复杂度的计算c++入门ubuntu使用qsort，sort，strcpy,strcmp等库函数的使用—————-基础—————-JAVA大数博弈巴什博弈威佐夫博弈尼姆博弈SG函数与SG定理树上删边游戏组合数学容斥原理各类组合数第一类斯特林数第二类斯特林数贝尔数卡特兰数那罗延数默慈金数康托展开康托逆展开母函数错位排序基姆拉尔森公式计算几何离散化凸包叉积点积pick定理三角形外新极角排序线段相交动态规划背包九讲数位dp概率dp状压dp区间dp树形dp数据结构线段树建树单点查询单点更新区间查询区间更新延迟标记并查集逆向并查集按秩合并路径压缩种类并查集树状数组lowbit操作区间查询单点更新单点查询区间更新区间查询区间更新区间求最值划分树RMQ问题图链式前向星拓扑排序最小生成树prim（适合稠密图）kruskal（适合稀疏图）朱刘算法（适合有向图）最短路floydDijkstra堆优化队列优化bellman-fordSPFADijkstra+堆优化第k短路（A*算法）分层最短路搜索bfs（广度优先搜索）dfs（深度优先搜索）网络流二分图匹配匈牙利算法二分图完备匹配增广路最小费用流树最近公共祖先（LCA）tarjan离线倍增欧拉序+RMQ树链剖分数论求逆元exgcd快速幂递推欧拉函数唯一分解定理中国剩余定理串最长回文子串manacher算法回文树模式匹配KMP扩展KMPTire树AC自动机数学斯特林公式高斯消元STLvectorqueuestringmapset迭代器进阶莫比乌斯反演波亚计数A*+可持续化可并堆KD树","link":"/2019/11/12/ACM%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/"},{"title":"Build a Simple SpringBoot Demo","text":"Integrate SpringBoot with MyBatis. 1 Build a SpringBoot Project1.1 Spring Initializer 1.2 Select what you need 2 Integrate MyBatis123456789101112131415161718server: port: 8081spring: devtools: restart: enabled: true datasource: url: jdbc:mysql://localhost:3306/boot_test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456mybatis: type-aliases-package: my.space.demo.pojo mapper-locations: classpath:mapper/*Mapper.xml 分别配置了数据源，和mybatis的类型aliases，以及mapper.xml的映射文件地址。 2.1 Scan Mappers1@MapperScan(value = &quot;my.space.demo.dao&quot;) 2.2 Configurate a mapper Bean1234@Repositorypublic interface UserMapper { List&lt;User&gt; queryAll();} 2.3 Mapper.xml123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;my.space.demo.dao.UserMapper&quot;&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;user&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 3 JUnit Test12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = DemoApplication.class)public class UserMapperTest { @Autowired private UserMapper userMapper; @Test public void queryAll() throws Exception { List&lt;User&gt; users = userMapper.queryAll(); users.forEach(System.out::println); }} Spring 将Mapper自动装配，装配后直接使用。 4 Final","link":"/2020/11/07/Build-a-Simple-SpringBoot-Demo/"},{"title":"UID:672342685 动态留档","text":"动态页面：点此直达 2023年06月23日 23:04:50 Type:img点击直达动态 和一个魂儿的第三个夏天！！！[乃琳个性装扮2.0_放烟花]今天的音乐节真的超级过瘾！！！好——开心！！！！！[乃琳个性装扮2.0_打招呼]今天也是很开心和大家相遇的小琳！！今天也要开开心心的入睡喔[乃琳个性装扮2.0_小狐狸] 2023年06月23日 12:00:00 Type:av点击直达视频 2023年06月22日 12:12:00 Type:text点击直达动态 端午节快乐！！！！！！[乃琳个性装扮2.0_耶][乃琳个性装扮2.0_耶]我刚刚吃了粽子！！！奶淇琳呢！有吃粽子吗！[乃琳个性装扮2.0_耶] 2023年06月21日 17:21:00 Type:text点击直达动态 彩排时小琳的os：我很帅我超级帅我特别特别帅我是最最有气场的飒姐姐！！！！[乃琳个性装扮2.0_墨镜][乃琳个性装扮2.0_墨镜][乃琳个性装扮2.0_墨镜]下来之后小然对我：你好像那个奶凶的小豹子[乃琳个性装扮2.0_再想想] 2023年06月20日 12:32:41 Type:reprint点击直达动态 评论：运营代转转发动态A-SOUL_Official UID:703007996动态内容：嗨~小伙伴们！又到了最最最火热的仲夏时节，一年一度的枝江乐坛流行榜单又来啦！A-SOUL的舞台你最喜欢哪一个呀？小伙伴们快来打开问卷pick你喜欢的舞台吧！小姐姐们将在某场直播里为小伙伴们重现大家喜爱的舞台表演！截止时间：6月24日 23:59问卷链接：https://wj.toutiao.com/q/241904/65r4NC4K/9bff/#/ 2023年06月19日 10:09:00 Type:text点击直达动态 哇……我已经连续三天梦到自己从天台起飞了[乃琳个性装扮2.0_翻跟头]就是那种从天台上奋力起跳，然后在高楼间飞跃[乃琳个性装扮2.0_打招呼]看着高楼从在我脚下到越来越小——哇……真的超级有趣！！！！[乃琳个性装扮2.0_墨镜]好像还有很多离谱的情节来着，但是记不清楚了，只记得飞得超级开心！！[乃琳个性装扮2.0_小狐狸]于是醒来就赶快来分享给你们啦！！！！[乃琳个性装扮2.0_贴贴捏]","link":"/2023/06/24/Eileen_data/"},{"title":"Highly agreed answers","text":"喜欢的高赞回答 整理至2020-12-14 如何看待嫦娥五号带回的部分月球土壤将保存在湖南以告慰毛主席？@王子君 国之大事，在祀与戎。 祭奠谁、告慰谁、尊崇谁，墓碑另一侧的人其实不在乎；但对墓碑这一侧的人来说，墓碑犹如一面镜子。 以月球土壤告慰教员，最大的意义不在教员身上，教员也不在乎。他这个脾性，后人是赞誉还是毁损，大概也不会妨碍他吃鱼。 最大的意义，是我们没有背弃自己的历史。 我们没有到外面找一个宏大叙事，把飞上月球说成什么“先进文明”的引导。我们没有在外面请一个弥赛亚； 我们没有在里面编一个船新版本，把飞上月球说成什么“告别革命”的出路。我们没有在里面供一个六耳猕猴。 前三十年与后三十年的一致，1840年到1949年的继承与变革，我们就是我们。中间的历史如一缕不绝之线，思想上没有剪断，月球的土壤摆在了教员面前。 这份月球土壤不是什么“贡品”，这份月球土壤是我们在一面巨大的镜子面前整理着装。 因为只有在这面精沉邃远的镜子面前，很多人才能回忆起自己最初的模样。 (2020-11-26) 哪些句子你看了想哭？(不是指特别虐的句子，是指那种，可能反复看了几遍，突然会觉得悲哀的句子。) @一只恐龙 不请自答，下面这些对话源自电影《The Sixth Sense》附上英文对话：COLEShe wanted me to tell you--LYNN(Cole's mother)Cole, please stop.COLEShe wanted me to tell you, she saw you dance.COLEShe said when you were little, you and her had a fight right before your dance recital. You thought she didn't come to see you dance. She did.COLEShe hid in the back so you wouldn't see... She said you were like an angel.COLEShe said, you came to her where they buried her. Asked her a question... She said the answer is \"Everyday.\"COLEWhat did you ask?LYNNDo I make her proud? (2016-11-02) 不提雨，怎么描写雨很大？@吕不同 视觉： 水泥地上几粒西瓜籽，跳个不停。屋门前一口池塘，正吞吐透明的钉子。天地昏暗，一片朦胧，只有眼前的三棵树，像三只绿色灯笼，逐渐明亮。 听觉： 把无数只虾，倒在无限宽的薄铁皮上，你就能听到我头顶的声音。先是我的出租屋在响，接着是整个城中村在响。声音浩荡盛大，如潮水涌过头顶。又闷闷的，像人沉思时身体内部会出现的嗡鸣。 嗅觉： 气味出不去。风满楼。一栋楼的人都在点外卖，油烧茄子、黄焖鸡、辣椒炒肉、酸辣粉。在老家，这种天气下的饭菜，总格外可口。一是人被拦在屋里，无所事事，饿会被放大。二是临近饭点，闲人便挤满厨房。一碗菜经手多人，最后盛在碗里，端上桌，样子总比一个人做出来的要热闹。味道尽管怪异，却因新奇而令舌头误以为是可口。何况这回，盐还是自己放的。 (2020-10-30) 「打工人」梗爆火，说明了现在年轻人一种什么样的心理状态？@李小粥 这是一个很重要的信号。以前，年轻人把工作称为“干事业”“拼前程”，这些词汇是一二十年前常见于网络和媒体上的，但是这几年，年轻人却赤裸裸的把工作称为“打工”，甚至自嘲为“社畜”，这就是在解构和矮化“工作”这种行为。影响更深远的是，这是一种群体行为，越来越成为年轻人的共识。我自认为是打工仔，这不重要，重要的是，一群人都自认为是打工仔。什么意思，以前我们不会用打工仔形容自己，那么劳动者之间就缺少共同语言，会容易被资本分化的，比如金融从业者看不起程序员、程序员看不起门店导购。劳动者被区隔开来，就形成不了共同话语权，影响力就被潜在的剥夺了。而现在，这种区隔正在渐渐消除，无论什么样的劳动者，都渐渐意识到，自己都是“打工”的一员，无论从事的行业光鲜与否、无论收入高低，其实一个阶层。这就不得了了。虽然现在的情形，表现出来还只是一群年轻人用“梗”的方式在自嘲，但这种方式无形中就拉近了所有劳动者的距离，起到了凝聚的作用，久而久之，就会产生更深远和深刻的作用。这种影响到底如何，我不知道，但是我觉得更多年轻人在意识到一些真相，并对资本产生了一些共同的情绪，只是现在以“戏谑”的口吻在表达，但可能用不了多久，就会从“戏谑”转为“严肃”了。作为广大“打工人”的一员，我乐见这种情形的出现。别忘了，相较于少数资本群体而言，我们打工人，才是社会的主要组成部分。____________________果然，网络上一些人已经开始利用“打工人”这个词，甚至把“打工人”和消费主义下的“尾款人”相提并论，还有一些年入千万的大明星甚至也在用“打工人”来描述自己的日常工作。这是什么意思？这就是为了消解掉一个话题的严肃性，企图用娱乐性的方式去解构掉这种趋势。不过，这也正说明“打工人”这种词汇越来越深入人心，所以才有引来一堆人想争夺它的解释权。但事实证明，大部分劳动者是清醒的，我们被这种小把戏忽悠的概率越来越低。 (2020-10-30) 一句话的信息量能大到什么程度？ @微社交英语 前不久，英国举办了只允许用六个单词的微小说大赛。 01 02 03 04 05 06 07 08 09 10 11 12 其他的获奖作品如下： She was lovely.Then things changed. 她曾那么可爱。然后一切都变了。 One candle, unattended. Only ashesremain. 一只蜡烛，无人看管，蜡炬成灰。 I leave. Dog panics. Furniture sale. 我走了。狗狗慌了。家具卖了。 Imagined adulthood. Gained adulthood.Lost Imagination. 幻想长大。长大成人。幻想破灭。 Cancer. Onlythree months left. Pregnant. 癌症。三个月生命。我怀孕了。 Nothing todeclare. Much to remember. 想说的无话。想记住的太多 New start. Newyou. Not you. 新的开始。新的你。却不是你。 Relationshipexpires; leaves a bitter aftertaste. 恋爱过期；苦味犹存。 She‘s his love;he*s her wallet. 她是他的挚爱，他是她的取款机。 They livedhappily ever after. Separately. 从此他们过上了幸福的生活。分别 First Friends.Then Lover. Lost both. 分手之后，无法做朋友。 Two wives, onefuneral. No tear 他的葬礼，两任妻子，无人流泪。 Tow lovers. Oneparachute. No survivors. 一对情侣。一把降落伞。无人生存 \"I love youtoo,\" she lied. “我也爱你。”她的谎言。 He loves her,they*re *just friends*. 他爱她。他们“只是朋友”。 Fantasticweekend. Then he never called. 美妙的周末。没有然后了。 谭浩强在程序员圈子里的口碑如何？为什么？@立党 我今天就是来给谭浩强洗地的。 谭浩强写烂书没啥毛病，这是他的学术自由，他出版一本烂书既不违法，又没抄袭，不违反学术道德，你们真的没理由因为一本烂书而喷谭浩强这样一个90多岁的老大爷。 让你们读烂书的，是你们的大一计算机老师，他/她在市面上有10本以上的优秀C/C++教材的前提下，为了省事，为了能直接用去年的课件，为了不用备课闭着眼睛就给你们讲课，为了不用搞懂那些他也不懂的知识而轻车熟路地把时间浪费在i+=(++i)+(i++)这种东西上面，直接挑了一本垃圾的教材给你们当入门计算机的第一本书——这不是书作者的问题，这是你的老师失职乃至职业道德缺失的行为。 这么多人喷《谭浩强》，本质上喷的不是“谭浩强”这个写破书的老大爷，喷的是大学里僵化的、脱离一线工程和学术的教学模式，喷的是害自己读了垃圾教材的那个C/C++老师。 谭浩强一把年纪写了一本烂书，如果卖不出去，就不会害人； 然而全国的计算机课老师，千人一面，为了省事儿，直接用《谭浩强》，这才是毒害中国大学生的罪魁祸首。 如果王者荣耀引入友军伤害会如何？@Legendary 1、“韩信你快回来，别上去浪了”老夫子对捆住的韩信说。 2、“鲁班我帮你吸住李白了，你快跑！”“可是东皇，你吸的是我啊？！” 3、“听说对面的泉水喝起来是草莓味的，不信你们尝尝”鲁班大师把队友往敌方泉水一推。（体验服鲁班大师刚出来的时候我就被这么推过） 4、“百里守约你别狗后面狙了，上去a两下啊！”项羽将刚架好枪瞄准的守约推进了团战中心，霸王粉色！！！ 5、“我开大了，快过来我给你们奶！”蔡文姬带着黄绿圈圈冲队友们喊，“奶可以，求求你别二技能晕五个了” 6、中路诸葛和司马懿战得如胶似漆~百里守约草丛中瞄准了敌方诸葛亮，枪响过后，手持黑色巨镰出现在诸葛背后的司马懿缓缓倒下，诸葛无力跪倒在地，抱起怀中冰冷的尸体，失声痛哭。 7、鲁班借助视野，精准一炮抢掉了猴子的红buff，之后，战场呈现了三打五的局面，鲁班和猴子不知去向。 8、由于无法自由选择攻击对象，貂蝉的二技能全部打到了队友身上，造成了大量的真伤和减速，从此貂蝉成了很不受待见的法师英雄，与之有相同遭遇的还有妲己、婉儿、芈月和诸葛亮等人。 9、明世隐经常因为走神，让本就残血的队友雪上加霜。 10、鬼谷子开启二技能，但是感觉时机不好，于是掉头朝队友冲去，身后跟着蠢蠢欲动的敌方五人。 11、队友表示禁止哪吒在有队友残血要回城的时候开大，兰陵王甚至极端地表示如果队友选哪吒，他就六分投。 12、被敌方追击，苏烈回头一个完美大闪击飞敌方五人，队友见状位移紧跟，结果因为敌方五人的落地伤害而导致团灭。 13、胶着的十人团战在龙坑打响，眼看胜负难分，武则天一个大招，全峡谷顿时只剩女帝一人。 14、关羽成功绕后，开启大招把队友顶了个七荤八素。 15、吕布大招入场，天魔降世，方天画戟一击之下，两千多的真实伤害瞬间取走三名队友首级。 16、团战双方越打越冒火，奕星见状及时开大，大家都有节奏地扭起了舞。 17、为了缓解中路的危机，西施用大招激活了两段一技能，将正在打蓝的韩信强行带到了中路草丛埋伏。 18、鲁班和鲁班大师遭遇敌方三人埋伏，鲁班求生心切，回头一炮将爸爸推向敌方魔爪，谁曾想魔高一尺 道高一丈，鲁班他爹反手大招将心爱的儿子拉回身边，回手一推将儿子送入三人合围之中，扭身在儿子凄惨的叫声中扬长而去。 19、“奇怪，为什么我的血量一直这么健康？”东皇百思不得其解，身边只剩个血皮的后羿瑟瑟发抖，“皇爷，一会儿开大的时候记得用头像锁定。” 20、这已经不知道是第几次张良放大死死地按住草里冲出来想切对方法师的韩信了，他委屈道：“你下次出来可不可以离对面法师近一点。” 21、李白最近很开心，因为他身边跟了一个廉颇，他再也不愁打团大招都刷不出来了。 22、遭到身边射手的一致嫌弃之后，东皇太一无奈找到了扁鹊，“要不我来辅助你吧。” 23、高渐离表示自从有了这个设定，他打团往里冲更猛了，杨戬也表示，打团的时候自己就像带了净化一般(经评论指正，杨戬的被动是有上限的)。 24、打团的时候，大家一致要求，让钟馗站在最前面，钟馗牺牲后，敌我双方都很默契地将他的尸体围了一个圈。 25、盾山在团战中心竖起了大招，双方在数次互相冲锋均被弹回后，一致表示等待盾山大招结束后再进行团战。 26、激烈的团战开始了，因蓄力没能赶上队友步伐的盘古， 只能眼睁睁看着五道裂痕劈向了前方的队友。 27、“你们真没用！这么多人竟然还能让我断大！”露娜冲着四名队友发起了脾气。 28、“我控住了五个，你们快来！”墨子张开双臂冲着身后的队友大喊，看着他身边环绕的绿色电蛇，队友陷入了沉思“上还是不上，这是个问题。” 29、李白借廉颇刷了个大，刚两段穿刺进入团战，不料队友后羿支援的大鸟及时赶到，将他定身于团战中央，李白又一次体会到了团战还没放大就死的感受了。 30、沈梦溪觉得今天开启二技能后跑的很慢，看着脚下的灼烧效果，回头看到一脸慈祥的姜子牙爷爷“孩子慢点跑，别摔着啦。” 31、队友多次对于黄忠和狼狗随意在草里丢弃地雷陷阱误伤自己人的事情表示强烈谴责。 32、火舞刚开始练习一闪，由于没有控制好距离，将我方四人打残，并推进了敌方防御塔内。 33、李元芳对着身上挂了三层镖的哪吒说，“吒儿，这次能不能对敌方后排造成出其不意的毁灭性打击就看你的了。” 34、由于没有把控好时间，带着三层李元芳被动的哪吒在飞行途中爆炸，并意外带走了残血打蓝buff的队友李白，自己也因血量不佳而落地成盒，面对偶像李白大人的谴责，李元芳将锅都推到了哪吒身上。 35、米莱狄因为手下小机器人们的胡乱攻击行为遭了队友的谴责，但是出人意料的是，一向脾气不太好的露娜小姐和李白大人对她却出奇地宽容。 36、马可波罗的一梭子子弹被自家米莱狄的小机器人悉数挡掉。 37、继太乙后，米莱狄的机器人成为了团队额外经济的又一个主要来源。元歌的傀儡曾经也被队友觊觎，但由于技能cd太长，代价太高而只能作罢。 38、排位中，元歌用傀儡化身成了自家后羿的样子，成功掩护后羿撤退，后羿对此感激涕零，表示以后再也不会去贪傀儡那20块钱了。 39、张飞一个飞跃为自家的队友套上护盾，丈八蛇矛一转又将护盾悉数击破，队友不解，飞曰：“这样我攒能量的速度就能翻倍了。” 40、每当刘禅和盾山血量不佳时，他们就会很有默契地来到自家防御塔下，一通不可描述的操作后，两人带着满满的血条满意而归。 41、最终后羿和东皇还是达成了和解，因为在东皇用球碰后羿的时候，后羿的分裂箭也总往东皇身上射，最后他们互相流淌着对方的血液。 42、玄策打算进入团战了，他看了一眼刚刚死里逃生的队友：“为了让我的飞镰兴奋起来，抱歉了。” 43、经过详细复杂的数学计算后，吕布表示吸一口队友可以让团队的血量在整体数据上增加，芈月表示赞同，但是其他队友表示强烈反对。 44、“我给你们叠被动，给你们奶血，我做错了吗？”扁鹊委屈地喊到。“叠被动奶血可以，但是你一直a我们来叠被动是什么意思？” 45、诸葛看到自家韩信丝血被敌方李白追杀心急如焚，二技能闪现赶路，然而却在李白开出大招的时候掏出了元气弹，韩信停下看了看自己身上的那根线，叹息一声回身走进了李白的大招里。 46、“你没事吧，我刚刚用二技能帮你挡了一只鸟。”公孙离对残血的裴擒虎说道。裴擒虎摸了摸她的头“傻兔儿，那是咱家后羿的。但是，谢谢你。” 47、虽然裴擒虎对阿离充满了宠爱，但是诸葛已经陷入癫狂了，他哀求公孙离“求求你放过我的被动吧，好不容易攒的，还没来得及用呢，你一来转个圈就全没了。”他的身后还跟着死死抱住自己大飞镖的李元芳。 48、瑶太可爱了，队友总是忍不住突然吓她一下，看着她变成小鹿蹦蹦跳跳的样子，直到东皇太一跟在瑶的身边才有所收敛。“谢谢你，小蛇。”“没关系，小鹿。” 49、马克总是沉醉于自己开大后四处挥洒弹幕的感觉，在多次造成队友伤亡后，队友表示如果他再不知道自己停下来的话，四个人的控制技能都将会为他保留。 50、这把开局后，韩信一直找不到自家张飞的下落，直到有一次他准备惩戒收红buff的时候，红buff突然跳墙逃走了。 51、队友表示，如果昭君能更多地预判敌人而不是预判队友，他们还是很乐意和昭君一起玩的。 52、“我觉得我们应该把目光放长远，更多地去考虑后期的团队实力，而不是短期内的一些小伤亡。”“我觉得你说的对。”“典韦干将你们两个够了！！！” 53、达摩和阿珂已经追了敌方韩信三座塔了，再追不上就真的让他跑了，达摩看了阿珂一眼，叹了口气：“女施主，得罪了！”遂一拳将阿珂锤上墙，一技能接大招二段将韩信击杀。 54、达摩和阿珂又追了敌方韩信三座塔，再追不上就真的让他跑掉了，达摩再次看向阿珂，还不等达摩说话，阿珂先行一步：“光头，得罪了！”遂一技能接斩杀击杀达摩，开启大招向前方的韩信追去 ，“此去追敌，路途险阻，怎能让你陪我同去。” 55、“师父！不要啊！！”兰陵王看了看自己腰上缠着的钩镰，望了望身后眼泛泪光的玄策，叹了口气，“徒儿，我知道那是你的哥哥，但，他终究还是站在了我们的对面，你下不了手，就让为师去吧。”“不是师父，你难道没发现你已经被我哥的眼看到了吗？求你别再上去送人头了！”“……” 56、由于沈梦溪王昭君和周瑜的存在，大家约定，等双方都做出魔女斗篷之后再进行大规模团战。 57、自从有了队伤设定，以后羿鲁班大小姐等射手为核心的养猪流逐渐没落，以高渐离为核心的“摇滚乐队粉丝后援团”式打法逐渐兴起，队友将高渐离紧紧围在中间，看着他用自己的二技能缔造一个又一个的医学奇迹。 58、虽然已经开启了队伤设定，但仍有很多射手习惯于在等兵线的时候平a，这种无意义的行为收到了辅助们的一致谴责。 59、姜子牙和鲁班大师给队友们展示“弹弓流”骚套路，但是由于姜子牙没有掌握好时机，一个蓄力满大全刮在了身后瞪眼看着的队友身上，之后，迫于队友的压力，“弹弓流”销声匿迹。 60、成吉思汗抱怨自己的坐骑发春了控制不住，队友表示愿意帮忙，于是成吉思汗身的狼狗身上多了四根链子，分别来源于大乔、玄策、明世隐和芈月 诸葛曾表示他也有链子，但被成吉思汗拒绝了。 61、激烈的团战过后，大乔将四个残血队友集合进圈，随后一个大招拿下四杀。 （更新至2020-06-14） （截止2020-12-12未更新 作者又鸽了-_-） 今年需不需要存粮食？@龙牙 有必要，现在就可以开始有序囤积一些食品和慢性病常用药、家庭常用药。 倒不是真的会有什么灾难、有什么变故，而是今年必然是一个恐慌情绪高发的年头，你很难预测这种恐慌情绪的高峰会是什么时候，恐慌起来会导致什么物资短缺。那么咱们就从自己生活需要出发，囤积一些生活必需品，先确保生活正常开展就行了。 需要注意的是，这些生活必需品，国家都是有战略储备的。恐慌情绪完全不必要，支持生活开展的物资都是有天量储备的，不用担心完全枯竭。比如粮食储备，国家的战略储备量是高度机密，但是根据猜测在18个月到5年的正常消耗量。像2011年日本海啸引起的食盐抢购，实际上中国的食盐根本都不需要储备，玩儿命开工的话，一天的产量够你吃一年。 所以恐慌完全没必要，你就按照预防抢购的标准来就是了。 请严格记住：我们的储备是为了防止恐慌情绪引起的物资暂时性短缺。 这种暂时性短缺，最多只会持续一个月时间，一个月之内国家一定会动用储备物资平息恐慌。我们只需要在这一个月的时间内确保有储备物资，不参与抢购就行了。因此现在我们需要有序的进行物资储备，不要临时抱佛脚，也不要煽动增长恐慌情绪。 我们只需要严防恐慌。物资本身并不会短缺，无论是粮食还是别的生活必需品。 我个人建议储备以下物资： 1、一个月的主粮，大米还是面粉就看你个人口味了； 2、家庭常用药，包括外伤用药，酒精碘伏这些，纱布、绷带；感冒药；止泻药；广谱抗生素；多元维生素片（药用标准）。 3、慢性病人用药，高血压病人的硝苯地平类药物；糖尿病人的胰岛素；其它慢性病的必需药。建议根据药品的保存条件和保质期，自行决定储备量。 4、家庭清洁用品和洗涤剂、消毒剂，牙膏、洗衣液、洗洁精、洁厕剂、卫生纸可以储备一些，一两周的量就足够了。 5、足够的知识，保持冷静理智，不要随大流，不要恐慌！要相信中国是世界工厂，中国不会真的出现物资短缺，任何情况下、面对任何困难，中国都至少能够保证人民正常生活！ 恐慌情绪有可能来自于民间自发，也有可能来自于别有用心的人炒作，甚至有可能来自于境外敌对势力的挑唆、造谣、攻击。 因此我们在现在还没有任何恐慌情绪的时候，有序的储备一些生活必需物资，也有助于抵抗这种谣言进攻，有助于保持社会稳定。 我个人的影响力有限，知乎这个平台也不像微博那么不理智，希望看到此文的朋友能够理智冷静储备一些生活必需物资。在您自己完成储备之后，再通知、提醒您的朋友、亲戚进行物资储备，提高我们国家民间抵抗造谣、恐慌的整体能力。这样我们可以把物资挤兑控制在一个很合理的区间，不对市场造成大的影响。 恐慌情绪是一个值得警惕的敌人，会造成难以预料的后果，希望我们能够万众一心，共同应对。 （2020-03-27） 如何看待全国或将禁食狗肉？@Hey Guy 首先说明，我不吃狗肉，在看到别人吃狗肉的时候甚至会反胃，我会请求对方不要在我面前吃狗肉，而不是一刀切禁止别人吃。针对你的回复，我再回复一下。 1.我没有亲眼见过肉狗养殖场，但是我当过流浪狗喂养志愿者，亲眼见过几十条流浪狗养在一个小房子里，说实话，并没有觉得环境很差（也许是因为我没有见过大规模的养殖场）。相反，我去过养猪场，三百头猪，环境更加恶劣，距离大老远的地方就臭得要命，而且排水之类的都需要通过环保处理；而且不人道，一头猪占一点点地方。 \\2. 如果养殖效益不高，那即使不禁止食狗，也不会有人养，而事实上在天眼养上能找到4万多家与狗肉有关的公司，有人养说明有一定的经济效益。至于相关的养殖标准，目前农业部出台有《犬产地检疫规程》，暂无养殖、屠宰等相关标准——但是，没有相关标准并不是禁止食用的前提，没有相关标准就需要制定相关标准，而不是一刀切直接禁止。比如说，征求意见稿中的传统畜禽中，骆驼我就没有发现有相关的养殖&amp;屠宰标准。如果有找到的，可以指出。\\3. 规模化养殖技术多方面研究并没有出现，容易爆发疾病。这个是当下国情所考量的。——这点我是赞同的，但是当下国情考量的是未经安全认证的野生动物，我国吃狗已经有几千年历史了，时间已经证明食狗没有安全问题。农业部征求意见稿认定有18种传统畜禽，凭常识说，你觉得狗是不是传统畜禽？ \\4. 我考量对立面的时候，并没有打上“爱狗人士”的标签，在我的认知里，对于吃狗，有两种人：一种是不吃狗的；一种是吃狗的。不吃狗的人里又分三种人：像我这样不吃狗、但是不禁止别人吃狗的；不吃狗同时要求别人不吃狗的；还有就是不吃狗，同时强烈反对别人吃狗的，被他知道你吃狗跟你誓不两立的那种。一个社会，发声的永远是反应最激烈的那部分人，事实上大多数人对是否立法禁止食狗是无所谓的，因为没有触及他们的利益；因此，强烈反对的即我口中所说的“爱狗人士”，禁止相关养殖屠宰标准出台、强烈要求立法禁止食狗，他们的数量不见得多，但是声量绝对大。 \\5. 我当然只摘取了食狗的片段，当时也是很多人不吃或者反对的。我认为这个观点站不住脚，现在也有很多人不吸烟或者反对吸烟，甚至已经立法禁止在公共场合吸烟，但是到现在都没有立法完全禁止吸烟。这是不是可以视作你这个观点的反例？ 最后，我想说的是。我反对征求意见稿，并不是因为我喜欢吃狗肉，事实上我喜欢狗，家里最多的时候养了8条狗，但我能分辨我是对我养的宠物狗以及其他宠物狗和服务犬的喜爱，因此别人吃狗的时候，只要不是偷的或者宠物狗，我都接受。 我反对的原因，在于征求意见稿把主观因素当作客观事实，它是这么解释的。 “关于狗。随着人类文明进步和公众对动物保护的关注及偏爱，狗已从传统家畜“特化”为伴侣动物，国际上普遍不作为畜禽，我国不宜列入畜禽管理。”——关于《国家畜禽遗传资源目录（征求意见稿）》的说明 这种解释是以偏概全，怎么定义伴侣动物，国际上普遍不作为畜禽但是也没有禁止食用啊（据我了解，美国也只有一个州明确禁止食用狗肉，韩国更不用说了）；而且，广西玉林狗肉节、朝鲜族有吃狗肉的习俗、沛县狗肉还受农业部批准农产品地理标志登记保护……我反对禁止吃狗，不是因为我吃狗，而因为今天可以因为主观因素禁止吃狗，明天是不是可以因为主观因素禁止吃牛？牛也是我们的好朋友啊，黄牛伯伯多辛勤。如果征求意见稿给的解释是狗肉可能造成传染病，我倒还能理解，但是这么主观的“伴侣动物”，我无法理解，也无法赞同。 尊敬的农业农村部， 您好！ 贵部日前发布关于《国家畜禽遗传资源目录》公开征求意见的通知，本人对征求意见稿中关于狗的部分有异议，特写此邮件，建议将狗列入《国家畜禽遗传资源目录》，理由如下： 1. 我国食用狗肉历史悠久。 我国食用狗肉的历史最早可以追溯到新石器时代，汉字“献”就与狗有关，东汉许慎在《説文解字》中说道：獻，宗廟犬名羹獻。犬肥者以獻之。从犬，鬳聲。意思是宗庙祭祀时用的犬叫作“羹獻”，挑选膘肥体壮者祭献。从商纣时期只有贵族能吃上狗肉，到春秋战国很多普通人开始吃上狗肉，甚至出现专业的“狗屠”，如战国时期有名的刺客聂政、高渐离，以及秦末的樊哙都是“狗屠”出身，这都说明我国很早就已经有食用狗肉的习俗。 《文子·上仁》云：“先王之法，犬豕不期年不得食。”《礼记·内则》上载有“犬宜粱”、“狗去肾”、“狗赤股而躁、臊”等内容。这些关于吃狗肉的经验之谈，也说明在古代狗肉已是人们普遍享用的肉食品，而且形成了完备的烹制之法。 2. 食用狗肉有其文化背景。 食用狗肉深入民心，很多名人好吃狗肉。如郑板桥，如周恩来总理。《水浒传》中，鲁智深在杏花酒店看到狗肉，大喜，用手扯着狗肉，一连吃了十来碗酒还不肯罢休。长期以来，我国还形成了许多与狗有关的典故和俗语，如“挂羊头卖狗肉“、”仗义每多屠狗辈，负心总是读书人“、“狡兔死，走狗烹”、“冬至鱼生，夏至狗肉”等。 3. 食用狗肉能产生经济效益。 如今我国很多地方还保留着食用狗肉的习俗，如广西玉林狗肉节，每年举办，已经成为当地一大特色，也吸引了很多游客。此外，江苏省徐州市沛县特产狗肉，《中华人民共和国农业部公告第1351号》正式批准对“沛县狗肉”实施农产品地理标志登记保护，沛县狗肉也成为当地的一大经济来源。这说明，食用狗肉并非少数人的癖好，而是具有群体基础的，同时还能产生经济效益。本人注意到关于《国家畜禽遗传资源目录（征求意见稿）》的说明中，有关于狗的解释，称随着人类文明进步和公众对动物保护的关注及偏爱，狗已从传统家畜“特化”为伴侣动物，国际上普遍不作为畜禽，我国不宜列入畜禽管理。本人也有异议，理由如下：\\1. 宠物狗、导盲犬、警犬等特种服务犬可认为伴侣动物，禁止食用，本人同意。然而还有很多肉狗，如沛县狗肉，是由人工饲养的专用食用的犬类，本人认为不应该列为伴侣动物。因此，应当将狗、尤其是食用狗列入《国家畜禽遗传资源目录》，而不应该一刀切，禁止所有狗肉食用。否则，对沛县等高度依赖狗肉经济的地区会带来极大的经济损失。\\2. 针对国际上普遍不作为畜禽这一说法，本人有两个观点。首先，对于未列入《国家畜禽遗传资源目录》的动物，即无法销售和食用，而国外禁止销售、食用狗的国家较少，如美国只有纽约州明确禁止以肉用目的屠宰犬类，其他州并无明文立法禁止食用狗肉；又如韩国素有吃狗肉传统，也未立法禁止狗肉食用。其次，各国法律法规应考虑各国国情，不应当以“国际上普遍不作为畜禽”为理由，而忽视了我国国情。法律法规应倾听民众的声音，但要超越民众的偏见。目前国际上、国内对禁止食用狗肉的呼吁绝大多数来源于“爱狗人士”，他们认为狗是人类的朋友、为人类做出巨大贡献，因此不能食用。我想请问，什么是“人类的朋友”？宠物狗是人类的朋友，看门狗是人类的朋友，但养来吃的狗算吗？我认为不算。不能因为少部分“爱狗人士”的偏见，而立法禁止。如果这样的话，为了是尊重某种少数民族的宗教信仰和生活习惯，是否应该禁止食用猪肉、牛肉？我认为不是，国家保护宗教信仰自由，同时也保护没有宗教信仰的自由，希望贵部能多倾听人民群众的意见，无谓让噪声影响判断。希望我的邮件能准确清楚表达我自己的意见，也希望贵部多加考虑。谢谢。 (2020-04-11) 相亲男生骄傲称不抽烟不喝酒，不打游戏不出去玩，这有什么值得骄傲的吗？@奉御卿 就像你问别人以下这些问题 长的高有什么好骄傲的？身材好有什么好骄傲的？长得好看有什么骄傲的？家里有钱有什么好骄傲的？学历高有什么好骄傲的？ 总有人得来这些毫不费力，也总有人要拼尽全力才能获得。 不抽烟，不喝酒，不赌博，不玩游戏。这些其实是一些不错的优点，至少对以后家庭稳定还是挺重要的。如果觉得这些没啥好骄傲的。只能说你不看重这些，或者有些事情没有经历过，所以才会觉得没啥可骄傲的。 稍微补充下： 我从来没说做到不抽烟，不喝酒，不打游戏，不喜欢出去“玩”。就算优质男了，我只是觉得这些算优点，是加分项。可以在相亲的时候说。 历史上有什么事件让你相信有国运这个东西存在？（国运这个词语很玄妙） @二月乌 中国近20年的好运气，让你不得不相信“国运”。 史无前例的“奇葩”美国总统特朗普、前无古人的世界病毒之王COVID-19，远的再加上电影编剧都不敢想的911奇袭美国。20年来这几件匪夷所思、宛如小说情节般的黑天鹅事件，连续三次打乱了美国试图围剿中国的修昔底德陷阱。历史上，挑战大英帝国的德国、挑战美国的日本帝国和原苏联，都没有遇见这种事，只能和第一强国正面硬杠。 结果是中华民族伟大复兴在最危险的阶段，获得了20年的战略机遇期，至今没有陷入“修昔底德陷阱”。 咱们就来分析下这几件意外事件对中国国运的影响。 实际上，从90年代末，连续三任美国总统都举起了“围剿”中国的大棒。然而，都因为意外被迫放下。 一、911事件，2001年，中国GDP达到美国的八分之一。 上世纪90年代末，苏联解体并失去威胁后，俄罗斯也日渐没落，中国被克林顿当作下一个敌人。彼时中国的经济总量只有美国的十分之一，且在90年代经历了严重的通货膨胀，1994年物价上涨率一度曾达到27.4％，正处于经济孱弱、亟需补血的境地。经济实力不济的情况下，更加没有余力升级军事力量，海空军战斗力与美国天地之差。美国只要认真起来，中国的崛起道路必然被打断。彼时美国的策略是软硬兼施，用意是施压中国、改造中国。 硬的方面，60—80后的朋友应该都还记得吧。1999年，克林顿总统时期，美国出动隐形轰炸机，摧毁了中国驻南斯拉夫大使馆，声称是“误炸”。此举是赤裸裸的挑衅，如发生在当年美苏之间，几乎等同于两国宣战，美国绝不敢“误炸”原苏联甚至俄罗斯的大使馆。由此可见美国当年对中国的蔑视和敌意，然而中国当时的国力也只能卧薪尝胆。当年我在北京读书，还违反学校禁令偷偷跑去见证了愤怒的大学生们向美国大使馆丢墨水瓶的壮举。也只有这点动静了。而且，尴尬的是，不少天之骄子丢完墨水瓶，回去还得继续准备托福、GRE考试……没办法，人家不光航母飞机甩中国几条街，高等教育也是如此。想要“师夷长技以制夷”，不受点委屈怎么行。 软的方面，便是推广“普世价值”，用人权来打击中国。那个时候国内人权斗士遍地走，加上互联网刚刚兴起，中美生活水平差距巨大，美分公知影响力与日俱增，以至于中国不得不“稳定压倒一切”。当然，客观上也提醒了中国在经济发展的同时重视法治和文明，比如对滥用职权和腐败的打击，对依法治国的重视，对劳动者和边缘群体的保护等。以至于今天通过弗洛伊德事件我们发现：至少在文明执法领域，中国可以当美国的人权导师了。 2001年，小布什上台后变本加厉。在对华政策方面，小布什放弃了克林顿时期关于建立中美“战略合作伙伴”关系的表述，将中美关系定位为“战略竞争对手”。公开表示克林顿政府对华政策太软弱，应当增加强硬的成分。美国在中国南海挑衅性常规巡逻，经常突入中国领空侦查。 随即，在2001年4月1日，发生了中美南海撞机事件，飞行员王伟牺牲。但彼时的中国没有对抗美国的资本，在美国象征性道歉、承诺不再进入中国领空侦查后,交还了美国的侦查机和24名飞行员，息事宁人。对于撞毁中国一架战斗机并杀死一名飞行员，美国人侮辱性地提出赔偿3.4万美元，中国当然没要。 2001年8月11日，南海撞机事件表面上尘埃落地。按照正常的轨迹，小布什政府会继续对中国的围剿。但仅仅一个月后，爆发了“911”事件。 我至今还记得：当我和同学们在电视上看到美国双子大厦被飞机撞击，并随后轰然倒塌后，一个个惊掉下巴，感觉非常不真实，感觉像在梦游。恐怖分子同时劫持客机就已经够黑天鹅了，还能劫持客机撞大楼。撞大楼也就罢了，飞机怎么可能撞得过大楼？结果，两栋大楼居然戏剧性地轰然倒地，化为齑粉！其过程的戏剧性，连好莱坞大片的导演都不敢想。 随后，群情激昂的美国人发动了反恐战争。他们不会想到：这场战争持续了20年！为了取得反恐战争的胜利，小布什提出“不是美国的朋友，就是美国的敌人”。这话是嘴上硬，手下软，代表着美国的全球战略前功尽弃，向过去的对手伸出橄榄枝。美国需要提前预防能够让阿富汗变成第二个越南的中俄两个大国干涉，还需要中俄在司法、情报等领域的支持，因此对中俄大加笼络。其实中国一直想做美国的朋友，可惜美国人不肯接纳，这次终于有机会“上车”了。 2001年11月9日,美国总统小布什正式批准中国加入世贸组织。中国从1984年开始，绞尽脑汁，付出无数努力，17年都没有实现的“不可能的任务”，美国总统一句话就轻松解决了。若没有911，就算中国跟所有其他成员国都达成协议，美国也不大可能同意的。从此，中国加入了美国主导的世界贸易体系，勤奋的中国人付出两代农民工、两代留守儿童、四代996、四代环境污染的代价，多年保持两位数的经济增长，最终到今天成为“世界工厂”。 美国人没想到的是：中国人不仅能吃苦，还好学。制造业从进口、代工、山寨，一路升级到研发，随后不到二十年就走完了工业现代化道路。并且居然还在如5G这样的高科技领域领先美国。军事工业也突飞猛进，造船工业的产能甚至已经超过美国，军舰像下饺子一样服役，空军研发出J-20这样的第五代战机，成为与美国、俄罗斯比肩的空军强国。也许挑战美国还不足，但自保已有余，再也不会出现大使馆被炸不敢反击、领空被敌国随意入侵只能息事宁人这样的糗事。 在德国崛起的过程中，没有任何意外逼迫大英帝国停止遏制德国且与之联手。日本昭和一代挑战美国的过程中，也没有出现打断美国封锁日本的意外事件。国运这种事，你能不信吗？ 二、特朗普上台，2016年，中国GDP达到美国的61%。 在此过程中，随着中国经济的飞速增长，美国政治精英对中国崛起的焦虑也与日俱增，奥巴马总统险些把中国崛起绞杀于半途。 2011年，中国GDP达到美国的49%，美国政治精英已发现了反恐的战略失误，以及中国不吭不哈的崛起。于是，奥巴马政府提出“重返亚太”。2012年，日本议员登上钓鱼岛。随后，香港“爱国人士”登岛保钓（所以香港必须得有安全法），打破了中日韩建立自贸区的尝试，引发了中日钓鱼岛事件。 此事影响深远，导致中日民众之间通过改革开放34年经贸、文化往来积累的互信被严重破坏。日本国内的亲中派遭遇失败被边缘化，甚至有些政治家离奇死亡，日本只好继续当美国的看门狗，潜伏爪牙忍受。而中国想要拉拢第一岛链最关键的棋子日本，也不得不考虑民间舆论压力。 美国还不断加强与东南亚各国的军事合作，在朝鲜半岛进行大规模军事演习不断刺激朝鲜这头一见红布就冲的公牛，还试图在韩国部署“萨德”导弹。总之，在中国周边制造事端，让亚太局势不稳。如果中国被激怒而动粗，那就会重蹈德国覆辙，正中美国下怀。即使中国不上当，周边国家也会因为局势的不稳而选择加强与美国合作防范中国。其战略无懈可击。 最阴险的“阳谋”，就是奥巴马提出的“TPP”（跨太平洋伙伴关系协定）。奥巴马已经看出中国崛起的关键：加入世贸给中国经济注入的资金、技术以及广阔的国际市场。但废除世贸动静太大，把中国开除也比较难，虽然没有间断过尝试（不断起诉中国违反世贸协定）。不如重起炉灶，架空中国。“TPP”将亚太周边几乎所有国家纳入“亚太自贸区”，意在用越南等发展中国家取代中国的世界工厂地位，将中国崛起的经济基础釜底抽薪。并且用经济利益捆绑政治利益，构建范围更广阔、利益更牢固的环太平洋封锁链。 TPP在奥巴马任期内几乎已经建成，曾经引发中国的恐慌，但阳谋无解。可惜，出现了黑天鹅事件。2016年，美国历史上最奇葩的总统、“懂王”特朗普当选！美国围剿中国大业功亏一篑。 特朗普当选，绝对称得上美国政治史无前例的黑天鹅事件。在美国的政治设计中，本来像特朗普这种反建制的“素人”是绝无当选机会的。美国的政治精英和金融寡头结合，既控制了竞选资金，又控制了媒体，再加上选举人制度，以及“蝾螈选区”的划分，能当上总统的人虽然具有一定随机性，但其特点是一致的、服务的利益集团也是一致的。因此，政治观点和立场大同小异，保持了美国政治的稳定。 可惜，美国的政治设计中，没有计算到社交媒体带来的颠覆性影响。同时，像特朗普这种性格奇葩、自带流量、不缺钱、又擅长运营社交媒体的妖孽，也是百年不遇。煽动群众天份有点希特勒的影子。但希特勒热爱学习（流浪期间借阅了维也纳图书馆40%的藏书，拿着救济面包、披着肮脏的大衣，蜷缩在图书馆最偏僻的角落把这些书看完了）、深刻领悟政治，特朗普却是不学无术的“懂王”；希特勒放手任用专业的容克军官团，特朗普却不断炒掉专业敬业的内阁成员，剩下一堆趋炎附势的马屁精；希特勒的外交政策正中当时国际关系要害，特朗普的外交政策则觉厉不明。 本来，特朗普就算再奇葩，至少在打击中国方面应该延续奥巴马的政策。但无巧不成书的是：特朗普居然和奥巴马结下了不死不休的梁子，个人恩怨压倒了国家利益。特朗普在奥巴马竞选的时候质疑奥巴马并不是出生在美国，明摆着拿奥巴马的非洲血统“哪壶不开提哪壶”，刺痛了奥巴马作为黑白混血内心最深处的自卑。 奥巴马当选总统后，却也小肚鸡肠，毫无一国领袖的气度，利用职务之便，连续多年在公开场合羞辱特朗普：上任第一年白宫晚宴，特朗普兴冲冲去捧场，奥巴马狂涮其半小时，全程电视直播，特朗普敢怒不敢言，恨不得找个地缝钻进去；第二年白宫晚宴，特朗普寻思着事情过去了，又去捧场，结果晚宴一开场，奥巴马张口就是“特朗普怎么在啊?还在啊？您来有何贵干？特朗普再次恨不得找个地缝，现场名流和美国人民再次获得半小时的欢乐；第三年白宫晚宴，老特不去了，奥总却还揪着不放“特朗普在哪儿？特朗普怎么没来啊？前两年咱们玩的可开心啦，这里这么多记者和摄像机，他最喜欢啦，这都不来…..”，三涮特朗普，全程直播。奥巴马任内，特朗普在美国名流圈灰头土脸、颜面全无。但总算悟出了一个道理：钱不胜权！ 特朗普8年间积攒着对奥巴马的仇恨，暗暗在家憋大招。2016年，特朗普居然黑马逆袭，将共和党内定总统小小布什、民主党内定总统希拉里先后拉下马，当选第45任美国总统！这下轮到奥巴马灰头土脸了，故作大度赞扬了特朗普，并积极配合权力交接。可惜特朗普不吃这套，上台第一件事，就把奥巴马最珍视的两个政治遗产——全民医保和TPP，一股脑全给废了。 特朗普是爽了：开发商报仇，八年不晚。但TPP大杀器废了。看到老大居然否决了就差最后一步的TPP协议，一堆环太平洋小伙伴目瞪口呆、不知所措。美国国际信誉扫地。同时，鹰酱们筹划多年的遏制中国战略黄了，新的战略则青黄不接。导致特朗普政府除了杀敌一万自损八千的贸易战外，就不知道该干啥了，有战术而无战略。 与此同时，特朗普政治根基不稳的缺陷，导致他不得不伤害美国长期利益，用短期利益换取核心选民支持。包括故意煽动种族对立以稳定其核心票仓。以及把“美国优先”作为纲领，破坏了美国延续70年的同盟战略，沉重打击了盟友对美国的信任。 结果，美国承袭大英帝国的以多欺少外交策略失效，美国不得不在没有盟友全力支持的情况下，自己与中国单挑。同时，又为了保护极少数美国农民的利益，在制裁中国的手段上捉襟见肘。 煽动种族分裂的言论，导致了种族分裂表面化，激化了弗洛伊德被跪杀这样的黑天鹅事件，捅了美国种族歧视的马蜂窝。结果被同样没有节操，只要大选利益、不顾长治久安的民主党利用，不仅不灭火还煽风点火，特朗普陷入攘外必先安内的困境。 因此，特朗普任期中，打乱了美国的节奏，暴露了美国的底牌，疏远了美国的盟友，激化了美国的内斗，不仅没有阻遏中国崛起，反而唤醒了中国民众、打脸了亲美“公知”。以至于中国网民纷纷认为，没有间谍能够比特朗普做得更好，亲切地称之为“同志”，支持其再干500年。 特朗普上台，是多重巧合阴差阳错的结果。大英帝国的历任首相都是稳定的，没有出现过素人成为首相这样的黑天鹅事件，历任首相也基本保持了大英帝国对外政策的一致性，即离岸平衡策略。所以，德国没有类似中国的好运气，德国做梦都想和大英帝国1v1呢，可惜没机会啊。美苏对抗时期，哪怕名誉扫地的尼克松，也是高瞻远瞩的战略家，冷战期间美国没有出现过类似特朗普这样完全蔑视美国外交传统的总统。苏联没有中国这样的好运气，被迫面对多如牛毛，并且更加多如牛毛的美国盟友和战略伙伴。不得不说，这是中国的国运。 三、新冠病毒，2019年，中国GDP达到美国的68%。 本来，哪怕特朗普再不靠谱，至少美国从精英到民众都已经形成共识，一致把中国当成对手。本来美国就算单挑中国，也照样够中国喝一壶的。如果美国全力出击，比如按照米尔斯海默的“进攻性现实主义”理论，在美国具有相对优势的时候全面出手，把中国威胁扼杀于萌芽，中国的崛起之路将风险大增。实际上，美国从上到下，逼迫中国走进修昔底德陷阱的战略意图已经很明显了。 谁能想到，在这样世界百年格局大变的关键历史节点上，居然发生了新冠病毒这样黑到伸手不见五指的黑天鹅事件！人类历史上有可以与之相提并论的病毒吗？没有，没有任何病毒曾迫使全世界所有国家封城！史无前例。 历史上，鼠疫杆菌传入西方的结果，是人口减少三分之一，被东方压制300年。天花传入美洲的结果，是90%的人口死亡，美洲文明消失。从历史前车推测，新冠病毒的后续影响之深远，我们目前的想象力根本到达不了。 中国在新冠病毒防控中的神表现，对比美国为代表的西方“自由世界”的“骚操作”，达到了苏联在1929-1933世界大萧条中一枝独秀表现同样的效果。 但中国为什么应对如此完美？因为哥们练过啊！中国在2003年经历过“旧冠疫情”——非典！头一次经历的时候，连北京市都带头瞒报，直到被网络媒体曝光才被迫公布疫情。但中国政府的纠错能力远超美国，美国应对疫情失职如此明显，至今死了13万人，但没有任何高官被问责，特朗普仍然坚持“没人比我做得更好”。而中国时任国家卫生部长张文康、北京市长孟学农仅仅是“非典”初期应对不力就丢了乌纱，成为中国高官因工作失职被问责的开始。2003年全国封城，北京、广东人到哪儿都被隔离。事后全国逐步建立了完善的疾控体系，各地都制定了完善的预案，做好了应对下一次疫情的准备。于是，2020年新冠疫情爆发后，中央一声令下，各地立即启动预案，24小时内连偏远乡村都被动员起来，960万平方公里土地上，13亿人加入抗疫洪流。全民团结如一人，试看天下谁能敌！ 若再给世界各国一次机会，肯定比现在做得更好。但非典只考验了中国。老子曰：祸兮福所倚，福兮祸所伏！一饮一啄，冥冥中自有天定啊！ 当然，换个角度说：其实中国已经给过世界一次机会了，本来2003年非典就会肆虐世界，只不过中国不惜成本为人类档了一劫。第二劫，中国也挡住了，还把教材公开了，专家都派出国，掏心窝手把手教。而且不仅没有发疫情财，还满世界捐赠紧缺防疫物资，连对正在制裁中国的美国都没有落井下石，给予了物资和技术支援。 只不过有些国家自认为比中国牛多了，瞧不起中国经验。他们觉得：这事儿不大，你看，连中国人都能搞定。美国更是把中国的好心援助当成驴肝肺，把自己的失职甩锅给中国，把病毒称为“中国病毒”、“武汉病毒”、“功夫病毒”，煽动对中国的仇恨来转移民众不满，多州居然起诉中国索赔。这就叫：天作孽，尤可恕；自作孽，不可活。 连续两次战胜史无前例的疫情，就不是偶然了。外部，发达国家和发展中国家的精英们，开始反思西方制度的不足以及东方制度的优越性。很有可能出现当年亚非拉精英纷纷把苏联模式作为强国之路选项，以及西方国家部分学习苏联模式优越性的局面，中国有可能获得更强大的国际软实力。 内部，中国民族自信空前高涨，美分公知再无容身之地，美国的和平演变政策宣告失败。哪怕对中国制度的批评都显得可笑了。中国无安内之忧，可以全力攘外。 在美国方面，形势则十分严峻，而特朗普只能穿着皇帝的新衣粉饰太平。按照福奇的说法，美国每天新增10万病例也不奇怪。美国已然放弃了对新冠病毒的抵抗，准备顺其自然了。照这样下去，美国三亿多的人口可能会有近两千万人死亡（考虑到目前医疗系统已经满负荷，病例再翻几倍的话，死亡率可能达到5%—6%），经济不受剧烈冲击是很难想象的。更严峻的是，美国的后院拉美也将成为病毒的天堂，对社会、国家的冲击远甚于美国，拉美将更加“拉美化”。印度这样的中国潜在对手，也可能因病毒陷入长期萧条，如果控制不住，以其人口基数，死亡人数很可能达到5000万人，经济陷入长期萧条。而中国则仅仅是外贸受影响，只要守住国境，则立于不败之地。 特朗普和西方领导人不断用疫苗给民众希望，但疫苗大概率作用不大。因为新冠病毒是RNA病毒，变异速度是乙肝等DNA病毒的100万倍！同为RNA病毒的流感、艾滋病病毒经过几十年研发都没有有效疫苗。原因在于变异速度太快，疫苗研发跟不上变异速度。而且变异后版本太多，目前的科技水平很难研究出适用所有变异版本的通用疫苗。 在这样史无前例的挑战面前，特朗普政府却毫无节制地提前打光了美国的子弹。2020年4月美债已达23万亿美元创新高。2020年财政赤字预计达3.8万亿美元，是2019财年的4倍。在疫情刚刚开始的时候，美股就遭遇了史无前例的三连熔断。为“救市”，特朗普任命的美联储主席鲍威尔为了救主，破坏美联储的独立地位，史无前例地用美联储资产为股市无限托底。美联储为了托底股市投入的基础货币据说仅70天就已高达3万亿美元。 特朗普此举，只不过为了11月的大选多一点胜算。然而，负面后果极大，典型的“我走后，哪怕洪水滔天”心态。因为，从目前情况预测，美国的疫情将长期化，世界的疫情将长期化，大萧条将持续至少3年，甚至更长。在第一回合就打光子弹的美国，未来将捉襟见肘。 在这样的局面下，无论谁当美国总统，都很难拥有遏制中国崛起的足够资源和决心。特别是很难下决心。 威廉二世、希特勒、斯大林、赫鲁晓夫、裕仁天皇….这些入土的挑战者们如果知道中国的运气，恐怕也只能一声叹息吧。或许，这就是所谓“天选之国”，上天的安排最大。 四、国运的偶然与必然 在大国崛起的道路上，不少国家都有过国运爆棚的巅峰时刻，如法国有过拿破仑时代、俄国有原苏联时代、日本有昭和时代。然而，这些国家“其兴也勃焉，其亡也忽焉”。国运像诱饵一样，不仅没有成为这些国家崛起的机遇，反而成为其一败涂地的诱因。400年来，只有大英帝国和美利坚合众国两个笑到最后的全球王者，这两个国家又都是盎格鲁撒克逊精英治理的国家，难道是偶然吗？ 我觉得不是偶然，其必然性在于一个国家文化基因中的“定力”。每个人一生都会遇到好运气，也会遇到坏运气，国家也是一样。长期打牌的高手最重要的是拿到烂牌能止损，拿到好牌能淡定地将其价值最大化，而不是靠运气。这种品质，就是定力。一日的定力不难，一个国家能够两百年如一日保持定力，才是真正的国运。 大英帝国崛起的200年中，历任首相基本保持了定力，确保了国策的稳定。在最辉煌的时候，也坚持“离岸平衡”策略，克制在欧洲大陆攫取领土的欲望（历史上英国在欧洲大陆是有国土的），除非力量平衡发生巨大变化，否则决不亲自下场。就算亲自出手，也可以放下世界霸主的面子向曾经的对手寻求妥协，总是能够以多打少、以强凌弱。极盛时期的拿破仑、巅峰期的沙俄、两次世界大战如日中天的德国，均被大英帝国构建的地缘绞索勒死。 面对攫取殖民地的诱惑，大英帝国也保持了匪夷所思的定力。与当地精英合作，给予其利益和特权，间接统治日不落帝国广阔的殖民地，克制亲自统治的“爽”感，把力量集中用于控制航道和交通枢纽。 一旦受挫，大英帝国不会像赌徒一样不肯放弃沉没成本，而是马上及时止损。比如在18世纪放弃美洲，赢得了美国的友谊。在20世纪放弃印度、澳大利亚、加拿大等殖民地，保住了在英联邦的影响力。 美国人继承了英国人的定力（早期美国人就是英国人）。在刚建国的时候克制占领整个北美的冲动，立法规定在新拓殖民地中，移民中新教白人比例达到多数，才能正式建立新州，花了一百多年才从东海岸拓殖到西海岸，由此保持了盎格鲁撒克逊新教伦理对新移民的同化。在19世纪强大之后，克制了对美洲小国的直接占领，满足于间接控制。二战后则允许其殖民地菲律宾、占领国日本独立，保持了对菲律宾、日本的巨大影响力。 在止损方面，美利坚同样继承了英国人的定力。失去越南、伊朗、中国后，没有纠结于沉没成本死缠烂打。苏联则死活不肯放弃阿富汗以及貌合神离的加盟共和国，日本死活不肯放开咬下中国的一大口肥肉，最终都被拖死。 英美的定力，使其获得了国际信誉。之所以昔日的敌人可以一夜间成为盟友，是因为这些国家信任英美不会翻脸不认人。战败者也不会鱼死网破，因为相信英美虽然会割韭菜，但不会斩草除根。所以，英美总是有种“得道多助”般的神秘国运。这是有力量，但自我克制带来的运势。 反观法国、德国、日本、苏联，则缺乏对力量使用的克制。 拿破仑被胜利冲昏了头脑，幻想可以征服整个欧洲，结果雄狮陷入狼群。德国的致命软肋就是双线作战腹背受敌，然而威廉和希特勒都图一时爽，不愿向任何一线妥协，结果同一条阴沟里翻船两次。日本更不用说了，一次次冒险成功，让昭和大神们狂妄到想要蛇吞象中国，并且居然以卵击石去进攻比自己强大百倍的美国。原苏联被二战胜利冲昏了头，说好的“友好互助”、“共产国际”，结果变成了对共产主义小兄弟们的殖民统治，小兄弟们不仅没有成为助力，反而让苏联不得不投入海量资源压制反抗，连中国这样的坚定盟友都被推到美国一边，不败才怪。 拥有力量，但缺乏克制，结果是引起周边国家，甚至盟友的广泛的恐惧，“失道寡助”，最终被群殴致死。像德国和日本、苏联的尿性，就算跟邻国妥协，也不过是阴谋而已，傻子才信。这是缺乏定力导致缺乏国际信誉的结果。看似是运气，实际有必然。 莎士比亚在《李尔王》中所说：不要给穷人一匹马，他会把马跑到累死。小老板最危险的不是赚不到钱，而是侥幸给他赚了第一桶金。要么忘乎所以可劲造到家破人亡，要么自认为可比肩马云马化腾，盲目上项目，最终不仅把赚的赔光，还欠了一辈子都还不完的债。德、日、苏等国的衰落过程，不就和小老板一样吗？ 国家的定力和人的定力何其相似啊！脱贫之所以难，难在品质而不是运气。国家的定力，也必然与其国民品质相关。英美的定力，与盎格鲁撒克逊新教伦理分不开。那么，中华民族会具备盎格鲁撒克逊人的定力吗？ 我相信是有的，因为华人的品质之优良，相比新教伦理有过之而无不及。比如勤俭、家庭责任、重视教育等。海外华人在东南亚不定期被屠杀，在美国被排华直到1950年代。然而，几代人后，华人成为东南亚最富裕的族群，在美国也成为平均收入、教育程度均超越白人的成功族群。以至于《美国种族简史》感叹：华人在任何地方都能发财致富，除了自己的母国！（说的是近代以来，新中国成立后，特别改革开放后，中国人在国内更成功） 没有对比就没有发现。去了海外，我们才注意到中华民族身上独特的优良品质：海外华人的品质就是定力，不管别人怎么侮辱、打压、歧视，华人总是那么勤奋、向上。赚了钱后，华人不会像一些民族那样及时行乐，而是省吃俭用攒起来，买房子、给孩子最好的教育、寄回国内孝敬父母、捐给祖国帮助建设。 5000年里，中国人正是靠这种定力，一次次在废墟中重建被烧毁的家园，一次次在泪水中播种被抢掠的农田，一次次在尸山血海中重建强大的国家。这种定力是偶然吗？当然不是。5000年里，华夏经历无数次饥荒战乱，动辄消灭50%—90%的人口。定力不足的基因没有机会延续，定力不够的文明没有机会传承。无数代大浪淘沙的结果，造就了地球上生命力最顽强的人民。 5000年的文明沉淀、百年来的命运多舛，中国政府的定力亦如中国人民一般历久弥坚。美国政治学家布热津斯基在《战略远见》中评价道：慎重且耐心是中国帝国DNA的一部分。但是中国也雄心勃勃、骄傲自豪，清醒地意识到其独特历史只是其命运的序幕。因此，中国领导人一直比较谨慎，在对外公开宣称寻求世界领导地位方面保持克制。总的来说，他们仍然遵循邓小平的著名格言：“冷静观察，稳住阵脚，沉着应对，善于守拙，决不当头，韬光养晦，有所作为。”这种谨慎的姿态还恰恰与中国古代孙武的战略指导不谋而合。孙武令人信服地主张：“昔之善战者，先为不可胜，以待敌之可胜。”中国对于美国国内问题和对外政策所持的官方态度，显然令人想起这一战略指导。北京的历史信心，与其精于算计的审慎和长远野心密切相关。 反观美国，文明底蕴终归是不足，其定力还是比拥有千年历史的大英帝国差点火候。特别是冷战胜利后，霸权失去约束后的骄横难以遮掩。加上几十年来“个人主义”被当做美国精神宣扬过度，近几届美国总统气质上和华盛顿、林肯、罗斯福的差距越来越大，和脱口秀演员的差距越来越小；国家使命担当越来越淡，个人价值实现越来越浓。 老布什还知道打着联合国旗号“用众之力”，并且给萨达姆留条生路以制衡伊朗，之后的历任总统越来越“飘”。克林顿总统居然在白宫椭圆办公室和女实习生偷情，小布什甩开联合国穷兵黩武连灭两国挑战帝国坟场，奥巴马总统把白宫当成说段子、拍写真、交名流的个人秀场。特朗普总统则狂到连跟欧、日盟国领袖表面的礼貌都懒得装，妄到连科学都敢蔑视。新冠疫情在美国的肆虐恐怕人祸多过天灾，正印证了一句老话：上帝欲使其灭亡，必先使其疯狂。 虽然如此，但当下来讲，中国崛起路上的危险仍然巨大。 一是老龄化的大山压顶。 老龄化的国际标准是老人占到10%。1980年中国60岁以上的老人不过7%，2020年已达到18%，2050年将达34%。而日本的老龄率27%，美国15%，印度6%，中东和非洲只有4%。中国的生育率只有1.08—1.6%（各方数据不一），已不能维持2.1的基本人口替代率，而印度有2.2，中东和非洲则保持5.0—6.5的超高生育率。这意味着中国实现富强、突破封锁、获得良好外部环境后，必须控制与美国争霸世界的诱惑，立即痛下决心转型，把鼓励生育当成最最重要的百年大计。否则，以百年后不过6亿左右的人口，300年的奋斗最终不过是为他人做嫁衣裳。 中国必须尽可能和平发展，绝不能轻启战端：我们的每个年轻人都太宝贵了！每个育龄青年都是华夏文明未来的火种，一个都不能少！这意味着中国崛起后的战略选择也只能效仿英美搞“离岸平衡”，至少熬过三代人，把人口生育率补到正常水平，才敢提更远大的志向。 须知，在美国崛起过程中，人口生育率是最基础的因素：根据亨廷顿《谁是美国人：美国国家特性面临的挑战》数据，17—19世纪，初期盎格鲁撒克逊移民后代持续保持了7.0左右的高生育率，在1790年的峰值甚至达到7.7的恐怖水平。到1990年，初期盎格鲁撒克逊殖民者后代达到1.22亿人，占当时美国总人口（2.49亿）的一半。正是庞大的同文同种人口基数，才使得美国能够有节制地陆续接纳、同化一亿多移民，并维持其国家特性长达244年。而上世纪90年代美国移民政策失控后，短短30年内，墨西哥非法移民潮水般涌入了至少2000万，其恶劣后果在今天已暴露无遗，并将持续而不可阻挡地侵蚀美国的根基。 二是警惕走上德日苏头脑发热出昏招的不归路。 经济方面。虽然中国的GDP已经与美国接近，但其中近10年翻两番的房地产占了多大比重？真跟美国正面硬杠的话，到底是肌肉多还是赘肉多？恐怕很多人心里都要打个问号。美国制裁中国的华为，但不制裁过去十年拉动GDP更给力、造富神话更多的房地产业及占了A股一半市值的银行业，原因不言自明。 长赘肉的过程很愉悦，充满诱惑；练肌肉的过程则很痛苦，需要勇气和毅力，这是对中国定力的考验。 另外，大国竞争的关键并非GDP的绝对值，而是剩余值，也就是可以挤出多少用于战争。在19世纪，俄国的GDP一直与英国接近，却在克里米亚惨败，英国一只手就可以死死按住俄罗斯，还有余力全球争霸。原因在于俄国人口多，庞大的GDP大多数需要拿来养活国民，英国的则有大量剩余财富。中国的情况相近，我们的GDP是把13亿人口的吃喝拉撒都算进来了，真正打起来，能用的财富是远不如美国的。衡量大国实力，必须考虑人均GDP。而人均GDP，美国是中国的6倍，差距比较大。 特别在贸易战+全球疫情的史无前例国际环境下，中国出口、投资、消费三架马车，瘸了一架出口。消费本来就营养不良，疫情防控常态化更是雪上加霜。投资拉动的耐药性则越来越明显，而且信贷扩张过猛带来的通货膨胀又会导致工薪阶层消费降级，以及贫富差距进一步拉大。能否克制灌猛药的冲动，这是对中国定力的考验。 综合国力方面，如果算金融、军事、科技、教育、文化、外交等综合实力的话，中国跟美国仍然不是一个量级，目前也只是做到有效威慑自保而已。祖国统一没有完成，第一岛链没有突破，系统性金融风险的不定时炸弹没有彻底排除。美国可以连续出一百个昏招，但依然瘦死的骆驼比马大。而目前的实力对比下，中国只要做出一个令鹰酱喜大普奔的昏招，复兴之路就可能被打断50年。 5000年风雨沉浮、70年艰苦奋斗、40年卧薪尝胆的定力，给了国人坚定的信心。路虽漫长而艰难，然终将踏平坎坷成大道。 伟人诗云： 风雷动，旌旗奋，是人寰。 三十八年过去，弹指一挥间。 可上九天揽月，可下五洋捉鳖，谈笑凯歌还。 世上无难事，只要肯登攀。 （完结）———————————————————————— （以下供感兴趣的朋友深入探讨。） 国运与文明基因 英国政治学家马丁·雅克不断提醒西方：“中国是个伪装成国家的文明”，美国的亨廷顿也持同样看法。 中国，与法国、美国、英国根本不是一个概念。《史记·楚世家》记载：“熊渠曰：我蛮夷也，不与中国之号谥”。“中国”和“天下”意思相近，是古代所知世界文明世界的意思。中国，实质上就是华夏文明。 深受中国文化熏陶日本首相伊藤博文，在签订《马关条约》时不允许大清使用“中国”作为国名，只准用“大清帝国”，因为他知道这么一写，就坐实日本的蛮夷身份了。中国，是文明的同义词，老外也是刚刚才有人明白过来。 华夏文明的正朔源于青海的黄帝部落（姬姓）。黄帝向东击败炎帝部落后，反而与炎帝结盟，成为有文字记录华夏共祖“炎黄”。炎黄联盟（位于甘陕）击败由蚩尤统帅的“东夷”部落联盟（位于今河北山东），海纳百川与东夷结盟，交给东夷成员之少昊部落领袖“少昊”治理。少昊部落的图腾“凤鸟”，与炎黄的龙图腾联姻，“龙凤呈祥”成为中国人婚姻幸福以及百年好合的象征。“凤鸟出”也成为天下归一的象征，孔子曰：凤鸟不至，河不出图，吾已矣夫。 黄帝的直系后裔为西周姬姓，武王伐纣灭商后，不计前嫌把商遗民分封到宋国这样的好地方（耕地肥沃还方便做生意，成为“商人”之祖）。西周一统华夏，但并不排斥与吴、越、楚这样不服王化的蛮夷之国交往。千年后，吴越楚地在屡次蛮族入侵中成为保存华夏文明火种的避风港。 少昊的治所曲阜后来诞生了大儒孔子，他把西周的定力总结为“仁”。“仁”即“人”+“二”，意为众人。“仁”即“忠”、“恕”。“忠”即“中”+“心”，意为感知本心、行为合乎本心、“致良知”；“恕”即“如”+“心”，如感知自己心一样去感知他人之心。“仁”，是华夏文明的定力之魂，代表了华夏文明总结的“王道”，王者有力量，但克制自己，仁爱他人，以德服人。 “仁政”“王道”的对内表现为“轻徭薄赋”。中国历代极权君主明明有能力征收“最大化地租”，但却非同寻常地极为克制，完全不同于西方统治者“最大化地租”的原则，令西方政治学家十分困惑。 中国两汉正常税率不到8%，唐宋不到7%，大明不到4%，清代7%。王朝中后期横征暴敛，则埋下灭亡伏笔。此举与西方经典经济学的减税理论暗合：任何税收都会减少资产积累，从而减少投资循环；减税则降低经济成本，增加积累，提升投资，带来正循环。 税收并不是越低越好，关键在于税收用于什么地方。是给统治者挥霍，还是为民众提供优质的公共服务。古代中国政府的税收维持了近代以前全世界最高效的行政体系，建设了全世界最复杂的水利灌溉设施、制服了黄河这样的世界第五大河，建设了令人惊叹的运河交通网、堪称奇迹的国防设施（长城），并投资了从蒙学到太学的完整教育体系。 所以，中国的经济两千年来冠绝全球并非偶然。选用百度搜索数据中比较保守的口径：宋代GDP占世界23%，明代占29%，清代占33%。这并不是国土肥沃的结果（三分之二国土都是山地），而是“仁政”的结果。 西方政权的经典理论是“坐寇”论，即政权源于强盗，强盗发现抢劫不如收税赚的多，所以从强盗变成占领土地收税的领主和国王，谓之“坐寇”。“坐寇”奉行经济学的“理性人”原则，能收100的税绝不收99，所以实行“地租最大化”原则，如同经济学的垄断定价一样。结果正如经典经济学推演：民间没有经济积累，消费低，投资低，故几千年都是国民穷、人口少（粮食积累决定人口数量）。其实它的土地是比中国肥沃的，降雨充足，且西欧、东欧都不缺适合农业的大平原。若非大航海狠狠发了笔横财，催生了资本主义，欧洲人难有咸鱼翻身之日。 中国政权的理论基础是“民本主义”。《尚书》中说：“天视自我民视”、“天听自我民听”。意思是统治合法性源于天命，而天是通过民众来看、来听的，天心就是民心，是谓“民本主义”。中国政权的合法性，源于“天命”。每次天下大乱、群雄逐鹿时，不仁的军阀，儒家知识精英不仅拒绝辅佐之，反而如曾国藩一样拉“团练”反抗之，将其葬身于人民战争的汪洋大海。“仁德”的王者，则登高一呼，应者云集。西方皇帝需要教皇加冕，中国的教皇是民众，众望所归即为加冕。 西方的对外政策，是其对内“霸道”政治的延伸。美苏英称霸后，无不是通过武力迫使小国屈服，然后当“坐寇”、割韭菜。一如他们的欧洲祖先：领主跟着国王打仗侵占他国土地，然后世世代代靠收租当贵族。只不过，现在农业用地不值钱了，他们到处抢的是石油、码头、矿山、铁路、优秀公司的股权。 而中华历来的对外政策，则是“王道”政治的延伸。“普天之下，莫非王土；率土之滨，莫非王臣”。真实的意思是：中华虽强，但对其他国家，以及他国国民一视同仁，都是“王臣”，不搞双重标准。所谓平等，不是自由竞争，而是扶助弱小。由此产生中华特色的“朝贡”制度。 中华是巨无霸，若进行自由贸易，周边小国拿什么跟天朝贸易？除了稀奇古怪的大象、狮子、孔雀拿来朝贡外，论工业品你能跟天朝比质量、比价格，还是比物流？论农业品，你跟天朝比粮食多？所以，乾隆对马嘎尔尼说：天朝物产丰富，无所不有，原不籍外夷货物以通有无。这话虽然不适用于英国，但适用于工业革命以前中国所知的其他国家。经济学来说，是中国庞大人口带来的规模效应！所以中国并没有采用貌似公平实则持强凌弱的“自由贸易”，而是采用了很吃亏、显失公平的“朝贡”贸易。尽显王者风范、大国气度。 现代中国已经是世界上工业门类最齐全的国家，不仅全，并且质量好、价格低。还被美国逼得必须拥有更全的工业体系，假以时日，在面对亚非拉小国时，将与历史上无异。只不过，历史上中国能够解决需要的所有资源，当代中国则需要进口资源而已。但资源和工业品的剪刀差，会让中国积累大量赢余。中国则在满足国内建设和人民消费之余，拿出一部分去亚非拉修桥补路，建设“人类命运共同体”。在秉承“王道”方面，中国亦如过去。 反观西方，自己工业不行的时候就搞贸易保护、抢殖民地（垄断市场），工业发达了就用武力推广“自由贸易”。美国多年来跟发展中国家自由贸易的结果，就是把国际贸易变成了“国内贸易”。为什么？因为你的工业品质量和价格都不如他，你没什么东西卖给他，他很多东西卖给你。慢慢你就没钱了。没钱物价就低，于是，你的油井、矿山、最赚钱的公司都被他廉价收购了。结果是发展中国家的财富汇聚到华尔街、伦敦，资本家们从国内剥削延伸到国际剥削。西方越来越富裕，而落入陷阱的发展中国家则注定贫困，在一小撮心系美国的买办统治下，永无翻身之日。 现在，美国自由贸易搞不过中国了，自己掀桌子搞贸易战，还以国家之力制裁华为一个企业，并且野蛮地规定只要使用美国技术的产品，都不能卖给华为。说到底，不过是西方“霸道”政治的一以贯之。 西方的用血统来区别身份，到现代则发展为种族主义。华夏以文化来区分，“汉入胡则胡，胡入汉则汉”，不论血统，只看文化，发展出独特的“天下”思想。并非汉人融合少数民族，而是历史上数不清的家族、部族，融合于华夏文化形成了汉族。 西方缺乏文化自信，总是用暴力推广和维护其思想。古代搞十字军圣战，现代则武力推广“普世价值”。中国文化则具备自信，兼容包并却能够保持自身特色，在南北朝融合了印度佛家思想精华形成儒释道合流的中国独特传统文化，在近现代则将西方的社会主义、市场经济、民族主义融会贯通。《论语》曰：“君子和而不同，小人同而不和“。 中国坚持“仁政”、“王道”的回报，是华夏王朝能够用羁繫政策低成本维持对蛮荒边疆的同化，能够用文化、道德的力量将高丽、交趾、日本等国纳入华夏文明圈，并塑造其具备与华夏民族相近的文化和品质。千年后，边疆开化为工业重镇。而周边心向中华的朝鲜、越南在近代则为中国缓冲了新一轮的蛮族入侵。 即使侵略中国的日本，也为中国保留了无数毁于战火的典籍（如《墨子》），还在改革开放后带来中国急需的资金和技术。文化更是水乳交融，日语源于汉语，但近代汉语则从日语借词无数，如：干部、科长、法律、必要、景气、乘客、发明、科学、客体、经济、资本主义等等。由西方而来的事物、概念，往往是先被日本翻译为日语，中国近代知识分子再从日语借词为汉语。离开了日语借词，现代中国人都没法写文章了。 眼光放在10年的话，日韩越是对手；放在百年，日韩越是盟友；放在千年文明史的话，日韩越是江河，华夏文明则是大海，江河奔流的源泉在于大海蒸腾形成的降雨，江河最终又将奔涌入海。海纳百川，有容乃大。 二战后，制造经济奇迹的国家，集中在华夏文明圈内的“东亚怪物房”，如中、日、韩、新，均曾经多年保持两位数的经济增长。中日韩移民普遍在美国获得平均收入水平、教育水平超越白人的成功。本次疫情中，地球上应对最优秀的国家和地区，几乎和“东亚怪物房”完全吻合。这么多巧合，就不是巧合，而是必然了。 “王道”、“仁政”在华夏埋下的种子，一千年播种、一千年发芽、一千年生长、一千年开花、一千年结果。今天的中国人一生下来就沐浴着五千年文明之光。文明传承，是我们民族的定力之源。中华民族并非崛起，而是“复兴”，走出一百多年落后的小插曲，回到千年辉煌的华夏文明正轨上。 鸦片战争以来，中华民族110年浴血奋战，70年卧薪尝胆。幸而苦心人天不负，而今终见民族复兴的曙光。有道是：潜龙在渊百八载，见龙在田七十载，亢龙有悔再十载，飞龙在天承千载。 (2020-10-04) 如何看待 2020 年 10 月 13 日凌晨一名大连理工大学研究生在实验室自杀身亡？@零点九循环 太抑郁了。最抑郁的不是导师压榨学生。最抑郁的是导师没什么大的问题，学生也没有大的问题，最后却是这么绝望的结果。导师没有大的问题。没有pua，没有言语打压，最多是喜欢聊聊行业前景。没有逼迫996007，通宵是为了赶进度，赶进度一部分原因是疫情影响，并不是一直这么忙。没有不让毕业，一直在为他争取只发相对简单的专利。之前疫情那么严重，半年时间封校无法做实验，也没有让学生延毕。做的不对的地方，是修仪器浪费了一点时间。是沟通不畅导致一部分工作白做。（而且沟通不畅是导师和学生共同的问题，白做了一些实验在科研中也并不罕见）甚至他自己都没有怨恨导师甚至按照组里的传统，之前比他做的更不好的人都毕业了，他也大概率能顺利毕业学生没有大的问题。没有懒惰，一直在努力地做实验。没有缺少规划，备考公务员也准备了很久。友善待人，对老师不带有怨恨，只是客观描述了学习和科研的痛苦。乐观积极，最后的遗书诙谐幽默，让人感受到他对生活的热爱。所以才绝望啊！为什么自己是一个好人！遇到的都是好人！最后却是这样！再说说疫情导致的就业难就拿我所在的材料专业来说。专业二三十人，去年华为给了五个口头offer，今年只给了一个。其他公司，无论是给offer的数量还是工资，都比去年差很多很多。当然，也可能是我们这届学生比较菜我现在也一样抑郁。导师是非常好的人，所有人都一致称赞，给了我很多支持，我永远感激他。室友是很好的人，拉着我跑招聘会，帮我投简历，教我怎么面试，给我筛选好的公司。导员很好，没有任何可以挑剔的地方。家长非常支持，为我做了很多事情。遇到的hr很好，即使没有录用我，也非常诚恳地指出我面试中回答的错误。……可我就是做不出实验！可我就是找不到工作！我过的这么惨，连一个可以怪罪的人都没有！只能去怪我自己！也许可以把责任推到其他东西身上，比如疫情，比如专业，比如运气。可是同专业的人过的好像都不错。也许可以什么都不想，只是无知无觉地继续走下去。可是做不到，都读到研究生了，家人的期待，朋友的压力，还有自己之前付出的努力……这些都放不下所以只能期待来生做一只猫，今生还是没有退路。不过我现在已经想开了。比起来生做一只猫，不如现在开始做一只猫。不要自杀投胎轮回转世，不要让中间商赚差价。实验不会做可以延毕，找不到月薪一万的工作，可以去找四千的，考不过国考省考选调生，还有小县城可以考虑。不就是当一只无知无觉的猫嘛！猫听不懂别人说什么，也不会为自己的处境而绝望 (2020-10-13) 湖北省高院副院长张忠斌办公室内自杀身亡，三天前曾主持会议，还有哪些信息值得关注？@托卡马克之冠 虽然我这么说有点站在干岸上不腰疼的感觉，但我还是想说，遇到事了一定要学会自我排遣，自我消解，自我干预。 这位副院长长期靠吃药撑着，我知道就医吃药是最科学的办法，但不一定是最有效的办法。 如果是正常工作中遇到的压力，要有摸鱼精神，想办法偷懒，工作内容软执行，打太极，拍皮球，干啥都行，就是千万别想不开，当个不求上进的混子总比寻短见强。 如果是遇到内部黑恶势力了，不论是当个混不吝的无赖，还是当个打不垮的斗士，哪怕当个明哲保身的油条都好，一定要活着，活着才能战斗，活着才能斗争，要有大不了在家睡觉，你有本事就算我旷工的精神。 实在压力大的受不了，去菜市场逛，逛那种嘈杂的超大型菜市场，人越多越好，越乱越好，去菜市场的熟食摊子吃东西，买那种油大的，不要切，整个的抱着啃。 逛超市，去粮油食品区，那种卖散装大米的地方，把手插进大米里，感受米颗粒在手指间滑动，流转，去半成品区，看见顺眼的就往推车上放，买一堆香氛，挨个闻。 去那种生意兴隆的大众餐馆，点几个菜，让老板允许你去厨房里待一会，哪怕给点钱都行，就去繁忙吵闹的厨房里呆着，感受那种嘈杂混乱的氛围，有刚炒好的菜直接花钱买下，端着吃。 买烟花爆竹，去郊外，炸，把那种几千响的炮仗埋沙土堆里，点着了，不要捂耳朵。 有夜市烧烤摊子最好，再不济酗酒都行。 自我干预的时候不要在乎现在是不是上班时间还是有什么急事开什么会，天大的事情都没有命重要，你现在首先得自救，自保，抛下一切往有烟火气的地方跑 干啥都行就是不要寻短见，活着才有输出。","link":"/2020/02/13/Highly%20agreed%20answers/"},{"title":"VirtualBox中各版本Kali Linux的安装","text":"Hi~ VirtualBox 6.1.28 r147628 (Qt5.6.2) 映像名：kali-linux-2019.4-amd64.iso 下载：http://old.kali.org/kali-images/ 安装教程1. 打开virtualbox，点击新建 2. 名称随意，文件夹路径选个大点的盘，类型版本如图（名称和路径尽量全英文） 3. 加载 kali 的 iso 镜像文件 4. 设置 改为双向方便使用（个人习惯，非必改） 储存—添加虚拟硬盘 创建 看个人情况，建议20~40GB 选择刚刚创建的这个 正常显示如下 5. 启动 选择Graphical install，回车 填入主机名，最好英文 空 继续 设置root账户密码 留空 如图选择 选择Kali GNU/Linux 用户名为root 6. 网络配置进入全局设定---选择网络---添加NAT网络 设置NAT（名称和CIDR可根据需要自行设定） （提供内网访问）配置Host-Only设置（建议设置顺序为 网卡设定 --- DHCP服务器设定） 虚拟主机提供3种网络（NAT模式，Host-Only模式，桥接模式） NAT模式 桥接模式 仅主机 （为了方便管理，建议虚拟主机同时添加NAT网络，和Host-Only网络，既可以访问内网也可以访问外网） 7. 中文乱码（没有中文字体）Kali Linux 2019.4开始默认使用的是Xfce桌面环境，替代了之前版本所使用的GNOME3桌面环境。 安装系统时，选择了中文语言时，进入系统后，中文会显示乱码 打开命令行 更改默认编码 输入:dpkg-reconfigure locales 进入图形化界面 空格是选择，Tab是切换，*是选中，回车是执行 找到zh_CN.UTF-8 UTF-8并设置为默认 空格选中后回车 Tab键选中左下所框（内容为确定），回车 # 编辑sources.list文件，并添加以下源，选择自己相对快一点的源。 vim /etc/apt/sources.list # 不会vim的可以使用图形界面编辑器 mousepad /etc/apt/sources.list 123456789101112131415161718# 阿里源deb https://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src https://mirrors.aliyun.com/kali kali-rolling main non-free contrib# 清华大学deb https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free# 中科大（亲测唯一可行）deb http://mirrors.ustc.edu.cn/kali kali main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali main non-free contrib 12345678910111213Ctrl+s 保存后关闭该窗口apt-get update # 取回更新的软件包列表信息apt-get upgrade # 进行一次升级apt-get dist-upgrade #这一步是更新软件，如果你对新版本软件的需求不是那么迫切，可以不执行apt-get clean # 删除已经下载的安装包sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-intl-chinese #安装中文字体，开源的文泉驿微米黑和文泉驿正黑字体reboot #重启 2021版Kali安装后无图形化界面映像名：kali-linux-2021.3-installer-netinst-amd64.iso 下载：https://mirrors.aliyun.com/kali-images/ 对于Kali系统的2020.1版本，开发团队宣称：”我们不再为每个桌面环境(DE)提供单独的映像。相反，我们现在只有一个单独的映像，可以在联网安装期间选择桌面环境和要安装的工具。这意味着没有Xfce、GNOME、KDE、MATE或LXDE桌面的单独镜像下载链接。”因此不联网安装，只有纯文本命令行界面。 正常安装后登录 登录普通用户后，启用root用户 123456789101112131415161718192021sudo passwd root我们信任您已经从系统管理员那里了解了日常注意事项。总结起来无外乎这三点：#1) 尊重别人的隐私。#2) 输入前要先考虑(后果和风险)。#3) 权力越大，责任越大。[sudo] lingyun 的密码：新的 密码：重新输入新的 密码：passwd：已成功更新密码 需要输入三次密码，分别是当前用户密码，root密码和root密码确认。输入密码时，密码是不可见的。 切换到root用户 su - root 更改apt源为国内源（同上述源），保存并退出 vi /etc/apt/sources.list 更新系统 sudo apt update &amp;&amp; apt upgrade &amp;&amp; apt dist-upgrade sudo apt-get clean 安装xorg（xfce4环境必备） sudo apt-get install xorg 安装Xfce4桌面环境 sudo apt-get install kali-defaults kali-root-login desktop-base xfce4 xfce4-places-plugin xfce4-goodies 解决中文乱码问题 sudo apt install ttf-wqy-zenhei 重启计算机，之后便可正常使用图形界面 reboot 个性化设置（主题风格、屏幕分辩率） 要先将VirtualBox的窗口拉大再向高分辨率调整，否则会概率失败 推荐联网安装2020.4映像名：kali-linux-2020.4-installer-amd64 下载：https://mirrors.aliyun.com/kali-images/kali-2020.4/ 联网状态下选择默认配置安装 无上述中文乱码及无图形化界面问题，且集成安装多数常用软件 参考：https://www.pianshen.com/article/49721031770/ https://blog.csdn.net/milkway2013/article/details/103371811 https://blog.csdn.net/weixin_45907620/article/details/106835152 https://blog.csdn.net/qq_42514956/article/details/104561883 https://blog.csdn.net/u011672712/article/details/103393297 https://www.cnblogs.com/rise-home/p/12529651.html https://developer.aliyun.com/mirror/kali https://blog.51cto.com/1inux/2048278","link":"/2021/10/28/Kali/"},{"title":"Probabilism_summary","text":"题型总结 Term Review","link":"/2020/12/27/Probabilism_summary/"},{"title":"Probabilism_notes","text":"概率论笔记 Term Review 随机事件与概率 概率论基本概念 随机试验 样本空间（集合）、样本点 随机事件：样本空间的子集 事件间的关系 包含：A发发生一定导致B发生，则B包含A 相等：A=B,A包含B，B包含A 互斥：AB不可能同时发生，A∩B=∅ 对立一定互斥，互斥不一定对立 事件的运算 并：A、B至少发生一个 交：A、B同时发生 差：A-B，A发生B不发生 对立事件：A不发生 德摩根律，A-B=A-AB=AB’差变交 概率 公理化定义 非负性 规范性 可列可加性（互不相容时） 性质 P(A-B) = P(A) - P(AB) 若A⊂B,则P(A)≤P(B) P(A⋃B)=P(A)+P(B)-P(AB) 𝑷(𝑨⋃𝑩⋃𝑪)=𝑷(𝑨)+𝑷(𝑩)+𝑷(𝑪)−𝑷(𝑨𝑩)−𝑷(𝑨𝑪)−𝑷(𝑩𝑪)+𝑷(𝑨𝑩𝑪)， 推广 Boole不等式: (Union Bound) (非互不相容的事件集) 两种方法证明 古典概型 特点：样本空间的元素只有有限个; 每个样本点发生的可能性相同 定义：P(A)=A包含样本点数/Ω包含样本点数=(|A|)/(|Ω|) 典型例题 男n女m，围成一圈，女生互不相邻的概率？ 抽签原理 随机取数（乘积能被10整除）：分解成两个事件的交——至少一个偶数，至少一个5 取铆钉：利用互斥性 几何概型 特点：样本空间无限性；等可能性 定义：𝑷(𝑨)=𝑨的几何测度/𝛀的几何测度=(𝝁(𝑨))/(𝝁(𝛀)) 典型例题 约会问题：0&lt;=x, y&lt;=60, |x-y| &lt;= 15, 面积 蒲丰投针 条件概率 定义：𝑷(𝑨│𝑩)=𝑷(𝑨𝑩)/𝑷(𝑩) 本质：缩减的样本空间 乘法公式： 𝑷(𝑨𝑩)=𝑷(𝑨)𝑷(𝑩|𝑨)， 𝑷(𝑨𝑩)=𝑷(𝑩)𝑷(𝑨|𝑩)， 推广到多个事件：若𝑷(𝑨𝟏 𝑨𝟐⋯𝑨(𝒏−𝟏) )&gt;𝟎，则𝑷(𝑨𝟏 𝑨𝟐⋯𝑨𝒏 )=𝑷(𝑨𝟏 )𝑷(𝑨𝟐│𝑨𝟏 )⋯𝑷(𝑨𝒏 |𝑨𝟏 𝑨𝟐⋯𝑨(𝒏−𝟏)） 全概率公式（求结果发生的概率（即求𝑷(𝑩))） 应用：推迟决定原则 贝叶斯公式：（已知事件𝑩发生，求𝑩由第𝒊个原因引起的概率（即求𝑷(𝑨𝒊 |𝑩)）） 应用：患肝癌概率，三囚犯问题，三门问题 独立性： P(AB) = P(A)P(B) 性质：P(B|A) = P(B), 概率为0或1的事件与任意事件独立，A,A’与B,B’都相互独立 独立与互不相容的关系：（P(A)、P(B)均大于0）若A、B相互独立，则不可能互不相容; 若A、B互不相容，则不可能相互独立（P(A)P(B) &gt; 0） n个事件的独立性：n个事件独立 =&gt;其中任意k个事件独立，反之不成立 分组独立性： 独立事件至少发生一次的概率： 应用：系统可靠性，矩阵乘法验证 离散型随机变量 随机变量 定义：把𝛀中的每一个样本点𝝎与一个实数𝑿(𝝎)相对应，称实值函数𝑿:𝛀→𝑹为随机变量，随机变量在某范围的取值表示随机事件 Y = g(X)的分布：合并相同项 二维离散型随机变量(X, Y) 联合分布律：𝒑𝒊𝒋=𝑷(𝑿=𝒙𝒊,𝒀=𝒚𝒋 )（列表） 边缘分布律：P{X = xi} = Pi·, P(Y = yj) = P·j 两个离散型随机变量的独立性：对所有x, y, 𝑷(𝑿=𝒙,𝒀=𝒚)=𝑷(𝑿=𝒙)𝑷(𝒀=𝒚), 则X, Y独立 推广：多个离散型随机变量的独立性：对任意取值的x1, …, xn, P(X1=x1, …, Xn = xn) = P(X1 = x1)…P(Xn = xn) (只要一个公式) 期望 定义 有4个盒子，编号为1,2,3,4。现将3个球随机放入4只盒子。用𝑿表示有球盒子的最小号码，求𝑬(𝑿). 随机变量函数的期望： 期望的线性性质：（**如何证明***）（不依赖于独立性） 例：猴子打字 一般E(f(x)) != f(E(x)), 如E[x^2] &gt;= E[x] ^2 Jensen不等式：设f为下凸函数，则E[f(x)] &gt;= f(E[x]) 几个典型的离散型随机变量 0-1分布（伯努利试验）：随机试验只有两个结果：A与A’，A发生则X=1，否则X=0，X为指示变量 期望：E[X] = p 方差：D(X) = p(1-p) 二项分布（n重伯努利试验, 每次实验结果相互独立， X为n次试验中A发生的次数）： 定义：记为X~B(n, p) 期望：E(x) = np（证明：公式* / 期望的线性性质） 二项式定理： 方差：D(X) = np(1-p) (由0-1分布方差相加而来) 二项分布的最大值（**解法***）：(n+1)p-1&lt;=k0&lt;=(n+1)p (np附近) 泊松近似公式：(n&gt;=20, p &lt;= 0.1)时，P(X = k)近似于 泊松分布（大量实验中稀有事件出现的次数， λ意义：事件的平均发生次数） 定义：（验证*） 期望：E(X) = λ（证明*） 方差：D(X) = λ （**证明***） 泊松变量的和：仍是泊松变量：若𝑿∼𝑷(𝝀𝟏)，𝒀𝑷(𝝀𝟐)且𝑿,𝒀独立，则𝑿+𝒀𝑷(𝝀𝟏+𝝀𝟐)（证明*！） 例：昆虫卵的分布*（条件概率+全概率公式） 几何分布（多重伯努利试验，不断重复直至A发生所需次数） 定义： 无记忆性（证明*， P(X&gt;t) = q^t）：假设已经经历了𝒏次失败，则从当前起直至成功所需次数与𝒏无关。严格地，设𝑿~𝑮(𝒑)，则对于任意自然数𝒔,𝒕有𝑷(𝑿&gt;𝒔+𝒕│𝑿&gt;𝒔)=𝑷(𝑿&gt;𝒕)，等价地，𝑷(𝑿=𝒔+𝒕│𝑿&gt;𝒔)=𝑷(𝑿=𝒕) 期望：E(x) = 1/p(三种证明方法*：定义(注意求导、负号) / 定理 / 条件期望) 方差：D(x) = (1-p)/p^2 (证明*：两种算E[X^2]方法: 定义（求导、错位相减） / 条件期望+无记忆性) 典型例题：票券收集问题（调和级数H(n) = lnn+θ(1)），快速排序比较次数X的期望 条件期望（常结合无记忆性） 条件分布(某事件A发生的条件下X的分布)：P(X = x | A) 条件期望 全期望公式（**证明***） 应用：证明几何分布的期望（按第一次事件是否发生分情况，利用无记忆性） 条件期望定义的随机变量：f(Y) = E[X|Y] -&gt; Y的函数构成的随机变量 性质：E[E[X|Y]] = E[X](**证明*, 用全期望公式**) 应用：分支过程（递归式） 方差 马尔可夫不等式（**证明*,引入变量I&lt;=x/a**） 只知道期望，且取值非负时使用 ，P(X&gt;=cE[x]) &lt;= 1/c 方差（反应数据的离散程度） 定义：D(X) = E[(X-E[X])^2] 简便计算：D(X) = E[X^2] - E[X]^2 性质：D(c) = 0,D(cX) = c^2D(X), D(-X) = D(X) (无线性性质) 协方差 定义：随机变量𝑿和𝒀间的协方差为𝐜𝐨𝐯(𝑿,𝒀)=𝑬[(𝑿−𝑬[𝑿])(𝒀−𝑬[𝒀])]=𝑬[𝑿𝒀]−𝑬[𝑿]⋅𝑬[𝒀]. 特别地，𝐜𝐨𝐯(𝑿,𝑿)=𝑫(𝑿). 𝑫(𝑿±𝒀)=𝑫(𝑿)+𝑫(𝒀)±𝟐𝐜𝐨𝐯(𝑿,𝒀) （证明） 性质 cov(X, c) = 0 cov(aX, bY) = ab·cov(X, Y) cov(X1+X2, Y) = cov(X1, Y) + cov(X2, Y) 若X与Y独立，则cov(X, Y) = 0 (反之不成立),即E[XY] = E[X]E[Y] , D(X+Y) = D(X - Y)= D(X) + D(Y) 随机变量和的方差 切比雪夫不等式（**证明***：利用马尔可夫） 例：抛硬币 连续型随机变量 一维连续型随机变量 分布函数 定义：F(x ) = P(X &lt;= x) P(x1 &lt;= X &lt;= x2) = F(x2) - F(x1) 性质（反之，任一有下列三个性质的函数都是某随机变量的分布函数） 单调不减（证明） F(-∞) = 0， F(+∞) = 1 F(x) 是右连续的（左闭右开） 连续型随机变量 定义 性质 对任意x，p(x) &gt; 0 ∫(-∞,+∞) p(x)dx = 1 F(x)是连续函数 P(x1 &lt;= X &lt;= x2) = F(x2) - F(x1) = ∫(x1,x2) p(x)dx P(x=a) = 0 若p(x)在点x处连续，则F(x)’ = p(x) 连续型随机变量函数的分布计算 分布函数法 定理（绕过积分） 联合分布函数 定义：F(x, y) = P(X &lt; x, Y &lt; y) (几何意义：无穷矩形) 性质 F(x,y)对每个变量单增不减 F(-∞, y) = 0, F(0, -∞) = 0, F(-∞, -∞) = 0, F(+∞, +∞) = 1 F(x, y)关于每个变量右连续 边缘分布函数： FX(x) = F(x, +∞) = P(X &lt;= x) , FY(y) = F(+∞, y) = P(Y &lt;= y) 随机变量的独立性 定义：对任意x,y, P(X&lt;=x, Y&lt;=y) = P(X&lt;=x)P(Y&lt;=y) &lt;=&gt; F(x, y) = FX(x)FY(y), 则随机变量X,Y相互独立 定理：若X, Y独立， 则f(X), g(Y)也独立 期望（绝对收敛则存在） 性质 方差、协方差：同连续型 二维连续型随机变量 定义 性质 p(x, y) &gt;= 0 ∫(-∞,+∞)∫(-∞,+∞)p(x, y)dxdy = F(+∞, +∞) = 1 边缘密度：已知联合密度p(x, y)，求X, Y的密度函数 二维随机变量函数的分布：已知p(x, y), 求Z = g(X, Y)的概率密度 分布函数法 卷积公式(Z=X+Y) 不独立时 极大极小分布 二维随机变量条件分布率 二维连续型随机变量独立的条件：p(x, y) = pX(x)·pY(y) 条件分布、条件密度 乘法公式 全概率公式 典型连续型随机变量的分布 均匀分布 密度函数 分布函数 期望，方差 定理(FY(y) &lt;= y) 指数分布 密度函数 分布函数 期望，方差 无记忆性 多个指数分布随机变量极小值的分布 正态分布 密度函数 几何特征 - 曲线在𝒙=𝝁±𝝈处有拐点 当固定𝝈,改变𝝁大小时，图形的形状不变，只是沿着横轴作平移变换 当固定𝝁,改变𝝈大小时，图形对称轴不变，但形状在改变；𝝈越小，图形越高越陡，反之图形越低越缓 分布函数 期望，方差（证明*：换元，奇函数，σ=1、μ=1的正态分布积分=1） 标准正态分布N(0,1) 性质（随机变量函数公式证明*） 一般正态分布的概率计算 独立正态分布随机变量的和 典型二维连续型随机变量分布 二维均匀分布 二维正态分布 边缘分布 独立性：X,Y独立 &lt;=&gt; ρ=0 协方差：cov(X,Y) = ρσ1σ2， cov(X*, Y*) = ρ 相关系数 标准化随机变量 相关系数 相关系数性质 柯西许瓦兹不等式 不相关等价定义 相关性 若|𝝆𝑿𝒀|=𝟏，则称𝑿,𝒀线性相关 𝝆𝑿𝒀=𝟏, 正相关 𝝆𝑿𝒀=−𝟏, 负相关 𝝆𝑿𝒀表示𝑿与𝒀存在线性关系的强弱程度。 |𝝆𝑿𝒀|越大， 𝑿与𝒀线性关系越强，反之越弱 |𝝆𝑿𝒀|=𝟎表示𝑿与𝒀不存在线性关系，称为不相关。 极限理论 大数定律（研究随机变量序列的均值收敛问题） 实例：如果工件的测量值真值为𝒂，第𝒏次测量值为𝑿𝒏,则{𝑿𝒏}就是一个独立同分布，均值为𝒂的随机变量序列。当𝒏充分大时，𝒏次测量的平均值应该和真值𝒂很接近。大量测量值的算术平均值具有稳定性，这就是大数定律的反映。 依概率收敛 区别于数列的收敛：对于给定的ε，Yn和a的距离可能会大于或等于ε，只是当n趋向于无穷时，这个取值偏差较大的概率将趋于0 连续映射定理（依概率收敛的随机变量的函数也依概率收敛）（证明） 大数定律 定义：随机变量的平均值依概率趋向于它们数学期望的平均值. 马尔可夫大数定律（利用切比雪夫不等式） 切比雪夫大数定律（两两互不相关） 独立同分布大数定律（切比雪夫大数定律的特殊情形） 该定理条件𝑫(𝑿𝒌 )=𝝈^𝟐可以省去，即只需期望存在。（被称为辛钦大数定律） 伯努利大数定律（频率稳定性的严格数学定义） 中心极限定理（随机变量和的正态分布） 定义（Zn的极限分布为标准正态分布） 独立同分布情形中心极限定理（本质上∑Xk服从正态分布，从而标准化后服从标准正态分布） 对于独立同分布的随机变量序列{𝑿_𝒏} 大数定律描述了其均值（或和）在𝒏→∞的趋势 中心极限定理则能给出给定n与x时的具体概率近似(也可以知道概率与x，求n；或者知道概率与n，求x) 伯努利情形中心极限定理 推论（n较大时二项分布的概率计算方法）n较大时，μn~N(np, np(1-p)) 用频率估计概率时误差的估计 统计量与抽样分布 基本概念 总体、个体 总体：研究对象的某项数量指标的值的全体。 个体：总体中的每个元素为个体。 研究对象的数量指标𝑿的取值在客观上有一定的分布，因此，可将其看做随机变量，它的分布称为总体分布。 样本 样本的二重性： 就一次具体观察而言，样本值是确定的数 在不同的抽样下，样本值会发生变化，因此可看做是随机变量 样本定义 特点 代表性：样本的每个分量𝑿𝒊与总体𝑿具有相同的分布 独立性：𝑿𝟏,𝑿𝟐,…,𝑿𝒏相互独立。 样本联合分布/密度 统计量（是随机变量） 常用统计量 样本均值 样本方差 修正样本方差 二者关系 样本标准差 样本k阶原点矩 样本k阶中心距 结论1：样本均值的均值和方差 正态总体的抽样分布 正态总体样本的线性函数的分布 定义 特别地，若取a=1/n，则U = X¯~N(μ，σ²/n) 标准正态分布的上α分位点 χ²分布（独立+**N(0,1)!**） 定义 性质 1、可加性：设X1χ²(n1), X2χ²(n2),且 X1, X2相互独立，则X1+X2 ~χ²(n1+n2) 2、若X~χ²(n) , 则E(X)=n, D(X)=2n. (证明) χ²分布的上α分位点 t分布 定义（二者独立！） t分布的上α分位点 性质 F分布 定义（独立！） F分布的上α分位点 性质 - - 关于正态总体抽样分布的四个定理 1、样本均值的分布（X¯~N(μ，σ²/n)） 2、样本方差的分布（χ²分布）（独立*） 3、由1和2推论（t分布） 4、两正态总体，样本方差比(S1²/S2²)**(F分布)、样本均值差(X¯-Y¯)的分布(t分布)（证明***） 参数估计 点估计（构造1个统计量） 矩估计 原则：以样本矩作为总体矩的估计，从而得到参数的估计量。 矩的定义 k阶原点矩：E[X^k] k阶中心距：E[(X-EX)^k] 期望是1阶矩，方差是2阶中心距 矩估计定义 方法 一个未知参数时（用X¯代替EX） 两个未知参数时 注意：Sn有两种形式！ 结论 极大似然估计 原则：选取估计值使得观测值出现的概率最大 离散情况：似然函数 连续情况：似然函数 单参数情况求最大值： 多参数情况求最大值： 没有极值时，从似然函数本身考虑最大值 正态分布的极大似然估计量：μ = 样本均值，σ^2=样本方差 极大似然估计的不变性 估计量的评选标准 无偏性 定义 k阶样本矩一定是k阶总体矩的无偏且一致估计量 特别地 样本方差Sn^2是有偏的！（**证明***）修正样本方差S^2是无偏的！ 注意 特别地，虽然S^2是σ^2的无偏估计量，但S不是σ的无偏估计量 有效性 多个估计量都无偏时，以方差小为好 定义： 算术均值比加权均值更有效. 一致性 无偏性与有效性都研究固定样本量的情况 一致性关注样本量n-&gt;∞的情况 定义 证明一致性的两个常用结论 k阶矩 已知是无偏估计量时 区间估计（构造两个统计量作为一个区间） 基本概念 区间估计 置信区间：[θ1^,θ2^] 置信度：1-α 说明 置信区间长度L反映了估计精度，L越小，估计精度越高 α反映了估计的可靠度，α越小，1-α越大，估计的可靠度越高，但此时L往往增大，估计精度降低 α确定后，置信区间的选取方法不唯一，常选长度最小的一个 枢轴变量法 单正态总体情形 均值μ的区间估计 已知方差，估计均值（样本均值的正态分布：定理1） 未知方差，估计均值（定理3） 未知均值，估计方差σ²（定理2） 双正态总体情形 已知方差σ1²、σ2²，估计均值差μ1-μ2（样本均值差服从正态分布） 未知均值，估计方差比（定理4(1),F分布） 单侧置信区间：只关心置信区间的上限或下限 单侧置信下限 单侧置信上限 非正态总体：均值的区间估计（大样本法） 大样本法：若样本量较大，可利用极限定理求出枢轴变量的近似分布，再求出未知参数的区间估计。 假设检验 基本概念 假设：假设是指施加于一个或多个总体的概率分布或参数的假设. 所作假设可以被接受或被拒绝. 反证法思想：为判断所作的假设能否被接受, 先假设其成立, 然后从总体中抽取样本, 根据样本的取值看是否有不合理的现象出现, 最后作出接受或拒绝所作假设的决定. 不合理：小概率事件在一次试验中几乎不会发生 本检验方法是 概率意义下的反证法，故拒绝原假设是有说服力的, 而接受原假设是没有说服力的. 因此应把希望否定的假设作为原假设 主要内容 参数检验 总体均值、方差的检验 双正态总体均值差、方差比的检验 非参数检验 拟合优度检验 独立性检验 显著水平α 假设检验中，我们需要对小概率的说法给出统一界定，通常给出一个上限α，当一个事件发生的概率小于α，我们认为这是小概率事件。 α常见取值 0.01, 0.05, 0.1 在假定 H0成立下，若根据样本提供的信息判断出某“异常”现象(发生概率p &lt;=α)发生，则认为H0错误显著。称α为显著水平。 假设检验步骤 \\1. 根据实际问题，提出原假设H0和备择假设H1； \\2. 确定检验统计量 \\3. 根据显著水平α，确定拒绝域 \\4. 由样本计算统计量值 \\5. 做出判断是否接受H0 两类错误 第一类错误： 为真时，我们仍有可能拒绝 ，此时犯了“弃真”错误 第二类错误： 不成立时，我们仍有可能接受 ，此时犯了“存伪”错误 正态总体均值的假设检验 单正态总体 σ²已知（正态分布检验） σ²未知（t检验） 双正态总体 σ1²,σ2²已知，检验均值差（正态分布检验） σ1²,σ2²未知但相等（定理4(2)） 成对数据 之前均假设X与Y的独立性；现实中，X和Y可能来源于同一个总体的重复测量称为block数据) 正态总体方差的假设检验 单正态总体（μ未知，χ²分布检验，定理2） 双正态总体，检验方差比 二项分布的检验 对于伯努利分布中p的检验（大样本法） 总结 关于μ的检验 关于σ²的检验 双正态总体μ1=μ2的检验 双正态总体σ1=σ2的检验 Tips 一致性关注n趋于无穷情况，可用连续映射定理，证明一致性两个常用定理 样本k阶矩是总体k阶矩的一致性估计量 已知无偏时，方差趋于0 注意估计量是σ²还是σ 连续型随机变量的函数均值，不用求密度函数，直接积分，与离散型相同 max与min P(min&lt;10) = 1-P(min&gt;10) = 1-P(x1&gt;10)···P(xn&gt;10) max、min的分布函数 多个指数分布极小值的分布 碰到α最好先画个图，别弄反 分部积分 注意正负号 1/θ求导时别忘了复合求导 o.w.的情况 独立时，E[XY] = E[X]E[Y]而不是0 非正态总体区间估计：中心极限定理，服从正态分布，若方差不知道则用样本方差代替 χ²分布的期望和方差样本均值和样本方差独立 求和的方差时，注意独立性！ 正态分布：X、Y不相关（cov = 0） &lt;=&gt; X、Y独立 注意绝对值拆成两部分 求随机变量函数Z的密度，先看Z的取值范围 边缘密度的范围不应该带变量 泊松分布的和仍是泊松变量，或反向分解成多个泊松变量 独立时E[XY]=E[X]E[Y]可扩展 将事件A分解为等价的B交C","link":"/2020/12/27/Probabilism_notes/"},{"title":"Problems","text":"搭建过程中遇到的问题 安全证书失效 无法进入自己的博客，Edge显示“您的连接不是私密连接” 解决办法是更新域名解析。方法跟当初绑定域名的一样。ping一下自己的blog，返回的一个IP值，就是github主机的IP值 然后去域名解析的地方设置一下这个IP：","link":"/2020/01/26/Problems/"},{"title":"Term Review","text":"期末复习整理 概率论 往年题 题型总结 笔记 视频 提取码: ee4p 数据库 知识点整理 模拟题 数据结构 模拟题 思维导图 密码:bb5h 课件 密码:fqfa 大学物理 视频 提取码: cbi4 计算机网络原理 思维导图 密码:3w2g 课件 密码:1zqf 杂 密码:5edw 计算机组成原理 思维导图 密码:d3u9 课件 密码:1y94 知识点 猴博士不挂科 视频 提取码: 4vks","link":"/2021/01/26/Term%20Review/"},{"title":"Resource Summary","text":"","link":"/2021/03/01/Resource-Summary/"},{"title":"SwitchyOmega安装使用","text":"代理管理和切换 下载安装Proxy SwitchyOmega 配置 规则列表的作用在于，收入大部分需要代理的网站并自动加载，无需在手动添加 AutoProxy 规则列表网址： https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt 应用选项即可 官网教程：https://proxy-switchyomega.com/settings/","link":"/2021/10/29/SwitchyOmega/"},{"title":"Word 学习笔记","text":"つ♡⊂ 视频链接: https://pan.baidu.com/s/14x7hE2edZGpKfr_U02-v9Q 提取码: wxu4 自动保存间隔设置为3分钟 自定义快速访问工具栏 （常用功能右键添加） 字被“吃”掉： 自定义状态栏将”改写”改为’插入” 功能区选项展示 （最小化左边） 发送时两份.doc与.docx （不确定对方版本兼容性） 取色器 （QQ截图/画图 RGB值） Smallpdf.com 格式转换网址 默认度量单位改为cm （选项—高级—显示） 单独设置中文西文字体 Ctrl+A Ctrl+D （高级—中文字体也应用于西文） 自动编号设置 （校对—自动更正设置—套用自动格式） 背景 （设计—页面颜色—填充效果—图片填充） 跨页表格没有标题 （布局—右上重复标题行） 重复标题行无法选 ①Ctrl+Shift+Enter 拆分表格 ②（布局—属性—文字环绕—无） 西文自动换行 Ctrl+A—段落命令启动框—允许西文在单词中间换行 文字特效 插入文本框—输入文字—文本框右键—设置形状格式—文本选项 遇见喜欢字体—截图—www.qiuziti.com（www.zhaozi.cn）—上传搜索 流程图拖动时箭头跟随 插入箭头时首位连接两个框的外围黑点 插入—截取屏幕 快速提取word所有图片 F12(另存为) 保存为htm格式 自动生成文件夹 网格线 视图 | 垂直线 图片—格式—对齐 汉字拼音 如果(rúguǒ)Ctrl+X — Ctrl+V — 以文本格式粘贴 如果(rúguǒ) 去除尾注横线 视图—大纲视图—引用—脚注显示备注—删除尾注分隔符 延续分隔符—进入页面视图 查找与替换 高级—通配符 AXX—&gt;ABC 查找与替换 * AXXXC—&gt;ABC （使用通配符） 查找与替换 批量更改—格式 （更改内容为任意图片必须为嵌入式） 查找与替换 批量电话号码打码 ([0-9]{3})([0-9]{4})([0-9]{4}) \\1****\\3 （使用通配符） Word默认字体 设计—字体—自定义 压缩图片（打开/保存更快） 格式—压缩图片 页眉页脚编辑状态插入背景图片（衬于文字下方）不变形 Word剪贴板 全部粘贴 图片一键替换 图片—格式—更改图片/右键图片 项目符号 开始—段落—项目符号—定义新项目符号 +—-+ 加号始末位置 减号表格线 Enter 生成表格 Tab生成下一行 Ctrl+Shift+Enter 拆分表格 导航窗口 大纲设置 调整下划线位置 选中文字—字体—位置—上升 （选中文字前后要有字符） 调整证件照背景颜色 图片—删除背景—填充颜色 小数点对齐 视图—标尺—制表符选择—点击对齐位置 “—“对齐 同上—数据前+Tab 斜线表头 插入直线分割—插入文本框（无轮廓无填充） 座位表设计 名字以英文逗号隔开—插入—文本转表格—布局—属性—表格选项增加边距—去外侧框线—姓名居中 去除多余换行符 替换—^p^p —&gt; ^p 去除手动换行符 替换—^l 去除留空 替换—^w 批量制作邀请函（奖状 桌签 工作证） 邮件—选择收件人—使用现有列表—插入Excel信息源（姓名性别邮箱等）—插入合并域（姓名）—添加规则—如果那么（性别为男 先生）—预览结果 限制编辑的文档 插入—文本—对象—文件中的文字—选择被保护文件 选择性粘贴 粘贴Excel表格 制作目录 开始—选择—格式相似文本—右键标题X更新 引用—目录 封面信息下划线对不齐怎么办 审阅—限制编辑（例外项可选择保护段） 文档加密 保存—工具—常规选项（取消时也是此位置） 文件—信息—保护文档 文档属性 文件—信息—高级属性—设置作者 删除文件属性 文件—信息—检查文档—全部删除 水印 设计—水印（/删除水印）—文字水印 页眉页脚自制水印 编辑状态—插入文本框—放大至合适（颜色适当调浅）—文本框置于文字下方—无填充无轮廓—两次Esc退出 关闭更正拼写与语法 输入网址自动改为超链接 选项—校对—自动更正—键入时自动套用格式—选择超链接相关 句首字母大写 文字显示不全 段落间距 自动编号 显示问题首先去找段落 兼容模式 文件—信息—转换 最近打开文件显示 选项—高级—显示—最近使用过的文档 图片 不能变形 排版整齐（利用表格（关闭自动调节适应内容） 剪切图片 去边框） 利用ppt（粘贴为图片） 取消显示开始界面（直接进入编辑） 常规—启动选项 自定义功能区 功能区部分右键—不在功能区命令 开始—编辑—选择—选择对象 同PPT托选多个内容 开始—编辑—选择—选择窗格 所有元素 添加书签（做标记） 插入—书签 选中文字—F2—移动光标—Enter 移动选中文字 插入图形 Ctrl+Shift+鼠标拖动 可在同一水平线 图文排版五原则 ①重点突出，增强对比 ②内容紧凑，增加间距 ③元素对齐，格式统 ④添加助攻，增加观赏性 ⑤规划版面，结构清晰 表格平均分布 布局—分布行/列 设置文字对齐 表格太宽观察不到 布局—自动调整—按窗口适应 图片显示不全 Ctrl+1 设为单倍行距 复选框  插入—符号—wingdings2 表格底部文字显示不全 表格属性—行高值（最小值）/允许跨页 表格变形 表格属性—表格—选项—取消自适应 表格—设计—表格样式 表格用处 三项表 联合公文头制作 封面制作 表格美观注意 文字在表格中位置 去边框 Word转PPT 标题—一级文本 正文—二级文本 word—Excel 插入—对象 表格转换行与列 Excel中两次复制 保存为PDF时 选项—创建书签时使用 可保留目录 自动更正—键入时自动更换 文档拆分 视图—大纲—一级文本—全选—主控文档—创建—拆分—保存 文档合并 新建文档—插入—对象—文件中的文字—插入文档 文档合并并与子文档实时连接 新建文档—插入—对象—文件中的文字—选择文档—插入为链接","link":"/2020/02/07/Word%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Short Sentence","text":"人间忽晚，山河已秋。 万物无邪，人间炽烈 万事胜意，平安喜乐 道阻且长，行则将至。（《荀子.修生》） 人生海海，山山而川。 听从己心，无问西东。 但行好事，莫问前程。（《增广贤文》） 身着白衣，心有锦缎。 生而为人，我很抱歉。 不忘初心，方得始终。（《华严经》） 未知苦处，不信神佛。（Priest） 日拱一卒，功不唐捐。（胡适） 来如风雨，去似微尘。（《增广贤文》） 一善染心，万劫不朽。（萧纲） 从善如登，从恶如崩。（《国语》） 我在远方，惜君如常。 白头如新，倾盖如故。（邹阳） 芝兰当道，不得不除。（张居正） 不矜细行，终累大德。（《尚书》） 华枝春满，天心月圆。（弘一法师） 选你所爱，爱你所选。（托尔斯泰） 久不联系，常在心中。 默然相爱，寂静欢喜。（多多） 我爱着，什么也不说。 向来缘浅，奈何情深。（顾漫） 花开如火，也如寂寞。（顾城） 黎明之前，黑暗最深。（腓特烈大帝） 此心光明，亦复何言。（王阳明） 艰难困苦，玉汝于成。（张载） 目光放远，万事皆悲。（钱钟书） 凡是过往，皆为序章。（莎士比亚） 一日不作，一日不食。（禅宗理念） 心有猛虎，细嗅玫瑰。（萨松） 得失从缘，心无增减。（释迦摩尼） 花看半开、酒饮微醺。（《菜根谭》） 家人闲坐，灯火可亲。（汪曾祺） 布衣饭菜，可乐终身。（沈复《浮生六记》） 大成若缺，和光同尘。（老子） 浮生若梦，为欢几何。（李白） 如鱼饮水，冷暖自知。 温柔半两，从容一生。 小恶不为，善莫大焉。 生而热烈，藏于俗常。 坠欢莫拾，酒痕在衣。（弘一法师） 浮舟沧海，立马昆仑。（周恩来） 生如逆旅，一苇以航。 山水一程，三生有幸。 得之我幸，不得我命。（徐志摩） 前尘隔海，古屋不再。（余光中） 生如芥子，心藏须弥。 良田万顷，日食一升。（《增广贤文》） 庸常之中，微芒不朽。 一别两宽，各生欢喜。 未知全貌，不予置评。（《魔道祖师》） 靡不有初，鲜克有终。（《诗经》） 凛冬散尽，星河长明。 东隅已逝，桑榆非晚。（王勃） 玻璃晴朗，橘子辉煌。（北岛） 虽不能至，心向往之。（司马迁） 凡有所相，皆是虚妄。（《金刚经》） 天寒地冻，路遥马亡。（海子） 未来可期，人间值得。 清斯濯缨，浊斯濯足。（孔子） 情之所钟，正在我辈。（《世说新语》） 视此虽近，邈若山河。（《世说新语》） 水波温柔，阳光强烈。（海子） 秋天深了，王在写诗（海子） 守岁花开，季季不同。","link":"/2020/12/13/short%20sentence/"},{"title":"Tips","text":"Tips for daily learning. Win11如何让右键点击默认就显示更多选项管理员运行命令： reg.exe add &quot;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32&quot; /f /ve # 重启后恢复win10右键 reg.exe delete &quot;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32&quot; /va /f #恢复win11右键 kali 国内源 与 apt-get update 报错-GPG error的解决方案12345678910# apt-get updateGet:1 http://kali.mirror.garr.it/mirrors/kali kali-rolling InRelease [30.5 kB]Err:1 http://kali.mirror.garr.it/mirrors/kali kali-rolling InReleaseThe following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt;Reading package lists... DoneW: GPG error: http://kali.mirror.garr.it/mirrors/kali kali-rolling InRelease: The following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt;E: The repository 'http://kali.mirror.garr.it/mirrors/kali kali-rolling InRelease' is not signed.N: Updating from such a repository can't be done securely, and is therefore disabled by default.N: See apt-secure(8) manpage for repository creation and user configuration details. 解决方法： 下载最新key添加到keylist wget -q -O - https://archive.kali.org/archive-key.asc | apt-key add 其中 123wget archive.kali.org/archive-key.asc //下载签名apt-key add archive-key.asc //安装签名 Kali 镜像下载（阿里云）https://mirrors.aliyun.com/kali/https://mirrors.aliyun.com/kali-images/ Kali国内源1234567891011121314151617181920212223242526272829303132#中科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib #阿里云deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib #清华大学deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙大deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-freedeb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free #东软大学deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contribdeb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib #官方源deb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib deb http://mirrors.163.com/debian/ jessie main non-free contribdeb http://mirrors.163.com/debian/ jessie-updates main non-free contribdeb http://mirrors.163.com/debian/ jessie-backports main non-free contribdeb-src http://mirrors.163.com/debian/ jessie main non-free contribdeb-src http://mirrors.163.com/debian/ jessie-updates main non-free contribdeb-src http://mirrors.163.com/debian/ jessie-backports main non-free contribdeb http://mirrors.163.com/debian-security/ jessie/updates main non-free contribdeb-src http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib","link":"/2021/10/30/Tips/"},{"title":"Sentence","text":"世间鲜有真可爱者，老子就是其中一个 如果夜里不能吃东西，那冰箱里为什么会有灯呢？ 睡不着，在数羊的时候，突然有一只小羊站了出来对我说“请你用心一点，你已经数过我一次了。” 白白胖胖 充满希望 今天的风好像会说话 他对我说:头给你拧掉 我原来是叼着烟开拖拉机的，自从遇到你，开始留意橱窗里的裙子。 月亮和星星会不会互道心事。 狐狸用尾巴扫干蘑菇上的灰尘 刺猬们也把肚子露出来了 长颈鹿不停的吃掉颜色不好的叶子 因为你走到我的森林里来了 我来考考你的数学 请问你的电话号码数字是多少 你不要淋到雨啦 不然你会可爱到发芽了 星河滚烫，你是人间理想 唯有南山与君眼，相逢不改旧时青 我吃完了一个五斤的西瓜，也没有等到回复我的信息，我想，这应该不是你不够喜欢我，而是这西瓜不够大。 我想要在茅亭里看雨、假山边看蚂蚁，看蝴蝶恋爱，看蜘蛛结网，看水，看船，看云，看瀑布，看宋清如甜甜地睡觉。——朱生豪 月色与雪色之间，你是第三种绝色。——余光中 世间情动，不过盛夏白瓷梅子糖，碎冰碰地当啷响。 把血液滴入杯子 加糖 搅拌 喝下去 我会变得更美好 “耳机线是年轻人的输氧管” 我对你那么好 是想让你以同样的态度对我，而不是让你觉得自己多牛逼，cnm. 各位朋友们，都她妈给我好好的，给我挺住了！——2020.2.3 可惜一溪风月，莫教踏碎琼瑶。——苏轼 世间所有的相遇，都是久别重逢。——白落梅 交友须带三分侠气，做人要存一点素心。——《菜根谭》 草在结它的种子，风在摇它的叶子，我们站着，不说话，就十分美好。——顾城 今天的云很好看，我想拍给你看，却想到我们很久不联系了，突然觉得，其实云没那么好看了。 最近压力有点大，可以叫我一声爸爸让我迷失下自我吗？ 你赢了，我就不算输。 山不过来，我就过去。——《古兰经》 死去活来不一定是深情厚谊，多半是没见过世面。 希望你明白，我凡事都看得开，但并不影响我记仇。 人生在世，还不是有时笑笑人家，有时给人家笑笑。——林语堂 我们笑着说再见，却深知再见遥遥无期 ——《海上钢琴师》 疏影横斜，远映西湖清浅；暗香浮动，长陪夜月黄昏。——张岱《补孤山种梅叙》 余光中《听听那冷雨》 因过竹院逢僧话，偷得浮生半日闲。 少年的肩应该担起草长莺飞和清风明月 少女的眼应该藏下星辰大海和万丈光芒 所谓心事，不过是不如己意。——林夕 生命的过程，无论是阳春白雪，青菜豆腐，我都得尝尝是什么滋味，才不枉来走这么一遭。——三毛 有幸成为知己 但最后还是成为甲乙 桂棹兮兰桨，击空明兮溯流光。——苏轼· 《前赤壁赋》 庭下如积水空明，水中藻荇交横，盖竹柏影也。——苏轼· 《记承天寺夜游》 云想衣裳花想容，春风拂檻露华浓。 一生一会 拈杯酒眯着眼 说专心看人间 数学里有个遗憾的词叫：渐近线 无限接近却永不相交 雾凇沆砀，天与云、与山、与水，上下一白。湖上影子，惟长堤一痕、湖心亭一点、与余舟一芥、舟中人两三粒而已。——张岱 《湖心亭看雪》 月亮今晚不营业 所以我来说晚安 “好想变成雪啊，这样就可以落在先生的肩上了……” “若是先生撑了伞呢？” “那就落在先生的红伞上，静载一路的月光。” “若是先生将雪拂去……” “那就任他拂去，能在他的手掌上停留一刻，便足矣。” “诺是先生撑伞的同时快速旋转伞同时自身以一个反方向转这样形成一股气流可以不断吹雪，加上上下横跳的走路灵巧避开所有雪呢？” “…” 我本想这个冬日就去死的 可最近拿到一套鼠灰色细条纹的麻质和服 是适合夏天穿的和服 所以我还是先活到夏天吧 ——太宰治 若非群玉山头见，会向瑶台月下逢。——李白· 《清平调·三首》 远(遥)赴人间惊鸿宴，一睹人间盛世颜。 要做不声不响，得到整个月亮的人。 “妈，你为什么那么爱笑啊”“因为妈生了你啊”——贾玲小品 做个小朋友，掏掏小口袋就有糖掉出来的那种。 中国人，你有什么理由不自信。中国人，你有什么理由不自强。 前天我右腿撞到石头，当时觉得疼了一阵也就没事了，今天才发现那一块已经青紫。人生很多事情都要延迟许久许久才会感觉到疼。你能想象吗，也许等到你四十多岁的某个夏夜，开车回家，在某个路口等红绿灯的时候，你突然反应过来，十九岁的时候，那个人说的那句话原来是这个意思。 “科学越是毫无顾忌和大公无私，它就越符合工人阶级的利益和愿望。” ——恩格斯 贞子从电视里爬出来，看着眼前哭的一塌糊涂的女孩，悄悄把手伸出来，呐，就一根冰激凌，不许再哭了！ 花も樹も僕らもカナシイ 你要知道 天越黑 月亮越亮 我喜欢可乐 昨天去超市买可乐 发现没有了 我就随手拿了瓶百岁山 到门口结账时突然发现了可乐 可是我不想换了 会给自己买花 也会自己长大 今でもあなたは私の光. 云深藏恼 在雨天释怀 淋了邻家的猫 我太容易生气了 我应该去幼儿园门口卖气球 . 要努力呀 为了想要的生活 为了人间的烟火气 为了今天的风和月 2%的美食碎片+98%的可爱拼凑成了我 你在路上随便碰到的一个路人，都是别人做梦都想见到的人 你的脖子真可爱，顶着一个猪脑袋 水煮蛋，溏心； 酥烧饼，刚出炉； 五花肉，邂逅烤盘； 小笼包，呼吸着温热的雾； 绿豆糕，清甜的味道刚刚好； 红樱桃，恰巧是那一颗蹦上了蛋糕。 可这都比不过，你站在早晨的阳光里，微微地笑。——《香港中文大学微情书大赛获奖作品》 从不愿打个电话 即使只记得你和妈妈的号码 无理毒舌武断专横 青春期交替着噤若寒蝉和火山爆发 你常吹嘘自己是那个年代的大学生 年轻时文艺 老了也能把我的高考作文批的体无完肤 高学历的你无意间说 收入还不如那些没升学的同辈九牛一毛 但我还是无法原谅你病态的吝啬 你说儿子和老子是上辈子互相欠债的仇家 不带戏谑不带抱怨 仿佛陈述着宇宙至理 还记得你拿着录取通知书嘲笑般 说 这下你可以远走高飞了 昨天你一个没头没脑的电话 早点睡，不然像老子一样掉头发 ——《关于父》 你说一个人自杀，是想通了还是想不通了 后来我发现世界真的很大，没有刻意地见面，就真没有再见过了 许多年后汤姆已经老了，主人不再喜欢他，家里新来的猫咪也总欺负他，当猫们再一次吧汤姆的食物扔岀门外时，汤姆拖着已不再灵便的腿走了好远，才将那块沾满了灰尘的奶酪捡回来，他长舒了一口气，在猫们的嘲笑声中，小心翼翼的将奶酪放在墙角，那个结满了蜘蛛网的老鼠洞门口，许多年后你还在不在。 那年上初中，夏天是好漫长的，西瓜是吃不完的，作业是最后两天才赶的 我想做一个能在你的葬礼上描述你一生的人。 “你知道我妈妈是谁吗” “不，我不是很清楚，她是谁？” “你不知道我妈妈是谁吗？” “我得想想”老人思考了一会回复“你妈妈是谁？” “我是乔治，我的妈妈是谁？” “是…对不起乔治，我实在不知道。” “好吧。” “那你的妈妈…是谁呢？” “是你啊” ——儿子与患阿尔茨海默病的母亲对话 人生碌碌，竞短论长，却不道荣枯有数，得失难量。——《浮生六记》 玻璃晴朗，橘子辉煌。——《过节》 放弃不难，但坚持一定很酷。 当你凝视深渊时，深渊也在凝视着你。——《善恶的彼岸》 人死像熟透的梨，离树而落，梨者，离也。——《活着》 “我想，一辈子做个钓鱼人，像个白痴一样生活。”“你做不到的。你太容易理解鱼的心情。” ——太宰治《秋风记》 而无缘的人，就总是要彼此错过了。若真的能就此错过的话倒也罢了，因为那样的话，就如同两个一世也没能相逢的陌生人一样，既然不相知，也就没有得失，也就不会有伤痕，更不会有无缘的遗憾了。 小时候我妈教我写作业我不会她就打我，前几天我教她用百度地图她学不会又打我。 中国是个伪装成国家的文明。 “这个世界腐败，疯狂，没人性。您却清醒，温柔，一尘不染。” ——《萨冈写给萨特的情书》 《大宋少年志》 “明知是挑拨，却压不住疑心。人性如此，没法子。” “是这世道的阴暗造就你不懂礼数的浅薄，不是你的错。” “我守自己的原则，可从来不会约束别人，各有各的底线，互相体谅就好。” “可如果真到了讯息便捷那一天，有敌方贬低国情宣扬自己呢” “那会比正面杀敌更危险，也更复杂，但是值得庆幸的是，这样的事，不会发生在我们现在这个年代。” “人生于世，无论聪慧愚笨，都独一无二，自有精彩之处，所以不必小瞧自己。” “女孩子这样子太不可爱了” “谁要你觉得可爱了” “不管过去多久，都要对心怀愧疚的人说一句对不起” “人怎么能不相信朋友呢” “世事本就不公，你又待如何” “可我还没有复习呀” “赵姐姐果然是我学习的榜样” “每个受委屈的人，都觉得自己没错，这种理由我没兴趣。” 礼法是为人情所设 虽然重要 却重不过人心 人和人之间看似相近 其实距离胜过千里万里 所谓心如渊海 谁都无法真实知道旁人的心思 也只有言语里不作为 才有可能试着了解彼此","link":"/2020/02/03/%E5%8F%A5%E5%AD%90/"},{"title":"当代青年极简穿搭指南","text":"我只有四条裤子，如果新买了一条，那必须得扔掉现有的一条。 @少数派Chay 这是《北漂青年生存指南》的第三篇文章。目前所有的衣服（包含春夏秋冬）：上装6 件 T 恤4 件衬衫1 件运动外套，1 件运动卫衣，1件休闲外套1 件三合一冲锋衣1 件长款羽绒服，1 件中长款棉服下装2 条运动长裤，1 条牛仔裤，1 条休闲裤1 条牛仔五分裤鞋子1 双跑鞋，2 双休闲鞋，1 双篮球鞋其他3 条篮球短裤1 条皮带好好穿衣，简单搭配维持较少的衣服数量，大概是从学生时代遗留下来的习惯，毕竟宿舍狭小的衣柜装不下太多衣服。而在工作之后，衣服的数量和类型也没有太多变化，并且向着更白搭，更普适的方向演进。更进一步，在满足基础的穿衣需求的前提下，如何降低衣服数量和简化搭配是我近一两年来更多考虑的问题。如同本文开头所述，我只会保留四条裤子来适应所有场合，这一做法就是在不断实践极简和实用性之间找到的平衡点。在满足基本需求的前提下，减少衣服数量对衣服断舍离的边界是要能覆盖基本的穿着场景，并且与换洗频率之间形成一定的权衡。覆盖目标场景从衣服的温度属性出发，针对所处城市的气候特点，选择衣物。我身处北京，并且在未来几年，都会在这里生活下去，所以衣服的选择主要考虑北京的气候特点。北京的春秋时间较短，而冬天又有暖气供应。暖气一般从 11 月中旬到次年的 3 月中旬，在此期间室内室外温度差巨大（室外零度以下，但室内会超过 20 摄氏度）。按照不同季节的情况，可以分类如下：夏季。北京夏季的时间大概是从 6 月 到 9 月。考虑到工作岗位的性质（程序员）对着装并无要求，我一般是上装 T 恤，下装篮球短裤（过膝）或者牛仔五分裤。春秋季。北京的春秋季时间很短，在这段时间，上装 T 恤/秋衣 +（衬衫）+（薄外套），下装长裤，衬衫可按温度选择是否穿着。冬季。上装 T 恤/秋衣 + 衬衫 + 厚外套，下装秋裤 + 长裤。需要注意的是，（对于我来说）下装只穿秋裤 + 普通长裤是无法长时间待在室外的，但是考虑到较高的室内温度，下装穿的太厚又不好穿脱，在室内会太热。考虑我们一天的绝大部分时间都是待在有暖气的室内的，所以下装不能穿的太厚。在这种气候条件下，可以直接精简掉某些品类的衣服。毛衣首当其冲，因为开暖气后，太热不方便穿脱。所以我把毛衣都扔掉了。本科时候，我的衣服品类里面还有风衣，那时在合肥这个偏南方的城市，风衣还可以勉强多穿一段时间。来到北京之后他也被精简掉了，毕竟它只适合 5℃~15℃ 的场景，而在北京，这个机会转瞬即逝。选择基本款从衣服的社会属性出发，不同的穿衣场景包括：工作日上班以及周末在家。休闲类和运动类衣服皆可周末出门。通常休闲类，视具体情况选择搭配。运动：篮球，跑步等。运动类衣服选择基本款的衣服是实践断舍离的必然要求。基本款的衣服具有较强的普适性，可以在不同场景下实现复用，进而降低衣服总量。对于品牌，优衣库（我目前的衣服中 70% 都是从优衣库购入）是大多数人的推荐。睡衣的需求也被我精简了。我用 T 恤 + 篮球短裤代替，从而不需要额外准备睡衣。但毕竟睡衣的面料更舒适，也可能会在未来尝试，这是极简与舒适度之间的 trade-off。多件衬衫之间可以有一定的区分度（偏正式和偏休闲），用以适用不同的场景。一条腰带，为了追求方便，选择自动扣。一些简单的衣服搭配规则由于没有正装的需求，我的衣服可以分为休闲和运动两种类型，它们之间的搭配会有一定的约束条件，由此形成一些穿衣规则。这些基础的搭配规则可能是一种迷思。在此罗列，并不意味着它是被广泛接受的原则。有些规则详细考虑的话可能又是毫无必要的，其中饱含我个人的偏见，因此不构成任何建议或意见。运动类的上装/跑鞋与牛仔裤/休闲裤互斥。错误示例：运动速干 T 恤搭配牛仔裤。衬衫与运动裤/运动鞋互斥。错误示例：衬衫搭配跑鞋。休闲鞋与所有类型的上装和裤子兼容（休闲鞋的定义实在宽泛，此处休闲鞋指运动用品厂商的运动休闲鞋，如 Nike SB 系列）。这些规则可以总结为运动类与休闲类分开。但很多时候并非一成不变，Adidas Superstar 和 Nike Air Jordan 最初推出时候都是篮球鞋，但如今都变成大大众意义的休闲鞋范畴。抵制盲目的消费幻想枯燥的生活总会冒出无数幻想，有段时间我突然迷恋上了西服，起因是在生活大爆炸（Season 3 Episode 18）中看到一段 Sheldon 试穿西装的场景。事实上，二十五年来我从未曾穿过西服，而在可以预见的未来，我也不会有什么场合能穿上它，也许受邀作为婚礼的伴郎可能算上一个。《生活大爆炸》剧照类似的我称之为「消费幻想」的念头，时常会在我脑海中浮现。大部分时候，我能够理智的斩断这种念头，对我来说，买衣服只有两种情况：当前某件衣服需要「退役」，买入相同性质的衣服替代。快消品的衣服的寿命不会很长，普通的裤子 1~2 年差不多就要更换。由于更换是购买相同性质的衣服，这对于「选择困难症患者」也极其友好，因为完全不需要过多考虑，甚至只需要去优衣库买一件相同的回来就可以。当前的衣服无法覆盖某些特定且刚需的场景，经明确需求后买入。十一的时候我去了一趟西北环线自驾，用的是 Osprey Porter 46 背包。但在前一天晚上打包的时候犯了难，由于温差较大，我必须携带一件较厚的外套，这让背包空间捉襟见肘，勉强才塞下所有必需品。这也使得在机场安检时候十分窘迫（需要费力重新打包）。而且由于目的地昼夜温差较大，厚重的棉服着实不够灵活。为了应付这种外出游玩温差较大的场景，三合一冲锋衣显得尤为合适。为此我在之后就购入了一件，而且日常也可以穿着，并不会闲置。但如果真的盲目消费了呢？那就扔掉吧，而不应该考虑沉没成本。慢慢的，我就培养出来固定的消费模式（以购买被子为例）：收集需求（发现生活中的「不美好」）。我之前使用的四件套和被芯是宜家的安斯莉娅和罗特帕，但使用起来有一个致命的缺点：被芯在被罩中跑动，无法贴合，睡一觉起来被芯已经缩成一团。加入愿望清单，调研解决方案（买什么，怎么买，参考什么指标，确定价位）。被芯和被罩不贴合，这种基本的用户体验被厂商忽略实在不应该。经过一番研究后，我发现除了淘宝买被子固定器外，厂商提供四角系扣才是合理的解决方案。而被芯跑动是因为被芯的面料材质摩擦系数太小，这通常是由于成本控制的考虑，没有使用纯棉面料而导致的问题。在此期间，我顺便了解了床品的棉的种类、纱支密度、编织工艺，然后按照自己能承受的价格水平确定选择范围。购买。如果是伪需求，或者现有的就可以解决，就直接略过。如何管理复杂？唐纳德·A·诺曼在《设计心理学2：如何管理复杂》中，有如下阐述：日常生活通常是复杂的，但并非由于某个特定的活动是复杂的，而是因为有那么多表面上简单的活动，每一个都有它自己一套特定的需求，把大量简单活动合在一起，结果就很复杂。穿衣是一件简单的事情吗？时间退回到 40 年前，我想是的，那时中国是「蓝色的海洋」。而生产力大幅提高的今天，文化，舒适度，质感等各种因素都在影响着我们对于服装的搭配选择。这时，如何化繁为简就是一种优雅，一种被设计的优雅。《大院子女》剧照 ——「蓝色的海洋」设计的概念可以非常广泛，2018 年日本优良设计奖颁给寺院住持，因为他发起的项目将人们供奉寺院神明的供品回馈社会中有需要的人，从而解决了贫困问题。这是我在 2020 北京设计博览会的讲座中听到的故事，那进一步的知识迁移一下，穿衣这件事也是可以「被设计」的。利用软件来辅助进行穿衣管理也是一种行之有效的方法，Android 和 iOS 的应用商店中可以找到很多类似的应用。不过由于我的衣服数量足够的少，所以我并不是使用这类软件，但对某些人来说可能是个不错的解决方案。 ​","link":"/2023/07/01/%E5%BD%93%E4%BB%A3%E9%9D%92%E5%B9%B4%E7%A9%BF%E6%90%AD/"},{"title":"睡前故事","text":"՞• •՞ 2020-02-10 《田螺》小青年许了个愿望。他想拥有一个田螺姑娘。小青年是个死宅，平日里大门不出二门不迈，能逃的课都逃了，不能逃的课想尽办法也逃了，奈何期末考这件事，实在是逃不过去。小青年翻出教材，开始复（预）习了。所谓工欲善其事，必先利其器，小青年环顾四周，决定先来个大扫除。第一天，他将积攒的外卖盒打包扔了出门。第二天，他将积攒的快递盒打包扔了出门。第三天，他将积攒的零食袋打包扔了出门。第四天……第四天，小青年反应过来了，这样不行。垃圾被清空后，露出了脏兮兮的地板，书桌仍旧是杂乱无章，宿舍里一股奇奇怪怪的味道，更是令人头疼。小青年对着满地狼藉叹了半天气，开始虔诚地许愿。小青年是无神论者，只是凑巧想起了小时候听过的那个童话，许完愿后他也没在意，开开心心地打了会游戏就去睡觉了。没成想，第二天一早，真的见到了一个全新的宿舍。柜子被收拾得整整齐齐，衣服被叠得方方正正，戴着围裙的男人一手拎着桶，一手拎着拖把，从卫生间走了出来。小青年：！！！四目相对的一瞬间，小青年试探性地喊了一声：“田螺姑娘？”男人沉默着，额角的青筋不安分地跳了跳。小青年连忙改口：“田螺先生！”男人抿了抿嘴，他放下桶，扔下拖把，两步走到小青年身旁：“你知道现在离期末考还有几天吗？”小青年茫然地摇了摇头，正要掏出手机询问同学，却突然被人揪住了领子。天旋地转之间，小青年被粗暴地摁到了书桌前，男人俯下身子，在他耳旁冷笑：“田螺……”“田你妈的螺，老子是你再不看就要挂科了的教科书！” 《医隐》公元2051年，医生被打、被虐到实在挺不下去了，慢慢都改行了，散落在各个角落。他们从事各种手艺活儿：有的卖麻辣烫，有的当裁缝，有的做铁匠，有的写小说。有一天，有个熟人病了，我偷偷告诉他：“指点你一条生路。你走到前面巷子左拐，有一家裁缝铺，找那个戴着眼镜噘着嘴、慢吞吞地一针一线缝衣服的大妈，她怎么说你就怎么做。“你这病的病灶已经转移，浸润不浅，这刀估计隔壁铁匠开不了，你得去南门找那个卖风筝的才行。他师父在青城山前卖羊肉串，实在不行只能请他出山了。诚意要足，记得多带上好的孜然。还有，记得请十六铺卖麻袋的光头做麻醉。” 《平安》将军是个普通的将军，就像所有的将军一样，他骁勇善战，打起仗来胜多输少，守护了一方平安。他善战，但是并不喜战。他骁勇，但是并不莽撞。他打打杀杀，钻研兵法，在战场上阴损招数也没少用。但是他喜爱书画，他善作诗，为人光明磊落。他不穿战衣的时候，捧本书卷，挥洒笔墨，甚至像个书生。这样的将军，就像所有的将军一样，远在皇城的地方，有一个在等他的姑娘。姑娘是个好姑娘，大家闺秀，温柔体贴，细致入微。她精通诗画，写的一手好字，她会和将军谈古论今，她会和将军斗诗，她会在将军出征的时候绣一个小小的平安福，她会在夜间一遍遍弹着寂寥的曲子等将军归来。她会和将军共度一生。她想和将军共度一生。可将军不会，可将军不想。所以将军还是将军，姑娘只是姑娘。皇帝是个昏庸的皇帝。浑浑噩噩，在治国方面是个庸才。可皇帝不听奸臣谗言，他只听将军的。老皇帝死后，国内动乱了一阵，各方蠢蠢欲动，都想把无用的太子推翻。可将军不想，将军尽职尽责的守住了皇宫，守住了当时还是太子的皇帝。从那之后，皇帝谁也不信，只信将军。他最愁的就是战争，因为这样，将军就要离开皇城，那时就剩他一个人面对这一池深水。可他不得不把将军派出去，因为他信将军，万民信将军，只有将军能守护这一方平安。他不会写诗，一手字也写的歪歪扭扭，他也听不懂高深的兵法之道。可他知道战场上的凶险，可他坚持在将军出征之前给将军一张爬满了平安两字的字条，可他会一遍遍的念着将军写的诗等将军回来。但将军是人，不是神。他败了。一只箭射中了他的胸口，将军跌下马，可他不能倒，他身后是他的国，是他的家。是他想守护住的一切。他折断箭柄，杀红了眼，可身边的人还是一个个的倒了下来。到后来，只剩下他一个人，直愣愣的站在天地之间，满身血污。后来对面的人说，只要将军投降，他们不会滥杀。那人又说，皇帝昏庸无道，将军不该愚忠。将军想了想，放下了剑。那你们不能杀了皇帝。这是将军倒下之前，说的最后一句话。将军倒了，国亡了。皇帝面对敌军，听说将军已经投降，面无表情。他站在宫门口，听见了众人的义愤填膺，无一不是对将军的谴责。可他只是走到敌军面前，那双腿，就这么跪了下去。许是皇帝太过无用，敌国并没有杀了皇帝，而是封皇帝为他国郡王，作为人质扣留在敌国。敌国赏识将军，尽力救回了将军，让将军继续守护着他的家，可不再是他的国。将军再也不会上战场了，姑娘也不需要苦苦等将军归来了。将军不再是将军了，姑娘却成了他的夫人。皇帝也不再是皇帝，可他并不在乎，甚至国破至今，他也未曾流露出半分悲伤。他本就不是当皇帝的料子，吃喝玩乐才是他的长处。他后来在酒席上见到了一位随军的老军医，那军医喝醉了，又向人泛泛谈起他的光辉事迹。那将军，就是他救活的。这本该是皇帝最不想听到的事情，可他听的津津有味。直到最后，老军医讲完了，口齿不清的嘟囔了一句：将军的心口窝，护着一张字条，那上面密密麻麻的，写满了平安二字，许是将军夫人写给他的…众人只道伉俪情深，夫妻恩爱，一段佳话。可皇帝哭了，撕心裂肺。皇帝不再是皇帝了，将军也不是将军了。幸而的是，他们都尚且平安。 《记慈父》我小时候，一个做父亲的就像电冰箱里的灯，家家都有一个，可谁都不知道冰箱门关上以后那盏灯在做什么。我爸爸每天早上出去，晚上回来看见大家好像很喜欢。谁都打不开的罐子他能打开；家里只有他敢独自到地下室去。他刮破脸，谁都不会安慰他或大惊小怪。只要下雨，人们准知道他会拿雨伞遮着我们出门，家里有人病了，总是他到药房买药。他安装捕鼠器，剪除玫瑰花的枝叶，使你不致为荆棘刺伤。我买了自行车，他跟着我至少路了一千里。直到我会骑为止。别人的爸爸我都怕，可是我不怕我的爸爸。有一次我给他冲茶，我冲得很淡，可他坐在小椅子上说好喝得很。每次我过家家，玩具妈妈有好多事可做，玩具爸爸我不知道让他做什么好。我就叫它说一句：“我要上班去了。”然后就把他丢在床底下。九岁那年，一天，爸爸没有起床上班，他进了医院，第二天就死了。我回到卧室把那个玩具爸爸从床下摸出来，扑扑上面的灰土，把它放在床上。他没有给我做过什么。我不知道他走了我会那么伤心。至今我还不晓得为什么。 2020-02-08 《纪新冠肺炎》后史记载： 庚子鼠年始，荆楚大地瘟魔肆虐。钟南山医圣携数万白袍同数千万荆楚豪杰共击瘟魔，数万人染疾，众惶恐。足不出，举国防。时九州一心，青丝，白发，皆身先士卒。布衣，商客，皆争先解囊。政医兵者扛鼎逆行为之勇战矣，能者皆竭力之。不日火神山，雷神山拔地而起，神威浩荡荆楚。数日后华夏大地无数白袍同身而起剑指瘟魔，疫尽去，万国赞。 《庆余年番外之轻眉传》@杏仁一勺 一叶轻眉从睡梦中醒来的时候，神庙外正下着一场纷纷扬扬的雪，大雪弥天盖地，化成仿佛要掩盖一切真相的纯白，将冰雪中的神庙映衬得宛若天堂。 她伸了个懒腰，揉了揉有些酸痛的脖颈，推开站在床边的清秀少年递过来的厚重冬衣：“谢谢，姐姐我不冷。” 少年身着剪裁简单的黑衣，眼前蒙着块黑布，听了这话后神色却没有半分变化，悬着的手执拗地举在叶轻眉眼前。 “真是个木头疙瘩。”叶轻眉气愤地挥起拳头，奈何小小而又肉乎乎的拳头没有半点震慑力，只得悻悻放下，老老实实穿起了衣服，托着腮愣愣望着窗外。 “这是今年的第几场雪了？” 这一年叶轻眉四岁，准确来说，是工科女博士叶轻眉来到这个世界的第四个年头。 自从一场车祸后，再醒来的她便发现自己躺在一个培养皿里，营养液包裹着新生的躯体，却没有让她有丝毫不适。 “我这是重生了还是被克隆了？”无数念头出现在叶轻眉的脑海里，可这具小小的躯体能做到的事情实在有限，最多只能发出几声含糊不清的咿呀声。 直到叶轻眉一岁多可以下地的时候，她才确认自己确实来到了一个与先前完全不同的时代，而自己身处的地方，则是身处北极而被称作神庙的…军事博物馆。 神庙里除了她自己，便只有几个冰冰冷冷的黑衣人，负责照顾她生活起居的是一个长相清秀的少年，除了不爱说话，扮相奇怪，仿佛在cos伊利丹之外，简直挑不出任何毛病。 叶轻眉对这些人的来历并非不好奇，前世的记忆也让她有了一个大致的猜测，但她并不愿接受这样的事实，而是日复一日地尝试着与这些寡言的黑衣人沟通。 如果神庙里有第三者在场，便会常常看到这般有趣的景象，一个粉雕玉琢的小女孩，挂在一个清秀少年的背上，仿佛公主一般巡视着空荡荡的大厅，向对分布在四周仿佛石像般的黑衣人们打着招呼。 “大个子，你一定是吃了很多饭才能长得这么高。” “三颗痣，我今天穿的衣服好看吗？好看的话你就不要说话。” “木头疙瘩，还是你好，肯背着我到处逛，他们都不和我说话，哎，我该给你取个什么名字呢？” 神庙外常常下雪，外面是千年不化的冰山，叶轻眉也曾想过走过这一片冰天雪地，去外面的世界看看，可这小小的身体实在是经不起折腾，倘若在这片白里迷失方向，便是有去无回，更何况那些黑衣人虽然沉默，但当自己想要走出神庙时，便会阻拦。 每想到这，她总是气得牙痒痒，紧紧攥着自己的小拳头，暗暗谋划。 再过几年，再过几年姐姐我一定走出这个破神庙，到时候我要做首富，揍皇帝，还要吃各种好吃的。 叶轻眉的出逃计划戛然而止在第四年的第七个月，那天，沉寂许久的神庙来了客人。 两个衣衫褴褛的年轻人在跨过迅猛肆虐的风雪后，终于倒在了神庙的石阶前，许久没有站起的力气。 叶轻眉躲在柱子后面远远的观望着，二人瘦得只剩骨头，穿着厚重的羊皮袄子，身上都带着斑斑的血迹，在冰雪的封冻下变成了一种古怪的粉红色。 其中一人面容阴郁，在休息片刻后终于奋力起身，似乎想要去寻找进入神庙的通道，而另一人则对周遭发生的一切充耳不闻，虔诚地跪在庙前的石阶前，不停叩首。 叶轻眉的双眼一转，清脆的声音透过神庙的屏障传出。 “喂，那边那个跪着的，你是来干什么的？” 跪在阶前的年轻人猛然抬起头来，空洞的双眼里乍然出现难言的神采。 “大魏苦荷，来神庙寻长生之法。” 叶轻眉感到有些好笑，果然无论是在哪个时代，人类都会对长生抱有幻想，长生有什么好的，你看机器人不也长生。 她清了清嗓子：“长生之法没有，延年益寿的法子倒是一大堆，你只要答应我一个条件，我就可以给你……” 那天的场面颇为戏剧，刚逃出神庙的叶轻眉一头扎进了碰巧回来的另一个年轻人怀中，而苦荷则拖住了从神庙里冲出的黑衣人，三人在风雪的掩映下顺利脱出了神庙的监控范围。 那两人不知为何突然把自己奉若神明，叶轻眉也没有诚实到戳破他们的无聊幻想，而是拿了颗从神庙里偷出的丹药打发了他们，让他们发下了此生不再靠近神庙的毒誓，三人不断向南，远离这极寒之地。 叶轻眉不断想象着来到人世间将会发生的故事，唇角不觉向上翘起，在这极寒之地呆了四年多，终于有机会去看看人间繁华了。 她的余光瞟到那个自称大魏镇抚司双营指挥使的肖恩正偷偷看着自己，赶忙收敛了笑容，变得一本正经。 “看什么看，再看眼珠子就要没了哦。” 肖恩吓得一哆嗦，脖子缩进领口，不再说话。 而另一侧苦荷则翻看着自己珍而重之藏在怀里的书，脸上是难明的笑意。 叶轻眉又向北看，雪在无穷的黑色白天里落下，只有低吟的风声推动着雪花，昭示着自己的存在。 她突然心中一动，一个难以抹除的想法涌上来。 他也太可怜了。 极北之地，神庙。 身着黑衣的少年呆呆望着纷纷扬扬的大雪，他总感觉自己似乎缺失了那么一小块，尽管全身上下都完好无损，但眼前总会出现一个小女孩的身影。 可自己明明不该有这般感情。 那个小女孩是什么时候在自己身上留下烙印的呢？ 她像一道光芒般，突然就出现在了这冰冷的神庙中。 她一点点长大，自己也逐渐习惯了照顾她的生活起居。 她贪睡，不爱吃饭，下雪天不喜欢穿厚衣服，还总喜欢趴在自己的肩膀上四处巡视。 可她现在突然消失了，就像她来的时候那样。 全世界的风雪在此刻似乎都落到了黑衣少年的身上，可他却浑然不觉，只是沉默地注目着远方。 不知过了多久，他的视野里突然出现一个小小的白色身影，一脚深一脚浅，蹒跚地冒着风雪向神庙走近。 这里是北极，也常常会有不长眼的狐狸兔子前来觅食，但无一例外都被神庙的守卫当成了食品贮藏。 眼看那个身影已经走到了跟前，少年站起身，警惕地举起双手，而那个身影却突然抖动了一下，头上身上的雪窸窸窣窣地落下，露出了被冻得通红的鼻子和脸颊。 小女孩仰起头看着他，伸出了小小的双手，展开了一个大大的笑脸。 “和我一起走吧。” “对了，还没有给你起名字呢。” “嗯…就叫你五竹吧。” 黑衣少年弯下腰来，自诞生以来便井然有序的大脑一片混沌，良久之后他才艰涩地开口，问出了一个本未被记录在程序里的问题。 “你…你是谁？” “哎，你终于说话了呀！”小女孩露出狡黠的笑容，“我嘛，我是小仙女呀。” 少年古井无波的脸上破天荒地露出了疑惑的神色，小女孩却已经灵巧地爬上了他的背部，抱住了他的脖子。 “难得回来一次，不带点东西走就太可惜了。” “小竹竹，姐姐带你去抢劫！” 那天，神庙外的风雪似乎停了半刻，一个黑衣少年拎着一个巨大的箱子，背着一个小女孩，在千年未曾变过的雪地里，踏出了一串串通向广阔世界的脚印。 二东夷城地处北魏边境，因为海路陆路发达，往来旅人商客不断，倒也称得上繁华。 这天，东夷城来了一对旅人，走在前面的是个穿着莹白色纱衣的小姑娘，约莫七八岁的样子，手上拿着串糖葫芦，在大街上新奇地东张西望。 而时刻站在她身后的则是一个穿着黑色劲装的少年，大概是眼睛有些问题，系着块薄薄的纱布，脸上看不出丝毫表情。 这是常见的大户人家出门的配置，一个小千金再加上一个大高手，奇怪的是，这姑娘的岁数也太小了些，而这高手，看上去也不怎么高。 小姑娘跑到一家胭脂铺前，试了几款，却因为不得要领，把脸颊涂得一块深一块浅。 她转过头来问身后的少年：“小竹竹，你看我好看吗？” 被称作小竹竹的少年半晌没有说话，许久才从牙缝里挤出一句：“涂之前是好看的。” “涂之后呢？” “像猴屁股。” 迎客的小厮听了这话，差点笑出声来，又连忙收敛了笑意，一本正经道。 “我家这胭脂，是采集了上好的玫瑰花瓣，用干净的石臼慢慢地把花瓣舂成厚浆后，用细纱过滤取汁，再把当年新缫就的蚕丝剪成胭脂缸口大小，放到花汁中浸泡，等完全浸透取出晒干，才做成的。” 到底是不是这样制成的尚且不知，但往常这样一番话，便能把那些未经世事的姑娘们哄住，轻而易举掏空她们的荷包。 没想到眼前的小姑娘并未动心，只是心不在焉地回了一句“哦”。 小厮仍不死心，继续说道。 “这样的一盒胭脂，小的自作主张，只卖您二两银子，简直是物超所值。” 小姑娘的眼睛突然一亮，“二两银？” 小厮感觉自己费的口舌终于得到了回报，白花花的银子仿佛正对着自己招手，刚准备去拿两盒胭脂来，转过头时那个小姑娘却已经不见了踪影。 在离胭脂铺子不远的槐树下，身着莹白色纱衣的小姑娘双手抱胸，踱着步对着身旁的少年老气横秋地说。 “小竹竹啊，你知道这东夷城最多的是什么吗？” “人？”黑衣少年有些不确定。 “这么笨怎么做我叶轻眉的帮手？”小姑娘摇了摇头，看向熙熙攘攘的街道，轻轻开口。 “是商机啊。” 东夷城的正中央伫立着一座巍峨的城主府，而离城主府不远的地方有一棵大青树。 晌午的太阳正烈，叶轻眉和五竹在城里晃悠了大半天，终于将这座城逛了一小半，五竹自然是不会乏的，可七八岁的小姑娘正是容易累的年纪，便索性停在大青树下纳凉。 青树庇护着的不止这两个外来客，还有一个拿着木棍的小孩。 叶轻眉好奇地在这个同龄人的身旁蹲下：“喂，小孩儿，你在干什么？” “数蚂蚁。”小孩头也没抬，依旧划着手上的木棍。 “这么多蚂蚁怎么数得过来。”叶轻眉撇了撇嘴。 “两百三十七只。”五竹突然开了口。 这下惊讶的便不止叶轻眉一个人了，那个小孩也抬起了头，看向了这个依旧面无表情的少年。 叶轻眉这才有机会看清这孩子的脸，两个眼睛隔得很远，并不挺拔的鼻子上有着好几片黑渍，鼻子下还挂着两串清水鼻涕，总之看上去颇有些鲁钝。 “小孩儿，你叫什么？”叶轻眉问。 “他们都叫我白痴。”这孩子回答了叶轻眉的问题，却未曾停下，而是看向了五竹。 “我本想把这群蚂蚁全部杀掉，这样蚂蚁的个数便是零只，你是怎么看出来的？” 叶轻眉这才注意到青树下已经横陈了不少蚂蚁的尸体，而罪魁祸首正是那孩子手中的木棍，一时间竟不知说什么才好。 五竹迎着那孩子的目光，依旧是面无表情，许久之后，大概是注意到了旁边的小姑娘在不断朝自己使眼色，才开了口。 “你别再杀蚂蚁了，我可以教你。” 三白痴自然不可能姓白名痴，前世看过不少苦情戏的叶轻眉没有拒绝孩子向他们发出的邀约，而是与他并肩走在回家的路上，也轻易地便从他的诉说中拼凑出了一出苦情戏。 母亲是城主府中的丫鬟，在与城主一夜风流后生下了一个智力有缺陷的孩子，孩子自小在众人的白眼中长大，没有玩伴，没有人关心，连一个说话的人也没有，所以只能蹲在那棵大青树下数蚂蚁。 他在想什么呢？叶轻眉看着孩子沉默的背影想。 可两世为人的记忆并未能给她答案。 孩子的住所在城主府侧门的一个低矮小屋，以前被用作堆放杂物，而现在则用来安置城主府里这个杂物般的闲人。 叶轻眉稍稍顿了顿，叫住了那个正准备开门的孩童。 “我该怎么称呼你？”她看着他的眼睛。 “你也叫我白痴就行。”孩子抹了把鼻涕，面色平静。 “不行，这样也太不尊重人了。”叶轻眉斩钉截铁地说，说来也怪，她现在明明是七八岁的模样，说出的话却意外有着让人无法抗拒的力量。 “什么叫尊重？”孩子问。 “就是别人都不会嘲笑你，而你说的话所有的人都会认真听。” 依旧流着鼻涕的小孩儿仔细思索了一会儿，也不知是否能理解这句话的意思，好一会儿才开了口。 “叫我阿蛮吧，我娘亲死之前总是这样叫我。” “阿蛮。”叶轻眉伸出双手，“以后我们就是朋友了。” 阿蛮愣了一下，手掌微微颤抖，不知该拿起还是放下。 “阿蛮，以后我们就是朋友了。”一路上都保持着沉默的五竹突然艰涩地开了口，伸出了双手。 后世的人一定未曾想过，即便是让人闻风丧胆的四顾剑的脸上，也曾出现过这般灿烂的笑容。 那年的夏天来得特别晚，初到东夷的叶轻眉和五竹窝在阿蛮的小屋里，不算溽热，倒也还算自在。 因为是杂物房改建的原因，阿蛮的屋子还带着一个小小的院子，院子里种着棵不知名的树，露水从叶片滑落，落在树下的大肚子水缸里，泛起一阵阵涟漪，地上的砖石缝因为疏于打理，长满了青苔，旁边几丛野花还没开，但叶子熙熙攘攘的挤在一起，晃出了几片换了几代却仍似当年的绿。 五竹履行了他的诺言，开始在院子里教阿蛮数蚂蚁，准确地来说应该是习武，这个从小命运坎坷的孩子在武道上的天份上倒是意外的高，叶轻眉从自己的大箱子里翻了好久，才找出一本破破烂烂的秘籍。 “喏，你以后就练这个。” 那本看上去平平无奇的烂书上写着四个遒劲的大字—四顾剑诀。 而与院子一门之隔的房间里，叶轻眉则在暗自打着小算盘。 这个世界上什么最重要？ 武功？谁能打得过门外的小竹竹啊喂。 权力？就算是皇帝在箱子里的那样东西面前，也只有发抖的份吧。 思来想去，也只有钱了。 她用笔在面前的宣纸上缓缓下笔。 赫然是四个王字。 紧接着她又面色严肃地补上了好几划。 “玩玻璃球”。 四曾经有一艘欧洲腓尼基人的商船，满载着晶体矿物“天然苏打”，航行在地中海沿岸的贝鲁斯河上。由于海水落潮，商船搁浅了，于是船员们纷纷登上沙滩。有的船员还抬来大锅，搬来木柴，并用几块“天然苏打”作为大锅的支架，在沙滩上做起饭来。 船员们吃完饭，潮水开始上涨了。他们正准备收拾一下登船继续航行时，突然有人高喊：“大家快来看啊，锅下面的沙地上有一些晶莹明亮、闪闪发光的东西！” 船员们把这些闪烁光芒的东西，带到船上仔细研究起来。他们发现，这些亮晶晶的东西上粘有一些石英砂和融化的天然苏打。原来，这些闪光的东西，是他们做饭时用来做锅的支架的天然苏打，在火焰的作用下，与沙滩上的石英砂发生化学反应而产生的物质，这就是最早的玻璃，后来腓尼基人把石英砂和天然苏打和在一起，然后用一种特制的炉子熔化，制成玻璃球，使腓尼基人发了一笔大财。 前世身为工科女博士的叶轻眉对这个故事并不陌生，只是而今被困在小女孩的躯体里，又被时代的枷锁牢牢禁锢，想要像以前那般试验自然颇为艰难，所幸东夷城人来客往，那些必备的原材料并不稀缺。 所以在阿蛮的小屋第十一次发出爆炸声后，五竹和阿蛮冲进屋子，只发现桌子上摆着一颗闪闪发光的透明物体。 “我知道这是什么。”阿蛮拿起桌上的物件，“我在书上看过，高僧得道后会留下一颗舍利，小姐应该是坐化了。” 还没说完，他的头上就被狠狠赏了一记板栗。 “坐化你个头啊。”浑身黑灰的叶轻眉从门后跑了出来，抓住那颗闪闪发光的玻璃珠，“这可是白花花的银子啊。” “连我这个白痴都知道这不是银子，小姐肯定是被炸傻了。”阿蛮说。 回应他的是五竹的一个脑瓜崩。 “不准这样说小姐。” 城主府角落传来的异响或多或少引起了一些有心人的注意。 这一日，几个蛮横的家丁闯进了阿蛮的小院，为首的是一个浓妆艳抹的肥胖妇人，居高临下地环顾四周后，从鼻子里发出了一声轻哼。 “这杂物院，倒是被收拾得有模有样。” 阿蛮听到声响，赶忙从房间里走出来，叶轻眉与五竹去了集市，家中便只有他一人。 他未曾说话，只是站在那，挡住了房门。 那妇人并未用正眼瞧他，嘴上却不住的冷嘲热讽。 “哟，我们城主府真是出了个人物，未经许可就留外人做客，不知道的还以为在谋划什么大动作呢。” 她一挥手，身上的赘肉仿佛波浪翻涌般层层叠叠，“给我把东西都扔出去。” 几个家丁迅速地靠近，但阿蛮却牢牢把住了房门，任凭如何被拉扯都没有让出半步。 毕竟也算是城主的骨肉，那几个家丁也未敢做出再出格的事，而是齐齐望向了肥胖妇人。 那肥胖妇人往地上啐了一口：“一群没用的东西，给老娘让开。” 她庞大的身影仿佛能吞没阿蛮瘦小的身体，只听“啪”的一声，阿蛮的右脸颊便已高高肿起，他依旧没有说话，只是抬头盯着肥胖妇人，仿佛在盯着大青树下的一只蚂蚁。 肥胖妇人似乎被这眼神弄得有些不舒服，又抡起了厚重仿若蒲扇般的巴掌，“小畜生，让你挡路。” 她的巴掌还没落下，背后却突然传来一阵凉意，紧接着是一声软软的女童声音。 “你说谁是小畜生？” 五肥胖妇人惊恐地回头，却发现一个只有半人高的小姑娘拿着一柄闪烁着寒芒的匕首抵在自己的后心，因为够不到，只能微微踮着脚。 这样的场景自然是有些奇怪，甚至有些可笑，可她却丝毫笑不出来，因为院子里还有一个人，一个黑衣青年不知何时已经放倒了所有的家丁，拎小鸡一般地把他们整整齐齐堆叠在一起。 肥胖妇人刚想发声，背后的小姑娘又开了口。 “不要大喊大叫哦，要不然匕首可是不长眼的。” 小姑娘轻轻旋着匕首，尖利的刀锋轻易地划破了春夏轻薄的衣衫，抵在肥胖妇人的赘肉上，让她感觉到隐约的刺痛与凉意。 “如果我没有记错的话，你刚才骂他是小畜生对吧？”小姑娘轻轻说，“如果阿蛮是小畜生的话，那你们的城主大人就是大畜生咯？” 她展开一个灿烂的笑脸，回头望了望那些呻吟着的家丁，又对着眼前的肥胖妇人说道。 “那你们这些城主府的下人，岂不是畜生不如？” 胖妇人心道好个牙尖嘴利的丫头，但话到了嘴边却变成了：“城主府不留外人过夜，本来就是这小…他犯了忌讳。” “哦？这里原来是城主府啊？我看这里年久失修，冬凉夏暖，还以为是放杂物的地方呢？莫非，你们城主府里，是专门设计来放垃圾的？” 胖妇人被气得微微发抖，却不好发作，只得硬着头皮说道：“这是夫人的命令，还请您不要为难下人。” “没意思。”叶轻眉放下了匕首，又轻轻叹了一声，“我们自然会搬走的，可你要是再过来骚扰，这身肉可就剩不下几斤了。” 胖妇人如蒙大赦，和地上忙不迭爬起的家丁，屁滚尿流般地跑出了小院。 看到小院终于恢复了清净，叶轻眉这才轻轻拍了拍自己的心口，转身看向站在后面的五竹。 “小竹竹，姐姐刚才表现好吗？” “尚可。” 小姑娘听到这句评价，满意地点了点头，又苦恼地轻跳了几步，发出一声叹息。 “我太矮了。” 她又走到阿蛮跟前，用手轻轻碰了一下他脸颊上的红肿，恨铁不成钢地说道。 “你怎么就不知道躲一躲呢，东西扔就扔了，又没有什么值钱的物件，干嘛要挨打？” 阿蛮低着头，抓着衣角的拳头微微攥起：“我不想让她碰你们的东西。” 叶轻眉轻不可闻的叹了口气，又拍了拍阿蛮的肩膀：“你是个高手。” “可我什么都没做成。”阿蛮疑惑地挠了挠头。 “但你在我心中永远是个高手。”叶轻眉说。 入夏的时候，叶轻眉和五竹搬离了城主府的小院，在东夷城的某地租了处宅子。 叶轻眉自然是邀请过阿蛮来住，可这执拗孩子只是不断摇头，这事也就被一笔带过了。 所幸宅子离城主府也就几里的路程，倒也方便往来。 那年夏天，叶轻眉的第一家玻璃铺顺利在东夷城内开了起来，面对这些新奇玩意，往来的商客很少有不心动的，即便说不上是日进斗金，半斗总是有的。 叶家玻璃铺越做越大，伙计越招越多，又在往来东夷城的商人里找了几个当掌柜，到了最后，大小事务，也都不怎么需要叶轻眉打理。 夏天快结束时的一个晚上，叶轻眉坐在宅院内的藤椅上，轻轻摇着扇子，看着星星不知在想些什么。 吱呀。 五竹轻轻推开院门。 叶轻眉鼻子嗅了嗅，接着又微微皱起。 “小竹竹，又出什么事了？” “有几个宵小闯进了库房，伤了几个伙计。”五竹如实回答。 “以后杀心不要这么重嘛，好不容易过上了这样的生活。”叶轻眉叹气。 五竹转头看说话的小姑娘，漫天的星辰倒映在她的眼眸里，在流萤的微光映衬显得愈发明亮。 一声“滋哇”声适时响起，又引起了周边树上的一阵附和。 那是那年夏天最清澈的蝉鸣。 六叶轻眉来到东夷城的第五年，城里突然发了水灾，东夷靠海，往日的衣食父母此时便成为了择人而噬的野兽，无情地破坏着所有挡在面前的障碍。 等到大水平息，商道，农田便已经被糟蹋得不成样子。 叶家的生意自然也受了影响。 玻璃这东西，是平民眼里的奢华物件，富人眼中的新鲜玩物，到了大家都收紧裤带的时候，自然不会有人愿意多往上面掷钱。 富人家也有下人要养，粮食的涨价是实打实的，大部分人都吃不上饭也是实打实的。 叶家凭着这几年的丰厚积蓄，倒没过上下人也吃不上饭的日子，甚至还能余下些钱来，开粥铺赈济街上的灾民。 “不要挤，不要挤，一个个来，都有都有。” 出声的正是已经出落的亭亭玉立的叶轻眉，身为叶家大掌柜的她并未像寻常大户人家的小姐般囿于深闺，而是常常抛头露面。 东夷城都知道叶家商铺有个笑起来很好看的女掌柜，很多人都猜测她是某个巨贾的女儿，只是提前来熟悉一下家族的生意，但只有那么一小部分人才知道，这个女掌柜，几乎是白手起家，在几年内便打造出了叶家这样一个庞然大物。 “没了没了。” 赈济的粥很快就被街上的灾民一抢而空，叶轻眉抹了抹额头上的汗，转身对一直站在身后的五竹说。 “小竹竹，你知道我们现在最缺的是什么吗？” “粥。”五竹诚实地回答。 “是钱啊，钱啊。”叶轻眉有些哭笑不得，“玻璃和肥皂生意能赚的钱终究有限，还是得想想别的出路。” 她正在打着小算盘，却突然在人群中看到了一个熟悉的身影。 阿蛮。 自从叶家的商铺开起来之后，阿蛮来的次数便肉眼可见的少了许多，到了最后，只有在武道一途遇到困难的时候，才会前来向五竹讨教。 他的剑道进展颇快，可却与五竹不尽相同，倘若说五竹的剑意是随心所欲的清风，阿蛮的剑意则更像一击致命的凶兽。 叶轻眉知道这个已经快和五竹一样高的少年过得并不好，尽管是十五六岁的年纪，可在他身上却看不出任何少年人的生气，瘦得和麻杆似的身材，再加上呆滞的面容，整个人看上去颇为古怪。 他的脸上总是会添上几处新伤，想也不用想，必然是城主府的那些人打的。 这些年来，叶轻眉想过各种办法，包括偷偷给他塞钱，劝他从城主府搬出来，可没一个奏效的，塞的钱总是被他又偷偷放了回来，而直至现在，阿蛮还住在城主府角落的那个小院子里。 “阿蛮！”叶轻眉从人群中挤过，叫住了那个瘦高的少年，“好久不见了。” 阿蛮却只是木讷地点了点头，他的额头上有一处伤痕，像是被人用指甲抓过。 “你吃饭了吗，一起去吃饭吧。”叶轻眉不由分说地抓住了他的手，把他拉进了叶家宅邸。 这少年大概的确是饿得狠了，饭添了一次又一次，叶轻眉的嘴巴也越张越大。 “我吃饱了。”阿蛮终于放下了碗筷，站了起来。 叶轻眉这才发现他腿上似乎也有伤，刚才还没觉得，现在凑近一看，确实是有些不灵便。 “你又被打了吗？”叶轻眉问他。 阿蛮没有说话。 “为什么不打回去？”叶轻眉愤愤伸出拳头，“他们打你，你也打他们。” 阿蛮抬起头，他的眼神有着些说不出的复杂意味，却让叶轻眉想起了第一次见他的场景，那天，这个孩子也是用着这样的眼神，在大青树下数着蚂蚁。 “那里是我的家。”阿蛮转身向外走，“谢谢小姐款待。” “等等。”叶轻眉叫住了阿蛮，拿出了一个包裹，“这些给你回去吃。” 这次他没有推脱。 这年元月，城主府突然起了一场火，火光在深夜里显得格外显眼。 叶轻眉听到外面嘈杂的人声，站到窗前望去，旋转而上的黑烟仿佛是一场大事件的预兆。 “我去看看。”五竹不知何时站到了她的身边。 叶轻眉点了点头，没有说话。 不远处的城主府偏院。 一个瘦高的少年正站在一个角落，愣愣望着起火的院子，和一旁大呼小叫来救火的家丁。 少年转过身来，从旁边的树下拾起一根树枝。 “快去救火啊，你拿着根树枝准备干啥呢？”一个提着水桶的家丁没好气地冲少年吼了一句，接着又匆匆跑开。 他没注意到的是少年空洞得可怕的眼睛和仿佛梦呓般的自言自语。 “去杀人。” 七很多人都觉得阿蛮是个傻子。 但不包括费介。 那年，碰巧路过东夷城的费介被城主请来医治府上的一个傻子，尽管说是城主的远房亲戚，但所有人都知道，那是这座城市的掌权者，与府内一个丫鬟生下的私生子。 费介只是和那时尚且年幼的阿蛮说了几句话，便匆匆离去，只留下了一句话。 “此子无药可医。” 于是阿蛮便在所有人的歧视下长大了，也成了那些视他作眼中钉的人不太舒服的心病。 可一个傻子能做什么呢？偌大的城主府还容不下一个傻子吗？ 更何况让他在眼皮子底下长大，连城主府的下人也能去踩上两脚，不是更加有趣吗？ 所以当阿蛮拿着树枝，踏着尸体走到城主夫人面前时。 那个雍容华贵的妇人顿时感到了一种久违的失控感，失声叫了出来。 “你，你想要干什么？” 阿蛮抬起头来，面色平静，完全不像刚刚用树枝戳穿了两个八品高手喉咙的样子。 “为什么，你们不能让我好好活着呢？” “你本来就不应该出生。”城主夫人尖利的声音划过夜空，“那个不要脸的贱人，不就是想一步登天吗，做梦！” “你不该出生。”阿蛮自嘲般地笑了笑，“这句话我娘亲也对我说过。” “可生我之前，你们这些人，有问过我的意愿吗？”阿蛮看向城主夫人的眼睛，“我娘从来没有想靠我一步登天，一切都只是一个意外，至于为什么会有这个意外，你为什么不去问问你那道貌岸然的夫君呢？” “自从我生下来，所有人都想我死，甚至包括我的娘亲，她本来是普通人家女儿，进了城主府当了婢女，只想过着衣食无忧的日子。” “可有一天，你们口中的城主大人却突然闯进了她的房间，又过了十个月，我出生了。” “自打我记事起，我娘就经常打我，她很奇怪，总是在打完我之后抱着我痛哭，嘴里絮絮叨叨，可我却再也不愿意多说话。” “城主府发给我娘的银子，还没到手上就只剩了几枚铜钱，我娘便只好替人缝衣服，她本来只是照顾起居的丫鬟，不常做这些活，手上被扎得都是针孔，可她还是坚持下来了。” “有一天我娘没有再回来，所有人都告诉我她是跳井死了，他们都以为我还小，我不懂事，我是个傻子，可他们都不知道，那天我就在那口井旁的一棵树上，看着我娘被推进了井底。” “我不敢出声，因为我怕我出声了，也会被推进井里，我甚至有些如释重负，她太苦了，终于可以好好休息了，这些年来我一直忍气吞声，就是想好好活下去。” “可是，你们为什么，要把我最后的倚靠也烧了呢？” 阿蛮沉默了一会儿，又继续说道。 “还好你们以为我是一个傻子。” 那天费介看着蹲在树下的年幼孩童，只问了一句话。 “孩子，你想要什么？” 那个孩子用树枝划着地面，好像在画一幅地图，头也没有抬。 “我想活着。” 这注定是会被载入东夷城历史的一天，这天晚上，城主府的几乎所有嫡系，都被一个少年拿着一根树枝杀了个一干二净。 这场屠杀精准得可怕，没有丝毫拖泥带水，甚至没有因为场地的复杂而产生片刻停顿，仿佛提前预演过千万遍。 而在这个过程中，所有人的注意力都在那场火上，直到一个想要趁火打劫的地痞偷偷闯入内院，才发现院里已经没有了活人。 当然，也并非没有人知道那天晚上到底发生了什么。 在故事的尾声，阿蛮丢下了手上那根沾满了鲜血的木棍，对站立在墙头上的黑衣青年轻轻说道。 “谢谢你没有出手。” 紧接着他又向那青年行了一个大礼，说来也怪，这竟是他这辈子第一次弯腰。 “请代我和小姐说一声。” “东西很好吃，我很感激。” “只要我还在东夷城，叶家就不会有倒下的一天。” “对了，还有一句。” “阿蛮已经死了，世间只剩四顾剑。” 东夷城卷完。 八儋州港在庆国的东面，因为靠着大海，而南方的几个港口又还未开始建设，所以承担着国家的海路贸易重任，人来人往，颇为热闹。 这两年位处北魏边境的东夷城换了主人，新的秩序被迅速从水灾后满目疮痍的城市上建立了起来，与秩序相伴的则是日益上涨的关税与严密的监控，东夷城中的一举一动，似乎都落到了一双无形的眼里。往来的散商港脚们见能捞到的油水日益稀薄，目光便转投向了地处南方，市场尚未规范化的庆国。 这天，港口来了一艘客船，船上陆陆续续下来了几个提着包裹的旅人，一副商人打扮，对于繁华的儋州港而言，这倒是不稀奇，稀奇的是走在最后的那对男女，走在前面的是一个穿着月白色长裙的少女，走在后面的则是一个拎着巨大黑色箱子的黑衣青年。 少女晃晃悠悠地从船上跳下，仿佛喝醉了酒一般，又深深地吸了一口略带海腥气的空气，才缓了过来，转头对身后的青年抱怨。 “这船都快把我的眼珠子晃出来了。” “我倒是没什么感觉。”青年面无表情。 “这一点也不公平。”少女愤愤地挥了挥拳头，紧接着，她的注意力又被人来人往的港口所吸引，雀跃道，“这南方的景色，就是和北方不一样。” 这一对男女正是来自东夷城的叶轻眉和五竹。 大概是因为自叶家的生意越做越大后，觊觎的宵小源源不绝，五竹的剑意也越来越凌厉，抑或是因为这个不安分的小姑娘已经厌倦了一成不变的生活，早在一个月前，叶轻眉就变卖了东夷城的大部分产业，然后登上了驶往庆国的客船。 而目的地，便是这同样位于海岸线上的儋州港。 叶轻眉并未在海边多逗留，而是急吼吼地扎进了进城的人群中，尽管买的是上等的客票，可这几天在船上的吃食，却是不尽如人意。 新鲜瓜果自然是难以储存，而精心腌制的鱼干腊肉，果脯蜜饯，刚入口时倒是惊艳，连吃好几天也难免倒胃口，若不是偶尔能在海上捞些水藻鲜鱼改善下伙食，只怕早就要掉几个膘来。 五竹倒是无碍，叶轻眉在航行中途便受不了这样的罪，开始谋划着造一个冰箱出来，但想到这个世界的科技并不发达，一切都要从头开始，只得悻悻作罢，成天长吁短叹。 儋州港内最大的酒楼唤做月明楼。 这月明楼的主厨，听说曾是某个小国御膳房的掌勺，当年北魏征伐四方，山河破碎，便只能背井离乡，不知怎么，就到了儋州港，但手艺终究是骗不了人，一眼便被当时月明楼的掌柜看中，而本来门可罗雀的小酒楼也借势咸鱼翻身，一路水涨船高，一跃成了城内最顶级的馆子。 叶轻眉刚走进月明楼，就被里面的阵仗吓了一跳，大堂里坐满了人，就连旁边的走道，也站满了等待的食客。 叶轻眉费力地挤上二楼，因为要多付二两的雅座钱，人却是少了些，但满眼也寻不着空位。 她刚想再往三楼走，却被小二给拦住了。 “这位小姐，实在不好意思，三楼只接待贵客。” 叶轻眉奇道：“你们这酒楼倒是有意思，上门的钱也不赚，该收多少钱收便是了，我又不会少你们的。” 说罢她晃了晃五竹递过来的荷包，包里亮闪闪的却不是银子，而是一片片金叶子。 那小二见状也是动容，却依旧陪笑道：“这三楼乃是大师傅亲自掌勺，所以一次只能接待一桌，倘若怠慢了客人，那也是我们担待不起的，您若是想来，我自做主张替您安排个时间，保证让您满意。” 叶轻眉刚想开口，楼上却悠悠传来一个温润的声音。 “让这位姑娘上来吧，坐在我们这桌便是。” 九月明楼三楼的格局，自然是与下面二层不同的。 因为地势极高，从镂空的雕花窗桕向外望去，便能一眼看尽整个儋州港的全景，窗户周围的墙壁上挂着几幅字画，也未必能瞧出个好来，只是落款极多，想必是价格不菲，四方的角落里都设着半人高的汝窑花囊，没插着花，却不断有花香从瓶口传出。 三楼正中央是一张紫檀木桌子，桌上已经摆着几道精美的小菜，而桌旁的官帽椅上，坐着三个衣着华贵的年轻人。 三人虽分散坐着，却隐隐有以中间那位为尊的意思，那人生得颇为好看，眉锋似刀，凤眼狭长，偏偏却有着一丝不怒自威的气质，此刻正看着拾级而上的叶轻眉，笑容温醇。 正是刚才出声邀请的那人。 叶轻眉倒是没有多客气，走到桌前便落了座，身后的五竹拎着巨大的黑箱子，并未落座，只是站在叶轻眉身后。 一旁的两人互相对视一眼，面露奇色，中间的那位公子哥儿却是笑容更盛。 先开口的却是旁边坐着的那一位。 “我家公子今日出游，正巧在这月明楼上落座，看到小姐被阻拦，便出声邀请，还望小姐不要见怪。” 眼前这人约莫二十岁年纪，生得倒是唇红齿白，像是大户人家的少爷，只是声音却十分细软，颇有一股说不出的阴柔气。 换做是别人，恐怕要多看他几眼，但两世为人的叶轻眉却并未在意，只是摆摆手：“当然不见怪，若不是你家公子，我恐怕就要饿死了。” 她又顿了顿，似乎不知该在这种场合说些什么，本来这样的场景，大多发生在武侠故事里，恶少在酒楼调戏从家里跑出来的小姐，再被从天而降的大侠狠狠收拾一顿。 可现在这些人倒是客气得很，这不是写在书中的故事。 她眼珠一转：“我叫叶轻眉，这位是我的朋友五竹。” 开口的还是刚才那人，“我家公子姓李，我姓陈，名五常，叫我五常就好。” 叶轻眉心想你家公子莫不是哑巴，怎么还要人代为自我介绍？况且只介绍姓氏，难不成以后唤他作小李子？当然倘若只论颜值，倒也不是不合适。 她的幽思很快就被桌旁另一个年轻人的言语打断。 “我姓范，叫范建。” “咳咳。”叶轻眉差点没被自己的口水呛到，“不好意思，嗓子有些干。” 那长相平平的年轻人一脸自豪：“我爹娘自小便希望我长大后可以建功立业，所以便给我起了这个名字。” “敢问令尊名讳？” “我爷爷希望天下长治久安，太平一统，所以我父亲叫范统。” 叶轻眉静默无语，良久后才朝他竖起拇指：“好名字。” 月明楼上菜很快，大概是只用招待一桌的原因， 小二很快就陆陆续续地端上了几道菜色精美的佳肴，香味一直往人鼻子里钻。 叶轻眉动了几筷，就没有再往嘴里送东西，好吃是不假，可也没什么新意。 那坐在中间的青年这时终于开了口。 “倘若菜色不合姑娘的口味，姑娘想吃什么，尽管点便是，今天的这桌菜，便记在我的账上。” 从北方来的小姑娘抬头看他一眼，突然展颜一笑，她本身就生得极美，这几年更是出落得亭亭玉立，这一笑，便晃得坐着的那几位有些恍惚。 “小女子谢过这位公子，初到此地，思乡情切，只想点些故乡的吃食。” 姓李的公子笑道：“看姑娘衣着，应该是来自北方，月明楼这位厨子，曾周游过列国，对他而言，其他菜式倒也不是难事，姑娘还请不要拘谨，便是他做不出的，本公子也能想出办法。” 叶轻眉脸上突然露出一丝狡黠，像一只小小的狐狸：“这可是你说的，那好。” “小二，给我来三块吮指原味鸡，两块新奥尔良烤翅，一份薯条，一个香辣鸡腿堡，一杯可乐。” 十要说这月明楼的大师傅，确实是颇有些手段仅凭叶轻眉的叙述，便将这些菜色还原出了五分，虽说原味鸡只是普通的炸制过，烤翅不过是刷过蜂蜜炙烤的普通鸡翼，汉堡的面包是由两个发面馒头代替的，但薯条倒是粗细均匀，颇为酥脆。 可乐自然是无法做出的，取而代之的是一种以沙蜜和糈米作为原料的饮料，被唤作百花春，因为发酵过，倒也有些气泡。 总而言之，倒是来到这世界后第一次尝到属于过去的味道。 那三个青年，倒是吃的啧啧称奇，一直没停过筷子。 名叫范建的年轻人油光满面，边啃着鸡腿，边含糊不清地对叶轻眉说：“姑娘家乡的菜色果然名不虚传，有机会我一定要前去拜访。” 叶轻眉撤了撇嘴，叹了口气：“一看你就没吃过什么好东西，这些吃的还是差点意思，要是给我点时间，倒说不定能把味道还原个七七八姓李的公子闻言一笑：“叶姑娘倘若有心于厨艺之道，可以来我庆国京都，必定会大受欢迎。” 还没等叶轻眉开口，范建就又接过了话茬：“没错，到时候一定要取个响当当的名字。” 思绪已经飘了十万八千里的小姑娘撑着下巴，突然起了逗逗他们的念头，眼珠乱转：“酒楼这行当，最需要的就是客人的肯定，而德行，是做任何事都需要的，我家乡的菜品，又是以鸡肉为主，那不如就叫…” “肯德鸡！” 从酒楼出来，已经快到未时。 大概是因为年龄相仿，叶轻眉又丝毫没有大姑娘家的羞涩拘谨，几人倒是相谈甚欢。 那三人并未多透露自己的身份，但并不难推断出，他们是从庆国京都出来游历的世家子弟，那姓李的身份最高，只不过眉头间总是有一股忧色，尽管如此，行为处事却都让人挑不出半点毛病。 名叫范建的，基本一直在吃，倒是瞧不出什么心眼。 最让人在意的是那名叫陈五常的年轻人，席间虽然一直笑看，却隐隐与人有一种隔阂感，即便是在和另外两人谈笑的时候，叶轻眉似乎能捕捉到那一点隐藏得极深的怯懦这种感觉该怎么形容呢？ 就像是另外两人在扶看他，他却控制不住自己向下坠。 而等待他的，是无底的深渊叶轻眉在东夷城也曾见过那样的人。 庆国三人组，吃过饭后便走向了码头，说来也巧，这竟是他们在澹州港逗留的最后一天。 李姓公子站在码头前，看着不断起伏的海浪，洗沐着澹州这处格外清明的海风，不知在想些什么，范建则与他并看肩，转头一看，竟是在用竹签剔牙。 名叫陈五常的白净青年则是站在离他们二人一臂远的身后，怔怔出神。 叶轻眉偷偷跑到陈五常的身后，轻轻把他往前推了推：“这么好的风景，站这么靠后做什么，难道是怕掉下去？ 她又指着前面的两人：“放心，尽管我不会游泳，但他们两个一定会救你的。” 陈五常先是一愣，又轻轻柔柔地说：“谢谢叶小姐范建听到这话后回头龇牙咧嘴，做了个狗刨的姿势。 李姓公子则微微一笑，向叶轻眉抱了抱拳。 那日澹州港的海风格外温柔，吹的几个年轻人倒是有些倦，几个人站在码头上，相接的天海把视野染出一片蓝。 李公子转头看向这个与自己并肩的少女：“叶姑娘当真不与我们一起回京都？” “不去，我这才刚到庆国，等我玩够了，再去京都找你们。”叶轻眉戳了戳一直没说话的五竹，是吧，小竹竹。” 小姐去哪儿，我就去哪儿。”五竹回答范建插嘴：“到时候别忘了带上你硏制岀来的烤鸡。” 几人哈哈大笑，海浪一阵阵地拍击岸边，涛声逐渐淹没了离别时的叹息。 后会有期。 十一京都位于庆国北部腹地，不仅承担着国家的政治重任，也是这个国家最繁荣的经济中心。 偌大的城市被一条宽敞的天河大道分割成泾渭分明的两部分，往西是平民的住处，往东则是掌管这个国家权力的分散中心，当然，真正的核心，永远在北城的重重深宫中，不算华丽却异常厚实的宫墙包裹着皇宫，让整个皇宫看上去像一只身处篱墙的匍匐巨兽，冷眼看着这片天下的一举一动。 沿着城外宽阔的官道一直向前，便能来到京都的南城门，往来的入京的行人，必须在此接受京都守备的检查，才能走进这座繁华城市。 要说这京都守备，虽然辛苦一些，但勉强也能称得上是肥差，来来往往的商客不少，为了减少麻烦，有点眼力见的都会塞上几锭银子，收不收是一码事，可这油水，却是实打实的，因此，挤破头想混进守卫师谋一份差事的不在少数但对于京都守备叶重而言，今天并不是如意的一天。 在半个小时之前，他被一个穿着鹅黄色纱衣的小姑娘揍成了猪头事情的起因经过结果很简单，这天正是叶重当值，所以当他看到一个小姑娘和一个提着大黑箱的瞎子缓缓走进城门时，他很本能地就提出了开箱查看的要求。 没想到小姑娘和瞎子并不买他的帐，而是自顾自地向前走本着宁杀错，不放过精神的叶重，只得一把抓住了小姑娘的肩膀。 然后，人生信条从来都是好男不跟女斗的叶重就不幸卷入了一场实力相当不平衡，可以说是以卵击石的战斗。 更不幸的是，他是以卵击石的那个卵。 所以在此刻，一脸轻松的小姑娘看着四脚朝天躺在地上的他，笑嘻嘻地说出“年轻人，你的功夫不到家啊”的时候，他并没有反驳，只是异常憨屈地从牙缝里挤出了一句。 有种留下名字，我叔父会来收拾你们的。 小姑娘歪着头看了他一会儿，又指着自己的脸蛋说。 那你记好了哦，小姑奶奶的名字叫叶轻眉。” 距澹州港一别，已经整整两年。 在这两年间，叶家商会又以新的面貌迅速建立了起来，得益于澹州港得天独厚的地理优势，还衍生出船舶，货运等多条分支，一跃成为了这个小小的枢纽里影响最大的几家商会之一。 眼看着叶家枝繁叶茂，手下又招了几个还算靠得住的掌柜，叶轻眉便自然而然想起了那日在码头遇到的那三人，刚好生意也到了瓶颈，去京都这座王城看看，便被安排上了日程。 没想到出师不利，刚进京就碰上了一个愣头青，似乎还惹下了不小的麻烦。 五竹看了眼在地上四仰八叉的京都守备叶重面色严肃地说：“小姐，我们现在去哪儿？” 叶轻眉则是潇洒地转身，摆出了一个起跑的姿势：“当然是……跑了！” 得罪了京都的守备还不跑，你要等他缓过劲找人来把你抓进大牢啊？”一缕微风拂过叶轻眉的发梢，“小竹竹，我先走，你殿后。 这日，天河大道烟尘滚滚，无数人望看一个飞奔女子的背影，感叹着这真是天外飞仙。 而在城东的诚王府正殿。 三个年轻人正围聚在一起，中间的那位面带忧色，正是那日月明楼的李姓公子。 父王今日入宫，这京都，恐怕很快就不会太平了 “世子不必过多担心，这等大事，也并非我们可以左右的了的。”开口的正是陈五常。 “也罢，不说这些了。”诚王世子苦笑了一下，转头看向正在怔怔出神的另一个伙伴：“范兄，你在看什么？” “你们刚才有没有看到一个影子从王府前一闪而世子殿下与陈五常双双摇头。 范建抓着自己的脑袋百思不得其解。 “怪了，这大白天，莫非是见了鬼不成？”","link":"/2020/02/09/%E6%95%85%E4%BA%8B/"},{"title":"Web Site","text":"Some good practical websites. Hexo搭建教程 有道云 正版中国 iData 知识搜索 PDF转换工具(1) PDF转换工具(2) 论文检索 图片背景消除 在线小工具 界面更高级点的在线工具 小众软件 USZE 视频🐟 (视频解析下载) MSDN, 我告诉你 (Windows系列系统的镜像) 网易见外 搜图导航 (找素材) MathJax基本使用语法 Ellen7ions (OIer) 谢公子 (网络安全) Markdown 语法手册 Markdown 基本语法 沈宇 (该博客主题作者) Hexo 博客文章加密 Hexo使用指南 (官方) 通过aplayer插入音乐 Hexo 博客优化(1) Hexo 博客优化(2) MathJax使用方法 MathJax的基本使用语法 二维码生成美化 百度统计 (访客) Cmd Markdown 公式指导手册 Google 开源项目风格指南 rqy (OIer) dormantbs (OIer) 花 (OIer) M_sea (OIer) 正月点灯笼 (B站UP) 浅谈OI中的2 OEIS (整数数列线上大全) w3school 洛谷 (界面友好在线OJ) 洛谷日报 (知识分享) 北京大学公开课 医学微视 我要自学网 Stanford Oeasy 果壳 任意门 修改代码块字体颜色：E:\\QinMoMeak\\themes\\ayer\\source\\css_partial\\highlight.styl 阿里巴巴矢量图标库 Word联盟 (不止有word) 51CTO学院 Shodan 搜索 thestocks (免费高质量图片素材网站集合) mathpix 少数派 (高效工作，品质生活) Gephi (图数据可视化) Pexels (高质量图片网站) 文案狗 有哪些免费的PPT模板下载网站？ 颜色 15分钟入门Chrome神器Vimium","link":"/2019/12/25/%E7%BD%91%E7%AB%99/"},{"title":"interview (网络专业相关)","text":"转载自github—huihut 📖 Github &emsp;&emsp; | &emsp;&emsp; 📚 Docsify 简体中文 &emsp;&emsp; | &emsp;&emsp; English 💡 关于 📚 本仓库是面向 C/C++ 技术方向校招求职者、初学者的基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。 💡 侧边目录支持方式：📚 Docsify 文档、Github + TOC 导航（TOC预览.png） 📄 保存为 PDF 方式：使用 Chrome 浏览器打开 📚 Docsify 文档 页面，缩起左侧目录-右键 - 打印 - 选择目标打印机是另存为PDF - 保存（打印预览.png） 🙏 仓库内容如有错误或改进欢迎 issue 或 pr，建议或讨论可在 #12 提出。由于本人水平有限，仓库中的知识点有来自本人原创、读书笔记、书籍、博文等，非原创均已标明出处，如有遗漏，请 issue 提出。本仓库遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。 📑 目录 ➕ C/C++ ⭐️ Effective 📦 STL 〽️ 数据结构 ⚡️ 算法 ❓ Problems 💻 操作系统 ☁️ 计算机网络 🌩 网络编程 💾 数据库 📏 设计模式 ⚙️ 链接装载库 📚 书籍 🔱 C/C++ 发展方向 💯 复习刷题网站 📝 面试题目经验 📆 招聘时间岗位 👍 内推 👬 贡献者 🍭 支持赞助 📜 License ➕ C/C++const作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 const 的指针与引用 指针 指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer） 引用 指向常量的引用（reference to const） 没有 const reference，因为引用本身就是 const pointer （为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 p2、p3 使用const 使用 123456789101112131415161718192021222324252627282930313233343536373839404142// 类class A{private: const int a; // 常对象成员，只能在初始化列表赋值public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值};void function(){ // 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = &amp;a; // 指针变量，指向常对象 const A &amp;q = a; // 指向常对象的引用 // 指针 char greeting[] = &quot;Hello&quot;; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量}// 函数void function1(const int Var); // 传递过来的参数在函数内不可变void function2(const char* Var); // 参数指针所指内容为常量void function3(char* const Var); // 参数指针为常量void function4(const int&amp; Var); // 引用参数在函数内为常量// 函数返回值const int function5(); // 返回一个常数const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6();int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); static作用 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。 this 指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）； this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。 在以下场景中，经常需要显式引用 this 指针： 为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。 inline 内联函数特征 相当于把内联函数里面的内容写在调用内联函数处； 相当于不用执行进入函数的步骤，直接执行函数体； 相当于宏，却比宏多了类型检查，真正具有函数特性； 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数； 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。 使用inline 使用 12345678910111213141516171819// 声明1（加 inline，建议使用）inline int functionName(int first, int second,...);// 声明2（不加 inline）int functionName(int first, int second,...);// 定义inline int functionName(int first, int second,...) {/****/};// 类内定义，隐式内联class A { int doA() { return 0; } // 隐式内联}// 类外定义，需要显式内联class A { int doA();}inline int A::doA() { return 0; } // 需要显式内联 编译器对 inline 函数的处理步骤 将 inline 函数体复制到 inline 函数调用点处； 为所用 inline 函数中的局部变量分配内存空间； 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。 优缺点优点 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 内联函数在运行时可调试，而宏定义不可以。 缺点 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。 虚函数（virtual）可以是内联函数（inline）吗？ Are “inline virtual” member functions ever actually “inlined”? 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。 虚函数内联使用 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using namespace std;class Base{public: inline virtual void who() { cout &lt;&lt; &quot;I am Base\\n&quot;; } virtual ~Base() {}};class Derived : public Base{public: inline void who() // 不写inline时隐式内联 { cout &lt;&lt; &quot;I am Derived\\n&quot;; }};int main(){ // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 Base b; b.who(); // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。 Base *ptr = new Derived(); ptr-&gt;who(); // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。 delete ptr; ptr = nullptr; system(&quot;pause&quot;); return 0;} volatile1volatile int i = 10; volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） const 可以是 volatile （如只读的状态寄存器） 指针可以是 volatile assert()断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、&lt;cassert&gt;（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。 assert() 使用 1234#define NDEBUG // 加上这行，则 assert 不可用#include &lt;assert.h&gt;assert( p != NULL ); // assert 不可用 sizeof() sizeof 对数组，得到整个数组所占空间大小。 sizeof 对指针，得到指针本身所占空间大小。 #pragma pack(n)设定结构体、联合以及类成员变量以 n 字节方式对齐 #pragma pack(n) 使用 1234567891011#pragma pack(push) // 保存对齐状态#pragma pack(4) // 设定为 4 字节对齐struct test{ char m1; double m4; int m3;};#pragma pack(pop) // 恢复对齐状态 位域1Bit mode: 2; // mode 占 2 位 类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。 位域在内存中的布局是与机器有关的 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定 取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域 extern “C” 被 extern 限定的函数或变量是 extern 类型的 被 extern &quot;C&quot; 修饰的变量和函数是按照 C 语言方式编译和链接的 extern &quot;C&quot; 的作用是让 C++ 编译器将 extern &quot;C&quot; 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 extern “C” 使用 123456789#ifdef __cplusplusextern &quot;C&quot; {#endifvoid *memset(void *, int, size_t);#ifdef __cplusplus}#endif struct 和 typedef structC 中1234// ctypedef struct Student { int age; } S; 等价于 123456// cstruct Student { int age; };typedef struct Student S; 此时 S 等价于 struct Student，但两个标识符名称空间不相同。 另外还可以定义与 struct Student 不冲突的 void Student() {}。 C++ 中由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。 一、如果在类标识符空间定义了 struct Student {...};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。 即表现为可以使用 Student 也可以使用 struct Student，如下： 123456// cppstruct Student { int age; };void f( Student me ); // 正确，&quot;struct&quot; 关键字可省略 二、若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下： 12345678910111213typedef struct Student { int age; } S;void Student() {} // 正确，定义后 &quot;Student&quot; 只代表此函数//void S() {} // 错误，符号 &quot;S&quot; 已经被定义为一个 &quot;struct Student&quot; 的别名int main() { Student(); struct Student me; // 或者 &quot;S me&quot;; return 0;} C++ 中 struct 和 class总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。 区别 最本质的一个区别就是默认的访问控制 默认的继承访问权限。struct 是 public 的，class 是 private 的。 struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。 union 联合联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点： 默认访问控制符为 public 可以含有构造函数、析构函数 不能含有引用类型的成员 不能继承自其他类，不能作为基类 不能含有虚函数 匿名 union 在定义所在作用域可直接访问 union 成员 匿名 union 不能包含 protected 成员或 private 成员 全局匿名联合必须是静态（static）的 union 使用 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;union UnionTest { UnionTest() : i(10) {}; int i; double d;};static union { int i; double d;};int main() { UnionTest u; union { int i; double d; }; std::cout &lt;&lt; u.i &lt;&lt; std::endl; // 输出 UnionTest 联合的 10 ::i = 20; std::cout &lt;&lt; ::i &lt;&lt; std::endl; // 输出全局静态匿名联合的 20 i = 30; std::cout &lt;&lt; i &lt;&lt; std::endl; // 输出局部匿名联合的 30 return 0;} C 实现 C++ 类C 实现 C++ 的面向对象特性（封装、继承、多态） 封装：使用函数指针把属性与方法封装到结构体中 继承：结构体嵌套 多态：父类与子类方法的函数指针不同 Can you write object-oriented code in C? [closed] explicit（显式）关键字 explicit 修饰构造函数时，可以防止隐式转换和复制初始化 explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外 explicit 使用 123456789101112131415161718192021222324252627282930313233343536373839404142struct A{ A(int) { } operator bool() const { return true; }};struct B{ explicit B(int) {} explicit operator bool() const { return true; }};void doA(A a) {}void doB(B b) {}int main(){ A a1(1); // OK：直接初始化 A a2 = 1; // OK：复制初始化 A a3{ 1 }; // OK：直接列表初始化 A a4 = { 1 }; // OK：复制列表初始化 A a5 = (A)1; // OK：允许 static_cast 的显式转换 doA(1); // OK：允许从 int 到 A 的隐式转换 if (a1); // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a6（a1）; // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a7 = a1; // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a8 = static_cast&lt;bool&gt;(a1); // OK ：static_cast 进行直接初始化 B b1(1); // OK：直接初始化 B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以复制初始化 B b3{ 1 }; // OK：直接列表初始化 B b4 = { 1 }; // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化 B b5 = (B)1; // OK：允许 static_cast 的显式转换 doB(1); // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换 if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换 bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换 bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换 bool b8 = static_cast&lt;bool&gt;(b1); // OK：static_cast 进行直接初始化 return 0;} friend 友元类和友元函数 能访问私有成员 破坏封装性 友元关系不可传递 友元关系的单向性 友元声明的形式及数量不受限制 usingusing 声明一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如： 1using namespace_name::name; 构造函数的 using 声明在 C++11 中，派生类能够重用其直接基类定义的构造函数。 12345class Derived : Base {public: using Base::Base; /* ... */}; 如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数： 1Derived(parms) : Base(args) { } using 指示using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如： 1using namespace_name name; 尽量少使用 using 指示 污染命名空间 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。 using 使用 尽量少使用 using 指示 1using namespace std; 应该多使用 using 声明 123int x;std::cin &gt;&gt; x ;std::cout &lt;&lt; x &lt;&lt; std::endl; 或者 123456using std::cin;using std::cout;using std::endl;int x;cin &gt;&gt; x;cout &lt;&lt; x &lt;&lt; endl; :: 范围解析运算符分类 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的 :: 使用 1234567891011121314151617181920212223int count = 11; // 全局（::）的 countclass A {public: static int count; // 类 A 的 count（A::count）};int A::count = 21;void fun(){ int count = 31; // 初始化局部的 count 为 31 count = 32; // 设置局部的 count 的值为 32}int main() { ::count = 12; // 测试 1：设置全局的 count 的值为 12 A::count = 22; // 测试 2：设置类 A 的 count 为 22 fun(); // 测试 3 return 0;} enum 枚举类型限定作用域的枚举类型1enum class open_modes { input, output, append }; 不限定作用域的枚举类型12enum color { red, yellow, green };enum { floatPrec = 6, doublePrec = 10 }; decltypedecltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法： 1decltype ( expression ) decltype 使用 1234567891011121314// 尾置返回允许我们在参数列表之后声明返回类型template &lt;typename It&gt;auto fcn(It beg, It end) -&gt; decltype(*beg){ // 处理序列 return *beg; // 返回序列中一个元素的引用}// 为了使用模板参数成员，必须用 typenametemplate &lt;typename It&gt;auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type{ // 处理序列 return *beg; // 返回序列中一个元素的拷贝} 引用左值引用常规引用，一般表示对象的身份。 右值引用右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 引用折叠 X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp; X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp; 宏 宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。 成员初始化列表好处 更高效：少了一次调用默认构造函数的过程。 有些场合必须要用初始化列表： 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化 initializer_list 列表初始化用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数. initializer_list 使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt; template &lt;class T&gt;struct S { std::vector&lt;T&gt; v; S(std::initializer_list&lt;T&gt; l) : v(l) { std::cout &lt;&lt; &quot;constructed with a &quot; &lt;&lt; l.size() &lt;&lt; &quot;-element list\\n&quot;; } void append(std::initializer_list&lt;T&gt; l) { v.insert(v.end(), l.begin(), l.end()); } std::pair&lt;const T*, std::size_t&gt; c_arr() const { return {&amp;v[0], v.size()}; // 在 return 语句中复制列表初始化 // 这不使用 std::initializer_list }}; template &lt;typename T&gt;void templated_fn(T) {} int main(){ S&lt;int&gt; s = {1, 2, 3, 4, 5}; // 复制初始化 s.append({6, 7, 8}); // 函数调用中的列表初始化 std::cout &lt;&lt; &quot;The vector size is now &quot; &lt;&lt; s.c_arr().second &lt;&lt; &quot; ints:\\n&quot;; for (auto n : s.v) std::cout &lt;&lt; n &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;Range-for over brace-init-list: \\n&quot;; for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作 std::cout &lt;&lt; x &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; auto al = {10, 11, 12}; // auto 的特殊规则 std::cout &lt;&lt; &quot;The list bound to auto has size() = &quot; &lt;&lt; al.size() &lt;&lt; '\\n'; // templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式， // 它无类型，故 T 无法推导 templated_fn&lt;std::initializer_list&lt;int&gt;&gt;({1, 2, 3}); // OK templated_fn&lt;std::vector&lt;int&gt;&gt;({1, 2, 3}); // 也 OK} 面向对象面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。 面向对象三大特征 —— 封装、继承、多态 封装把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。 public 成员：可以被任意实体访问 protected 成员：只允许被子类及本类的成员函数访问 private 成员：只允许被本类的成员函数、友元类或友元函数访问 继承 基类（父类）——&gt; 派生类（子类） 多态 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。 多态是以封装和继承为基础的。 C++ 多态分类及实现： 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载 子类型多态（Subtype Polymorphism，运行期）：虚函数 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换 The Four Polymorphisms in C++ 静态多态（编译期/早绑定）函数重载 123456class A{public: void do(int a); void do(int a, int b);}; 动态多态（运行期期/晚绑定） 虚函数：用 virtual 修饰成员函数，使其成为虚函数 注意： 普通函数（非类成员函数）不能是虚函数 静态函数（static）不能是虚函数 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针） 内联函数不能是表现多态性时的虚函数，解释见：虚函数（virtual）可以是内联函数（inline）吗？ 动态多态使用 123456789101112131415161718192021222324252627282930313233class Shape // 形状类{public: virtual double calcArea() { ... } virtual ~Shape();};class Circle : public Shape // 圆形类{public: virtual double calcArea(); ...};class Rect : public Shape // 矩形类{public: virtual double calcArea(); ...};int main(){ Shape * shape1 = new Circle(4.0); Shape * shape2 = new Rect(5.0, 6.0); shape1-&gt;calcArea(); // 调用圆形类里面的方法 shape2-&gt;calcArea(); // 调用矩形类里面的方法 delete shape1; shape1 = nullptr; delete shape2; shape2 = nullptr; return 0;} 虚析构函数虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。 虚析构函数使用 123456789101112131415161718192021class Shape{public: Shape(); // 构造函数不能是虚函数 virtual double calcArea(); virtual ~Shape(); // 虚析构函数};class Circle : public Shape // 圆形类{public: virtual double calcArea(); ...};int main(){ Shape * shape1 = new Circle(4.0); shape1-&gt;calcArea(); delete shape1; // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。 shape1 = NULL; return 0；} 纯虚函数纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。 1virtual int A() = 0; 虚函数、纯虚函数 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。 虚基类是虚继承中的基类，具体见下文虚继承。 CSDN . C++ 中的虚函数、纯虚函数区别和联系 虚函数指针、虚函数表 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。 虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。 C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现 虚继承虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。 虚继承、虚函数 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间） 不同之处： 虚继承 虚基类依旧存在继承类中，只占用存储空间 虚基类表存储的是虚基类相对直接继承类的偏移 虚函数 虚函数不占用存储空间 虚函数表存储的是虚函数地址 模板类、成员模板、虚函数 模板类中可以使用虚函数 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数 抽象类、接口类、聚合类 抽象类：含有纯虚函数的类 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点： 所有成员都是 public 没有定义任何构造函数 没有类内初始化 没有基类，也没有 virtual 函数 内存分配和管理malloc、calloc、realloc、alloca malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。 calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。 realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。 alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。 malloc、free用于分配、释放内存 malloc、free 使用 申请内存，确认是否申请成功 12char *str = (char*) malloc(100);assert(str != nullptr); 释放内存后指针置空 12free(p); p = nullptr; new、delete new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。 delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。 new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。 new、delete 使用 申请内存，确认是否申请成功 123456int main(){ T* t = new T(); // 先内存分配 ，再构造函数 delete t; // 先析构函数，再内存释放 return 0;} 定位 new定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。 1234new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] { braced initializer list } place_address 是个指针 initializers 提供一个（可能为空的）以逗号分隔的初始值列表 delete this 合法吗？ Is it legal (and moral) for a member function to say delete this? 合法，但： 必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的 必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数 必须保证成员函数的 delete this 后面没有调用 this 了 必须保证 delete this 后没有人使用了 如何定义一个只能在堆上（栈上）生成对象的类？ 如何定义一个只能在堆上（栈上）生成对象的类? 只能在堆上方法：将析构函数设置为私有 原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。 只能在栈上方法：将 new 和 delete 重载为私有 原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。 智能指针C++ 标准库（STL）中头文件：#include &lt;memory&gt; C++ 981std::auto_ptr&lt;std::string&gt; ps (new std::string(str))； C++ 11 shared_ptr unique_ptr weak_ptr auto_ptr（被 C++11 弃用） Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。 shared_ptr多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁 weak_ptrweak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题 unique_ptrunique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。 unique_ptr 用于取代 auto_ptr auto_ptr被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。 auto_ptr 与 unique_ptr 比较 auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义； auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）； 强制类型转换运算符 MSDN . 强制转换运算符 static_cast 用于非多态类型的转换 不执行运行时类型检查（转换安全性不如 dynamic_cast） 通常用于转换数值数据类型（如 float -&gt; int） 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法） 向上转换是一种隐式转换。 dynamic_cast 用于多态类型的转换 执行行运行时类型检查 只适用于指针或引用 对不明确的指针的转换将失败（返回 nullptr），但不引发异常 可以在整个类层次结构中移动指针，包括向上转换、向下转换 const_cast 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ） reinterpret_cast 用于位的简单重新解释 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全） 也允许将任何整数类型转换为任何指针类型以及反向转换。 reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。 bad_cast 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。 bad_cast 使用 123456try { Circle&amp; ref_circle = dynamic_cast&lt;Circle&amp;&gt;(ref_shape); } catch (bad_cast b) { cout &lt;&lt; &quot;Caught: &quot; &lt;&lt; b.what(); } 运行时类型信息 (RTTI)dynamic_cast 用于多态类型的转换 typeid typeid 运算符允许在运行时确定对象的类型 type_id 返回一个 type_info 对象的引用 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数 只能获取对象的实际类型 type_info type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。 头文件：typeinfo typeid、type_info 使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;using namespace std;class Flyable // 能飞的{public: virtual void takeoff() = 0; // 起飞 virtual void land() = 0; // 降落};class Bird : public Flyable // 鸟{public: void foraging() {...} // 觅食 virtual void takeoff() {...} virtual void land() {...} virtual ~Bird(){}};class Plane : public Flyable // 飞机{public: void carry() {...} // 运输 virtual void takeoff() {...} virtual void land() {...}};class type_info{public: const char* name() const; bool operator == (const type_info &amp; rhs) const; bool operator != (const type_info &amp; rhs) const; int before(const type_info &amp; rhs) const; virtual ~type_info();private: ...};void doSomething(Flyable *obj) // 做些事情{ obj-&gt;takeoff(); cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl; // 输出传入对象类型（&quot;class Bird&quot; or &quot;class Plane&quot;） if(typeid(*obj) == typeid(Bird)) // 判断对象类型 { Bird *bird = dynamic_cast&lt;Bird *&gt;(obj); // 对象转化 bird-&gt;foraging(); } obj-&gt;land();}int main(){ Bird *b = new Bird(); doSomething(b); delete b; b = nullptr; return 0;} ⭐️ EffectiveEffective C++ 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL） 宁可以编译器替换预处理器（尽量以 const、enum、inline 替换 #define） 尽可能使用 const 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高） 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数） 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现） 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数） 别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理） 绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class） 令 operator= 返回一个 reference to *this （用于连锁赋值） 在 operator= 中处理 “自我赋值” 赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数） 以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII）） 在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr）） 在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便） 成对使用 new 和 delete 时要采取相同形式（new 中使用 [] 则 delete []，new 中不使用 [] 则 delete） 以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏） 让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任） 设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。 宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象） 必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。） 将成员变量声明为 private（为了封装、一致性、对其读写精确控制等） 宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性） 若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数 考虑写一个不抛异常的 swap 函数 尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率） 尽量少做转型动作（旧式：(T)expression、T(expression)；新式：const_cast&lt;T&gt;(expression)、dynamic_cast&lt;T&gt;(expression)、reinterpret_cast&lt;T&gt;(expression)、static_cast&lt;T&gt;(expression)、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型） 避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性） 为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型） 透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级） 将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件） 确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象） 避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日） 区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承） 考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 tr1::function 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数） 绝不重新定义继承而来的 non-virtual 函数 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound） 通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出）） 明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承） 明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本） 了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期） 了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符） 学习处理模板化基类内的名称（可在 derived class templates 内通过 this-&gt; 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成） 将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码） 运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符） 需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”） 请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if…else 测试） 认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码） 了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常） 了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为） 编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”） 写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本） 不要轻忽编译器的警告 让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件） 让自己熟悉 Boost（准标准库） More Effective c++ 仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers） 最好使用 C++ 转型操作符（static_cast、const_cast、dynamic_cast、reinterpret_cast） 绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用） 非必要不提供 default constructor（避免对象中的字段被无意义地初始化） 对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为） 区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础） 千万不要重载 &amp;&amp;，|| 和 , 操作符（&amp;&amp; 与 || 的重载会用 “函数调用语义” 取代 “骤死式语义”；, 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估） 了解各种不同意义的 new 和 delete（new operator、operator new、placement new、operator new[]；delete operator、operator delete、destructor、operator delete[]） 利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏） 在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try…catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题） 禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情） 了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数） 以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数） 明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions） 了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions） 谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码） 考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作） 分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率） Google C++ Style Guide 英文：Google C++ Style Guide 中文：C++ 风格指南 其他 Bjarne Stroustrup 的常见问题 Bjarne Stroustrup 的 C++ 风格和技巧常见问题 📦 STLSTL 索引STL 方法含义索引 STL 容器 容器 底层数据结构 时间复杂度 有无序 可不可重复 其他 array 数组 随机读改 O(1) 无序 可重复 支持随机访问 vector 数组 随机读改、尾部插入、尾部删除 O(1)头部插入、头部删除 O(n) 无序 可重复 支持随机访问 deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问 forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 priority_queue vector + max-heap 插入、删除 O(log2n) 有序 可重复 vector容器+heap处理规则 set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复 map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复 unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 STL 算法 算法 底层算法 时间复杂度 可不可重复 find 顺序查找 O(n) 可重复 sort 内省排序 O(n*log2n) 可重复 〽️ 数据结构顺序结构顺序栈（Sequence Stack）SqStack.cpp 顺序栈数据结构和图片 123456typedef struct { ElemType *elem; int top; int size; int increment;} SqStack; 队列（Sequence Queue）队列数据结构 123456typedef struct { ElemType * elem; int front; int rear; int maxSize;}SqQueue; 非循环队列非循环队列图片 SqQueue.rear++ 循环队列循环队列图片 SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize 顺序表（Sequence List）SqList.cpp 顺序表数据结构和图片 123456typedef struct { ElemType *elem; int length; int size; int increment;} SqList; 链式结构LinkList.cpp LinkList_with_head.cpp 链式数据结构 1234typedef struct LNode { ElemType data; struct LNode *next;} LNode, *LinkList; 链队列（Link Queue）链队列图片 线性表的链式表示单链表（Link List）单链表图片 双向链表（Du-Link-List）双向链表图片 循环链表（Cir-Link-List）循环链表图片 哈希表HashTable.cpp 概念哈希函数：H(key): K -&gt; D , key ∈ K 构造方法 直接定址法 除留余数法 数字分析法 折叠法 平方取中法 冲突处理方法 链地址法：key 相同的用单链表链接 开放定址法 线性探测法：key 相同 -&gt; 放到 key 的下一个位置，Hi = (H(key) + i) % m 二次探测法：key 相同 -&gt; 放到 Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2） 随机探测法：H = (H(key) + 伪随机数) % m 线性探测的哈希表数据结构线性探测的哈希表数据结构和图片 123456789101112typedef char KeyType;typedef struct { KeyType key;}RcdType;typedef struct { RcdType *rcd; int size; int count; bool *tag;}HashTable; 递归概念函数直接或间接地调用自身 递归与分治 分治法 问题的分解 问题规模的分解 折半查找（递归） 归并排序（递归） 快速排序（递归） 递归与迭代 迭代：反复利用变量旧值推出新值 折半查找（迭代） 归并排序（迭代） 广义表头尾链表存储表示广义表的头尾链表存储表示和图片 12345678910111213141516// 广义表的头尾链表存储表示typedef enum {ATOM, LIST} ElemTag;// ATOM==0：原子，LIST==1：子表typedef struct GLNode { ElemTag tag; // 公共部分，用于区分原子结点和表结点 union { // 原子结点和表结点的联合部分 AtomType atom; // atom 是原子结点的值域，AtomType 由用户定义 struct { struct GLNode *hp, *tp; } ptr; // ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾 } a;} *GList, GLNode; 扩展线性链表存储表示扩展线性链表存储表示和图片 1234567891011121314// 广义表的扩展线性链表存储表示typedef enum {ATOM, LIST} ElemTag;// ATOM==0：原子，LIST==1：子表typedef struct GLNode1 { ElemTag tag; // 公共部分，用于区分原子结点和表结点 union { // 原子结点和表结点的联合部分 AtomType atom; // 原子结点的值域 struct GLNode1 *hp; // 表结点的表头指针 } a; struct GLNode1 *tp; // 相当于线性链表的 next，指向下一个元素结点} *GList1, GLNode1; 二叉树BinaryTree.cpp 性质 非空二叉树第 i 层最多 2(i-1) 个结点 （i &gt;= 1） 深度为 k 的二叉树最多 2k - 1 个结点 （k &gt;= 1） 度为 0 的结点数为 n0，度为 2 的结点数为 n2，则 n0 = n2 + 1 有 n 个结点的完全二叉树深度 k = ⌊ log2(n) ⌋ + 1 对于含 n 个结点的完全二叉树中编号为 i （1 &lt;= i &lt;= n） 的结点 若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋ 若 2i &gt; n，则 i 结点没有左孩子，否则孩子编号为 2i 若 2i + 1 &gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1 存储结构二叉树数据结构 12345typedef struct BiTNode{ TElemType data; struct BiTNode *lchild, *rchild;}BiTNode, *BiTree; 顺序存储二叉树顺序存储图片 链式存储二叉树链式存储图片 遍历方式 先序遍历 中序遍历 后续遍历 层次遍历 分类 满二叉树 完全二叉树（堆） 大顶堆：根 &gt;= 左 &amp;&amp; 根 &gt;= 右 小顶堆：根 &lt;= 左 &amp;&amp; 根 &lt;= 右 二叉查找树（二叉排序树）：左 &lt; 根 &lt; 右 平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | &lt;= 1 最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整： LL型：根的左孩子右旋 RR型：根的右孩子左旋 LR型：根的左孩子左旋，再右旋 RL型：右孩子的左子树，先右旋，再左旋 其他树及森林树的存储结构 双亲表示法 双亲孩子表示法 孩子兄弟表示法 并查集一种不相交的子集所构成的集合 S = {S1, S2, …, Sn} 平衡二叉树（AVL树）性质 | 左子树树高 - 右子树树高 | &lt;= 1 平衡二叉树必定是二叉搜索树，反之则不一定 最小二叉平衡树的节点的公式：F(n)=F(n-1)+F(n-2)+1 （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量） 平衡二叉树图片 最小失衡树平衡二叉树插入新结点导致失衡的子树 调整： LL 型：根的左孩子右旋 RR 型：根的右孩子左旋 LR 型：根的左孩子左旋，再右旋 RL 型：右孩子的左子树，先右旋，再左旋 红黑树RedBlackTree.cpp 红黑树的特征是什么？ 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是 NIL 节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红） 调整 变色 左旋 右旋 应用 关联数组：如 STL 中的 map、set 红黑树、B 树、B+ 树的区别？ 红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些 B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。 B 树（B-tree）、B+ 树（B+-tree）B 树、B+ 树图片 特点 一般化的二叉查找树（binary search tree） “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好） 应用 大部分文件系统、数据库系统都采用B树、B+树作为索引结构 区别 B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。 B+树中所有叶子节点都是通过指针连接在一起，而B树不会。 B树的优点对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。 B+树的优点 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。 B 树、B+ 树区别来自：differences-between-b-trees-and-b-trees、B树和B+树的区别 八叉树八叉树图片 八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。 用途 三维计算机图形 最邻近搜索 ⚡️ 算法排序 排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性 冒泡排序 O(n2) O(n2) O(1) 稳定 选择排序 O(n2) O(n2) O(1) 数组不稳定、链表稳定 插入排序 O(n2) O(n2) O(1) 稳定 快速排序 O(n*log2n) O(n2) O(log2n) 不稳定 堆排序 O(n*log2n) O(n*log2n) O(1) 不稳定 归并排序 O(n*log2n) O(n*log2n) O(n) 稳定 希尔排序 O(n*log2n) O(n2) O(1) 不稳定 计数排序 O(n+m) O(n+m) O(n+m) 稳定 桶排序 O(n) O(n) O(m) 稳定 基数排序 O(k*n) O(n2) 稳定 均按从小到大排列 k：代表数值中的 “数位” 个数 n：代表数据规模 m：代表数据的最大值减最小值 来自：wikipedia . 排序算法 查找 查找算法 平均时间复杂度 空间复杂度 查找条件 顺序查找 O(n) O(1) 无序或有序 二分查找（折半查找） O(log2n) O(1) 有序 插值查找 O(log2(log2n)) O(1) 有序 斐波那契查找 O(log2n) O(1) 有序 哈希查找 O(1) O(n) 无序或有序 二叉查找树（二叉搜索树查找） O(log2n) 红黑树 O(log2n) 2-3树 O(log2n - log3n) B树/B+树 O(log2n) 图搜索算法 图搜索算法 数据结构 遍历时间复杂度 空间复杂度 BFS广度优先搜索 邻接矩阵邻接链表 O(|v|2)O(|v|+|E|) O(|v|2)O(|v|+|E|) DFS深度优先搜索 邻接矩阵邻接链表 O(|v|2)O(|v|+|E|) O(|v|2)O(|v|+|E|) 其他算法 算法 思想 应用 分治法 把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 循环赛日程安排问题、排序算法（快速排序、归并排序） 动态规划 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题 背包问题、斐波那契数列 贪心法 一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法 旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码 ❓ ProblemsSingle Problem Chessboard Coverage Problem（棋盘覆盖问题） Knapsack Problem（背包问题） Neumann Neighbor Problem（冯诺依曼邻居问题） Round Robin Problem（循环赛日程安排问题） Tubing Problem（输油管道问题） Leetcode Problems Github . haoel/leetcode Github . pezy/LeetCode 剑指 Offer Github . zhedahht/CodingInterviewChinese2 Github . gatieme/CodingInterviews Cracking the Coding Interview 程序员面试金典 Github . careercup/ctci 牛客网 . 程序员面试金典 牛客网 牛客网 . 在线编程专题 💻 操作系统进程与线程对于有线程系统： 进程是资源分配的独立单位 线程是资源调度的独立单位 对于无线程系统： 进程是资源调度、分配的独立单位 进程之间的通信方式以及优缺点 管道（PIPE） 有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信 优点：可以实现任意关系的进程间的通信 缺点： 长期存于系统中，使用不当容易出错 缓冲区有限 无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程） 优点：简单方便 缺点： 局限于单向通信 只能创建在它的进程以及其有亲缘关系的进程之间 缓冲区有限 信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问 优点：可以同步进程 缺点：信号量有限 信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生 消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合 共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问 优点：无须复制，快捷，信息量大 缺点： 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信 套接字（Socket）：可用于不同计算机间的进程通信 优点： 传输数据为字节级，传输数据可自定义，数据量小效率高 传输数据时间短，性能高 适合于客户端和服务器端之间信息实时交互 可以加密,数据安全性强 缺点：需对传输的数据进行解析，转化成应用级的数据。 线程之间的通信方式 锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition） 互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 信号量机制(Semaphore) 无名线程信号量 命名线程信号量 信号机制(Signal)：类似进程间的信号处理 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制 进程之间的通信方式以及优缺点来源于：进程线程面试题总结 进程之间私有和共享的资源 私有：地址空间、堆、全局变量、栈、寄存器 共享：代码段，公共数据，进程目录，进程 ID 线程之间私有和共享的资源 私有：线程栈，寄存器，程序计数器 共享：堆，地址空间，全局变量，静态变量 多进程与多线程间的对比、优劣与选择对比 对比维度 多进程 多线程 总结 数据共享、同步 数据共享复杂，需要用 IPC；数据是分开的，同步简单 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 各有优势 内存、CPU 占用内存多，切换复杂，CPU 利用率低 占用内存少，切换简单，CPU 利用率高 线程占优 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度很快 线程占优 编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优 可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优 分布式 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 适应于多核分布式 进程占优 优劣 优劣 多进程 多线程 优点 编程、调试简单，可靠性较高 创建、销毁、切换速度快，内存、资源占用小 缺点 创建、销毁、切换速度慢，内存、资源占用大 编程、调试复杂，可靠性较差 选择 需要频繁创建销毁的优先用线程 需要进行大量计算的优先使用线程 强相关的处理用线程，弱相关的处理用进程 可能要扩展到多机分布的用进程，多核分布的用线程 都满足需求的情况下，用你最熟悉、最拿手的方式 多进程与多线程间的对比、优劣与选择来自：多线程还是多进程的选择及区别 Linux 内核的同步方式原因在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。 同步方式 原子操作 信号量（semaphore） 读写信号量（rw_semaphore） 自旋锁（spinlock） 大内核锁（BKL，Big Kernel Lock） 读写锁（rwlock） 大读者锁（brlock-Big Reader Lock） 读-拷贝修改(RCU，Read-Copy Update) 顺序锁（seqlock） 来自：Linux 内核的同步机制，第 1 部分、Linux 内核的同步机制，第 2 部分 死锁原因 系统资源不足 资源分配不当 进程运行推进顺序不合适 产生条件 互斥 请求和保持 不剥夺 环路 预防 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。 有序资源分配法 银行家算法 文件系统 Windows：FCB 表 + FAT + 位图 Unix：inode + 混合索引 + 成组链接 主机字节序与网络字节序主机字节序（CPU 字节序）概念主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种： 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址 存储方式32 位整数 0x12345678 是从起始位置为 0x00 的地址开始存放，则： 内存地址 0x00 0x01 0x02 0x03 大端 12 34 56 78 小端 78 56 34 12 大端小端图片 判断大端小端判断大端小端 可以这样判断自己 CPU 字节序是大端还是小端： 1234567891011121314#include &lt;iostream&gt;using namespace std;int main(){ int i = 0x12345678; if (*((char*)&amp;i) == 0x12) cout &lt;&lt; &quot;大端&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;小端&quot; &lt;&lt; endl; return 0;} 各架构处理器的字节序 x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序； Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序； ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。 网络字节序网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。 网络字节顺序采用：大端（Big Endian）排列方式。 页面置换算法在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。 分类 全局置换：在整个内存空间置换 局部置换：在本进程中进行置换 算法全局： 工作集算法 缺页率置换算法 局部： 最佳置换算法（OPT） 先进先出置换算法（FIFO） 最近最久未使用（LRU）算法 时钟（Clock）置换算法 ☁️ 计算机网络 本节部分知识点来自《计算机网络（第 7 版）》 计算机网络体系结构： 各层作用及协议 分层 作用 协议 物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器） 数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机） 网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） 运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX 会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC 表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII 应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 物理层 传输数据的单位：比特 数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点） 通道： 单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播 双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收 双向同时通信（全双工通信）：通信双方可以同时发送和接收信息 通道复用技术： 频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源 时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度 波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用 码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信 数据链路层主要信道： 点对点信道 广播信道 点对点信道 数据单元：帧 三个基本问题： 封装成帧：把网络层的 IP 数据报封装成帧，SOH - 数据部分 - EOT 透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符） 差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check） 点对点协议（Point-to-Point Protocol）： 点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议 广播信道广播通信： 硬件地址（物理地址、MAC 地址） 单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同 广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧 多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧 网络层 IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。 ARP（Address Resolution Protocol，地址解析协议） ICMP（Internet Control Message Protocol，网际控制报文协议） IGMP（Internet Group Management Protocol，网际组管理协议） IP 网际协议IP 地址分类： IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;} IP 地址类别 网络号 网络范围 主机号 IP 地址范围 A 类 8bit，第一位固定为 0 0 —— 127 24bit 1.0.0.0 —— 127.255.255.255 B 类 16bit，前两位固定为 10 128.0 —— 191.255 16bit 128.0.0.0 —— 191.255.255.255 C 类 24bit，前三位固定为 110 192.0.0 —— 223.255.255 8bit 192.0.0.0 —— 223.255.255.255 D 类 前四位固定为 1110，后面为多播地址 E 类 前五位固定为 11110，后面保留为今后所用 IP 数据报格式： ICMP 网际控制报文协议ICMP 报文格式： 应用： PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性 TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量 内部网关协议 RIP（Routing Information Protocol，路由信息协议） OSPF（Open Sortest Path First，开放最短路径优先） 外部网关协议 BGP（Border Gateway Protocol，边界网关协议） IP多播 IGMP（Internet Group Management Protocol，网际组管理协议） 多播路由选择协议 VPN 和 NAT VPN（Virtual Private Network，虚拟专用网） NAT（Network Address Translation，网络地址转换） 路由表包含什么？ 网络 ID（Network ID, Network number）：就是目标地址的网络 ID。 子网掩码（subnet mask）：用来判断 IP 所属网络 下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: 0.0.0.0, Netmask: 0.0.0.0）指向自治系统的出口。 根据应用和执行的不同，路由表可能含有如下附加信息： 花费（Cost）：就是数据发送过程中通过路径所需要的花费。 路由的服务质量 路由中需要过滤的出/入连接列表 运输层协议： TCP（Transmission Control Protocol，传输控制协议） UDP（User Datagram Protocol，用户数据报协议） 端口： 应用程序 FTP TELNET SMTP DNS TFTP HTTP HTTPS SNMP 端口号 21 23 25 53 69 80 443 161 TCP TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。 特征： 面向连接 只能点对点（一对一）通信 可靠交互 全双工通信 面向字节流 TCP 如何保证可靠传输： 确认和超时重传 数据合理分片和排序 流量控制 拥塞控制 数据校验 TCP 报文结构 TCP 首部 TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下： URG：紧急比特（urgent），当 URG＝1 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。 ACK：确认比特（Acknowledge）。只有当 ACK＝1 时确认号字段才有效，代表这个封包为确认封包。当 ACK＝0 时，确认号无效。 PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。 RST：复位比特(Reset)，当 RST＝1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。 FIN：终止比特(Final)，用来释放一个连接。当 FIN＝1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 UDP UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。 特征： 无连接 尽最大努力交付 面向报文 没有拥塞控制 支持一对一、一对多、多对一、多对多的交互通信 首部开销小 UDP 报文结构 UDP 首部 TCP/UDP 图片来源于：https://github.com/JerryC8080/understand-tcp-udp TCP 与 UDP 的区别 TCP 面向连接，UDP 是无连接的； TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付 TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信 TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题） UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等） TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节 TCP 黏包问题原因TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。 解决 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。 在数据包之间设置边界，如添加特殊符号 \\r\\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \\r\\n，则会误判为消息的边界。 使用更加复杂的应用层协议。 TCP 流量控制概念流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。 方法利用可变窗口进行流量控制 TCP 拥塞控制概念拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 方法 慢开始( slow-start ) 拥塞避免( congestion avoidance ) 快重传( fast retransmit ) 快恢复( fast recovery ) TCP的拥塞控制图 TCP 传输连接管理 因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png TCP 三次握手建立连接 【TCP 建立连接全过程解释】 客户端发送 SYN 给服务器，说明客户端请求建立连接； 服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）； 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）； 服务端收到客户端的 ACK，连接已建立，可以数据传输。 TCP 为什么要进行三次握手？【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。） Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信} 【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。 知乎 . TCP 为什么是三次握手，而不是两次或四次？ 【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 《计算机网络（第 7 版）-谢希仁》 TCP 四次挥手释放连接 【TCP 释放连接全过程解释】 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）； 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）； 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）； 服务端继续发送之前没发完的数据给客户端； 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）； 客户端收到服务端的 FIN+ACK，并回复 ACK 给客户端（同意释放从服务端到客户端的连接）； 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。 TCP 为什么要进行四次挥手？【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？ 【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。 【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手） 【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。 【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？ 【答案三】 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。 TCP 有限状态机TCP 有限状态机图片 应用层DNS DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。 域名： 域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}，如：blog.huihut.com FTP FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。 TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定 TELNET TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。 HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。 WWW WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问 URL URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address） 标准格式： 协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 完整格式： 协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项如：https://github.com/huihut/interview#cc HTTPHTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。 请求方法 方法 意义 OPTIONS 请求一些选项信息，允许客户端查看服务器的性能 GET 请求指定的页面信息，并返回实体主体 HEAD 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 PUT 从客户端向服务器传送的数据取代指定的文档的内容 DELETE 请求服务器删除指定的页面 TRACE 回显服务器收到的请求，主要用于测试或诊断 状态码（Status-Code） 1xx：表示通知信息，如请求收到了或正在进行处理 100 Continue：继续，客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议 2xx：表示成功，如接收或知道了 200 OK: 请求成功 3xx：表示重定向，如要完成请求还必须采取进一步的行动 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替 4xx：表示客户的差错，如请求中有错误的语法或不能完成 400 Bad Request: 客户端请求的语法错误，服务器无法理解 401 Unauthorized: 请求要求用户的身份认证 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够） 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时 5xx：表示服务器的差错，如服务器失效无法完成请求 500 Internal Server Error: 服务器内部错误，无法完成请求 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求 更多状态码：菜鸟教程 . HTTP状态码 其他协议 SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。 DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途： 用于内部网络或网络服务供应商自动分配 IP 地址给用户 用于内部网络管理员作为对所有电脑作中央管理的手段 SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。 🌩 网络编程Socket Linux Socket 编程（不限 Linux） Socket 中的 read()、write() 函数12ssize_t read(int fd, void *buf, size_t count);ssize_t write(int fd, const void *buf, size_t count); read() read 函数是负责从 fd 中读取内容。 当读成功时，read 返回实际所读的字节数。 如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。 如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。 write() write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。 成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。 （1）write 的返回值大于 0，表示写了部分或者是全部的数据。 （2）返回的值小于 0，此时出现了错误。 如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。 Socket 中 TCP 的三次握手建立连接我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下： 客户端向服务器发送一个 SYN J 服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1 客户端再想服务器发一个确认 ACK K+1 只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图： 从图中可以看出： 当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态； 服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态； 客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认； 服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。 Socket 中 TCP 的四次握手释放连接上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图： 图示过程如下： 某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M； 另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据； 一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N； 接收到这个 FIN 的源发送端 TCP 对它进行确认。 这样每个方向上都有一个 FIN 和 ACK。 💾 数据库 本节部分知识点来自《数据库系统概论（第 5 版）》 基本概念 数据（data）：描述事物的符号记录称为数据。 数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点。 数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。 数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。 实体（entity）：客观存在并可相互区别的事物称为实体。 属性（attribute）：实体所具有的某一特性称为属性。 码（key）：唯一标识实体的属性集称为码。 实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。 实体集（entity set）：同一实体型的集合称为实体集。 联系（relationship）：实体之间的联系通常是指不同实体集之间的联系。 模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。 常用数据模型 层次模型（hierarchical model） 网状模型（network model） 关系模型（relational model） 关系（relation）：一个关系对应通常说的一张表 元组（tuple）：表中的一行即为一个元组 属性（attribute）：表中的一列即为一个属性 码（key）：表中可以唯一确定一个元组的某个属性组 域（domain）：一组具有相同数据类型的值的集合 分量：元组中的一个属性值 关系模式：对关系的描述，一般表示为 关系名(属性1, 属性2, ..., 属性n) 面向对象数据模型（object oriented data model） 对象关系数据模型（object relational data model） 半结构化数据模型（semistructure data model） 常用 SQL 操作 对象类型 对象 操作类型 数据库模式 模式 CREATE SCHEMA 基本表 CREATE SCHEMA，ALTER TABLE 视图 CREATE VIEW 索引 CREATE INDEX 数据 基本表和视图 SELECT，INSERT，UPDATE，DELETE，REFERENCES，ALL PRIVILEGES 属性列 SELECT，INSERT，UPDATE，REFERENCES，ALL PRIVILEGES SQL 语法教程：runoob . SQL 教程 关系型数据库 基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改 关系模型中的三类完整性约束：实体完整性、参照完整性、用户定义的完整性 索引 数据库索引：顺序索引、B+ 树索引、hash 索引 MySQL 索引背后的数据结构及算法原理 数据库完整性 数据库的完整性是指数据的正确性和相容性。 完整性：为了防止数据库中存在不符合语义（不正确）的数据。 安全性：为了保护数据库防止恶意破坏和非法存取。 触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。 关系数据理论 数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。 最重要的数据依赖：函数依赖、多值依赖。 范式 第一范式（1NF）：属性（字段）是最小单位不可再分。 第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。 第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 非主属性对码的传递函数依赖）。 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。 数据库恢复 事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 事物的 ACID 特性：原子性、一致性、隔离性、持续性。 恢复的实现技术：建立冗余数据 -&gt; 利用冗余数据实施数据库恢复。 建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。 并发控制 事务是并发控制的基本单位。 并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。 并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。 基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。 活锁死锁： 活锁：事务永远处于等待状态，可通过先来先服务的策略避免。 死锁：事物永远不能结束 预防：一次封锁法、顺序封锁法； 诊断：超时法、等待图法； 解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。 可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。 📏 设计模式 各大设计模式例子参考：CSDN专栏 . C++ 设计模式 系列博文 设计模式工程目录 单例模式单例模式例子 抽象工厂模式抽象工厂模式例子 适配器模式适配器模式例子 桥接模式桥接模式例子 观察者模式观察者模式例子 设计模式的六大原则 单一职责原则（SRP，Single Responsibility Principle） 里氏替换原则（LSP，Liskov Substitution Principle） 依赖倒置原则（DIP，Dependence Inversion Principle） 接口隔离原则（ISP，Interface Segregation Principle） 迪米特法则（LoD，Law of Demeter） 开放封闭原则（OCP，Open Close Principle） ⚙️ 链接装载库 本节部分知识点来自《程序员的自我修养——链接装载库》 内存、栈、堆一般应用程序内存空间有如下区域： 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据 栈栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面： 函数的返回地址和参数 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量 保存上下文：包括函数调用前后需要保持不变的寄存器 堆堆分配算法： 空闲链表（Free List） 位图（Bitmap） 对象池 “段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。 普遍原因： 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针 编译链接各平台文件格式 平台 可执行文件 目标文件 动态库/共享对象 静态库 Windows exe obj dll lib Unix/Linux ELF、out o so a Mac Mach-O o dylib、tbd、framework a、framework 编译链接过程 预编译（预编译器处理如 #include、#define 等预编译指令，生成 .i 或 .ii 文件） 编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 .s 文件） 汇编（汇编器把汇编码翻译成机器码，生成 .o 文件） 链接（连接器进行地址和空间分配、符号决议、重定位，生成 .out 文件） 现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin 目标文件编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。 可执行文件（Windows 的 .exe 和 Linux 的 ELF）、动态链接库（Windows 的 .dll 和 Linux 的 .so）、静态链接库（Windows 的 .lib 和 Linux 的 .a）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF） 目标文件格式 Windows 的 PE（Portable Executable），或称为 PE-COFF，.obj 格式 Linux 的 ELF（Executable Linkable Format），.o 格式 Intel/Microsoft 的 OMF（Object Module Format） Unix 的 a.out 格式 MS-DOS 的 .COM 格式 PE 和 ELF 都是 COFF（Common File Format）的变种 目标文件存储结构 段 功能 File Header 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等） .text section 代码段，执行语句编译成的机器代码 .data section 数据段，已初始化的全局变量和局部静态变量 .bss section BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间） .rodata section 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量 .comment section 注释信息段，存放编译器版本信息 .note.GNU-stack section 堆栈提示段 其他段略 链接的接口————符号在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。 如下符号表（Symbol Table）： Symbol（符号名） Symbol Value （地址） main 0x100 Add 0x123 … … Linux 的共享库（Shared Library）Linux 下的共享库就是普通的 ELF 共享对象。 共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容 命名libname.so.x.y.z x：主版本号，不同主版本号的库之间不兼容，需要重新编译 y：次版本号，高版本号向后兼容低版本号 z：发布版本号，不对接口进行更改，完全兼容 路径大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。 /lib：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等 /usr/lib：存放非系统运行时所需要的关键性的库，主要是开发库 /usr/local/lib：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库 动态链接器会在 /lib、/usr/lib 和由 /etc/ld.so.conf 配置文件指定的，目录中查找共享库 环境变量 LD_LIBRARY_PATH：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序 LD_PRELOAD：指定预先装载的一些共享库甚至是目标文件 LD_DEBUG：打开动态链接器的调试功能 so 共享库的编写使用 CLion 编写共享库 创建一个名为 MySharedLib 的共享库 CMakeLists.txt 123456cmake_minimum_required(VERSION 3.10)project(MySharedLib)set(CMAKE_CXX_STANDARD 11)add_library(MySharedLib SHARED library.cpp library.h) library.h 12345678910111213141516171819#ifndef MYSHAREDLIB_LIBRARY_H#define MYSHAREDLIB_LIBRARY_H// 打印 Hello World!void hello();// 使用可变模版参数求和template &lt;typename T&gt;T sum(T t){ return t;}template &lt;typename T, typename ...Types&gt;T sum(T first, Types ... rest){ return first + sum&lt;T&gt;(rest...);}#endif library.cpp 123456#include &lt;iostream&gt;#include &quot;library.h&quot;void hello() { std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;} so 共享库的使用（被可执行项目调用）使用 CLion 调用共享库 创建一个名为 TestSharedLib 的可执行项目 CMakeLists.txt 12345678910111213141516171819cmake_minimum_required(VERSION 3.10)project(TestSharedLib)# C++11 编译set(CMAKE_CXX_STANDARD 11)# 头文件路径set(INC_DIR /home/xx/code/clion/MySharedLib)# 库文件路径set(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)include_directories(${INC_DIR})link_directories(${LIB_DIR})link_libraries(MySharedLib)add_executable(TestSharedLib main.cpp)# 链接 MySharedLib 库target_link_libraries(TestSharedLib MySharedLib) main.cpp 12345678910111213#include &lt;iostream&gt;#include &quot;library.h&quot;using std::cout;using std::endl;int main() { hello(); cout &lt;&lt; &quot;1 + 2 = &quot; &lt;&lt; sum(1,2) &lt;&lt; endl; cout &lt;&lt; &quot;1 + 2 + 3 = &quot; &lt;&lt; sum(1,2,3) &lt;&lt; endl; return 0;} 执行结果 123Hello, World!1 + 2 = 31 + 2 + 3 = 6 Windows 应用程序入口函数 GUI（Graphical User Interface）应用，链接器选项：/SUBSYSTEM:WINDOWS CUI（Console User Interface）应用，链接器选项：/SUBSYSTEM:CONSOLE _tWinMain 与 _tmain 函数声明 12345678910Int WINAPI _tWinMain( HINSTANCE hInstanceExe, HINSTANCE, PTSTR pszCmdLine, int nCmdShow);int _tmain( int argc, TCHAR *argv[], TCHAR *envp[]); 应用程序类型 入口点函数 嵌入可执行文件的启动函数 处理ANSI字符（串）的GUI应用程序 _tWinMain(WinMain) WinMainCRTSartup 处理Unicode字符（串）的GUI应用程序 _tWinMain(wWinMain) wWinMainCRTSartup 处理ANSI字符（串）的CUI应用程序 _tmain(Main) mainCRTSartup 处理Unicode字符（串）的CUI应用程序 _tmain(wMain) wmainCRTSartup 动态链接库（Dynamic-Link Library） DllMain _DllMainCRTStartup Windows 的动态链接库（Dynamic-Link Library） 部分知识点来自《Windows 核心编程（第五版）》 用处 扩展了应用程序的特性 简化了项目管理 有助于节省内存 促进了资源的共享 促进了本地化 有助于解决平台间的差异 可以用于特殊目的 注意 创建 DLL，事实上是在创建可供一个可执行模块调用的函数 当一个模块提供一个内存分配函数（malloc、new）的时候，它必须同时提供另一个内存释放函数（free、delete） 在使用 C 和 C++ 混编的时候，要使用 extern “C” 修饰符 一个 DLL 可以导出函数、变量（避免导出）、C++ 类（导出导入需要同编译器，否则避免导出） DLL 模块：cpp 文件中的 __declspec(dllexport) 写在 include 头文件之前 调用 DLL 的可执行模块：cpp 文件的 __declspec(dllimport) 之前不应该定义 MYLIBAPI 加载 Windows 程序的搜索顺序 包含可执行文件的目录 Windows 的系统目录，可以通过 GetSystemDirectory 得到 16 位的系统目录，即 Windows 目录中的 System 子目录 Windows 目录，可以通过 GetWindowsDirectory 得到 进程的当前目录 PATH 环境变量中所列出的目录 DLL 入口函数DllMain 函数 1234567891011121314151617181920212223BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved){ switch(fdwReason) { case DLL_PROCESS_ATTACH: // 第一次将一个DLL映射到进程地址空间时调用 // The DLL is being mapped into the process' address space. break; case DLL_THREAD_ATTACH: // 当进程创建一个线程的时候，用于告诉DLL执行与线程相关的初始化（非主线程执行） // A thread is bing created. break; case DLL_THREAD_DETACH: // 系统调用 ExitThread 线程退出前，即将终止的线程通过告诉DLL执行与线程相关的清理 // A thread is exiting cleanly. break; case DLL_PROCESS_DETACH: // 将一个DLL从进程的地址空间时调用 // The DLL is being unmapped from the process' address space. break; } return (TRUE); // Used only for DLL_PROCESS_ATTACH} 载入卸载库LoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread 函数声明 123456789101112131415161718192021222324// 载入库HMODULE WINAPI LoadLibrary( _In_ LPCTSTR lpFileName);HMODULE LoadLibraryExA( LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);// 若要在通用 Windows 平台（UWP）应用中加载 Win32 DLL，需要调用 LoadPackagedLibrary，而不是 LoadLibrary 或 LoadLibraryExHMODULE LoadPackagedLibrary( LPCWSTR lpwLibFileName, DWORD Reserved);// 卸载库BOOL WINAPI FreeLibrary( _In_ HMODULE hModule);// 卸载库和退出线程VOID WINAPI FreeLibraryAndExitThread( _In_ HMODULE hModule, _In_ DWORD dwExitCode); 显示地链接到导出符号GetProcAddress 函数声明 1234FARPROC GetProcAddress( HMODULE hInstDll, PCSTR pszSymbolName // 只能接受 ANSI 字符串，不能是 Unicode); DumpBin.exe 查看 DLL 信息在 VS 的开发人员命令提示符 使用 DumpBin.exe 可查看 DLL 库的导出段（导出的变量、函数、类名的符号）、相对虚拟地址（RVA，relative virtual address）。如： 1DUMPBIN -exports D:\\mydll.dll LoadLibrary 与 FreeLibrary 流程图LoadLibrary 与 FreeLibrary 流程图 LoadLibrary FreeLibrary DLL 库的编写（导出一个 DLL 模块）DLL 库的编写（导出一个 DLL 模块）DLL 头文件 123456789101112131415161718192021// MyLib.h#ifdef MYLIBAPI// MYLIBAPI 应该在全部 DLL 源文件的 include &quot;Mylib.h&quot; 之前被定义// 全部函数/变量正在被导出#else// 这个头文件被一个exe源代码模块包含，意味着全部函数/变量被导入#define MYLIBAPI extern &quot;C&quot; __declspec(dllimport)#endif// 这里定义任何的数据结构和符号// 定义导出的变量（避免导出变量）MYLIBAPI int g_nResult;// 定义导出函数原型MYLIBAPI int Add(int nLeft, int nRight); DLL 源文件 12345678910111213141516171819// MyLibFile1.cpp// 包含标准Windows和C运行时头文件#include &lt;windows.h&gt;// DLL源码文件导出的函数和变量#define MYLIBAPI extern &quot;C&quot; __declspec(dllexport)// 包含导出的数据结构、符号、函数、变量#include &quot;MyLib.h&quot;// 将此DLL源代码文件的代码放在此处int g_nResult;int Add(int nLeft, int nRight){ g_nResult = nLeft + nRight; return g_nResult;} DLL 库的使用（运行时动态链接 DLL）DLL 库的使用（运行时动态链接 DLL） 123456789101112131415161718192021222324252627282930313233343536373839404142// A simple program that uses LoadLibrary and // GetProcAddress to access myPuts from Myputs.dll. #include &lt;windows.h&gt; #include &lt;stdio.h&gt; typedef int (__cdecl *MYPROC)(LPWSTR); int main( void ) { HINSTANCE hinstLib; MYPROC ProcAdd; BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; // Get a handle to the DLL module. hinstLib = LoadLibrary(TEXT(&quot;MyPuts.dll&quot;)); // If the handle is valid, try to get the function address. if (hinstLib != NULL) { ProcAdd = (MYPROC) GetProcAddress(hinstLib, &quot;myPuts&quot;); // If the function address is valid, call the function. if (NULL != ProcAdd) { fRunTimeLinkSuccess = TRUE; (ProcAdd) (L&quot;Message sent to the DLL function\\n&quot;); } // Free the DLL module. fFreeResult = FreeLibrary(hinstLib); } // If unable to call the DLL function, use an alternative. if (! fRunTimeLinkSuccess) printf(&quot;Message printed from executable\\n&quot;); return 0;} 运行库（Runtime Library）典型程序运行步骤 操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数） 入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。 入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。 main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。 一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。 glibc 入口_start -&gt; __libc_start_main -&gt; exit -&gt; _exit 其中 main(argc, argv, __environ) 函数在 __libc_start_main 里执行。 MSVC CRT 入口int mainCRTStartup(void) 执行如下操作： 初始化和 OS 版本有关的全局变量。 初始化堆。 初始化 I/O。 获取命令行参数和环境变量。 初始化 C 库的一些数据。 调用 main 并记录返回值。 检查错误并将 main 的返回值返回。 C 语言运行库（CRT）大致包含如下功能： 启动与退出：包括入口函数及入口函数所依赖的其他函数等。 标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。 I/O：I/O 功能的封装和实现。 堆：堆的封装和实现。 语言实现：语言中一些特殊功能的实现。 调试：实现调试功能的代码。 C语言标准库（ANSI C）包含： 标准输入输出（stdio.h） 文件操作（stdio.h） 字符操作（ctype.h） 字符串操作（string.h） 数学函数（math.h） 资源管理（stdlib.h） 格式转换（stdlib.h） 时间/日期（time.h） 断言（assert.h） 各种类型上的常数（limits.h &amp; float.h） 变长参数（stdarg.h） 非局部跳转（setjmp.h） 📚 书籍 huihut/CS-Books：📚 Computer Science Books 计算机技术类书籍 PDF 语言 《C++ Primer》 《Effective C++》 《More Effective C++》 《深度探索 C++ 对象模型》 《深入理解 C++11》 《STL 源码剖析》 算法 《剑指 Offer》 《编程珠玑》 《程序员面试宝典》 系统 《深入理解计算机系统》 《Windows 核心编程》 《Unix 环境高级编程》 网络 《Unix 网络编程》 《TCP/IP 详解》 其他 《程序员的自我修养》 🔱 C/C++ 发展方向 C/C++ 发展方向甚广，包括不限于以下方向， 以下列举一些大厂校招岗位要求。 后台/服务器【后台开发】 编程基本功扎实，掌握 C/C++/JAVA 等开发语言、常用算法和数据结构； 熟悉 TCP/UDP 网络协议及相关编程、进程间通讯编程； 了解 Python、Shell、Perl 等脚本语言； 了解 MYSQL 及 SQL 语言、编程，了解 NoSQL, key-value 存储原理； 全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等专业知识； 了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识。 桌面客户端【PC 客户端开发】 计算机软件相关专业本科或以上学历，热爱编程，基础扎实，理解算法和数据结构相关知识； 熟悉 windows 操作系统的内存管理、文件系统、进程线程调度； 熟悉 MFC/windows 界面实现机制，熟练使用 VC，精通 C/C++，熟练使用 STL，以及 Windows 下网络编程经验； 熟练掌握 Windows 客户端开发、调试，有 Windows 应用软件开发经验优先； 对于创新及解决具有挑战性的问题充满激情，具有良好的算法基础及系统分析能力。 图形学/游戏/VR/AR【游戏客户端开发】 计算机科学/工程相关专业本科或以上学历，热爱编程，基础扎实，理解算法、数据结构、软件设计相关知识； 至少掌握一种游戏开发常用的编程语言，具 C++/C# 编程经验优先； 具游戏引擎（如 Unity、Unreal）使用经验者优先； 了解某方面的游戏客户端技术（如图形、音频、动画、物理、人工智能、网络同步）者优先考虑； 对于创新及解决具有挑战性的问题充满激情，有较强的学习能力、分析及解决问题能力，具备良好的团队合作意识； 具阅读英文技术文档能力； 热爱游戏。 测试开发【测试开发】 计算机或相关专业本科及以上学历； 一至两年的 C/C++/Python 或其他计算机语言的编程经验； 具备撰写测试计划、测试用例、以及实现性能和安全等测试的能力； 具备实现自动化系统的能力； 具备定位调查产品缺陷能力、以及代码级别调试缺陷的能力； 工作主动积极，有责任心，具有良好的团队合作精神。 网络安全/逆向【安全技术】 热爱互联网，对操作系统和网络安全有狂热的追求，专业不限； 熟悉漏洞挖掘、网络安全攻防技术，了解常见黑客攻击手法； 掌握基本开发能力，熟练使用 C/C++ 语言； 对数据库、操作系统、网络原理有较好掌握； 具有软件逆向，网络安全攻防或安全系统开发经验者优先。 嵌入式/物联网【嵌入式应用开发】 有良好的编程基础，熟练掌握 C/C++ 语言； 掌握操作系统、数据结构等软件开发必备知识； 具备较强的沟通理解能力及良好的团队合作意识； 有 Linux/Android 系统平台的开发经验者优先。 音视频/流媒体/SDK【音视频编解码】 硕士及以上学历，计算机、信号处理、数学、信息类及相关专业和方向； 视频编解码基础扎实，熟常用的 HEVC 或 H264，有较好的数字信号处理基础； 掌握 C/C++，代码能力强, 熟悉一种汇编语言尤佳； 较强的英文文献阅读能力； 学习能力强，具有团队协作精神，有较强的抗压能力。 计算机视觉/机器学习【计算机视觉研究】 计算机、应用数学、模式识别、人工智能、自控、统计学、运筹学、生物信息、物理学/量子计算、神经科学、社会学/心理学等专业，图像处理、模式识别、机器学习相关研究方向，本科及以上，博士优先； 熟练掌握计算机视觉和图像处理相关的基本算法及应用； 较强的算法实现能力，熟练掌握 C/C++ 编程，熟悉 Shell/Python/Matlab 至少一种编程语言； 在计算机视觉、模式识别等学术会议或者期刊上发表论文、相关国际比赛获奖、及有相关专利者优先。 💯 复习刷题网站 cplusplus cppreference runoob leetcode | leetcode-cn lintcode nowcoder 📝 面试题目经验 牛客网 . 2020秋招面经大汇总！（岗位划分） 牛客网 . 【备战秋招】2020届秋招备战攻略 牛客网 . 2019校招面经大汇总！【每日更新中】 牛客网 . 2019校招技术类岗位面经汇总【技术类】 牛客网 . 2018校招笔试真题汇总 牛客网 . 2017秋季校园招聘笔经面经专题汇总 牛客网 . 史上最全2017春招面经大合集！！ 牛客网 . 面试题干货在此 知乎 . 互联网求职路上，你见过哪些写得很好、很用心的面经？最好能分享自己的面经、心路历程。 知乎 . 互联网公司最常见的面试算法题有哪些？ CSDN . 全面整理的C++面试题 CSDN . 百度研发类面试题（C++方向） CSDN . c++常见面试题30道 CSDN . 腾讯2016实习生面试经验（已经拿到offer) cnblogs . C++面试集锦( 面试被问到的问题 ) cnblogs . C/C++ 笔试、面试题目大汇总 cnblogs . 常见C++面试题及基本知识点总结（一） segmentfault . C++常见面试问题总结 📆 招聘时间岗位 牛客网 . 2020届校招 | 2020 IT名企校招日程 👍 内推 Github . CyC2018/Job-Recommend：🔎 互联网内推信息（社招、校招、实习） Github . amusi/AI-Job-Recommend：国内公司人工智能方向（含机器学习、深度学习、计算机视觉和自然语言处理）岗位的招聘信息（含全职、实习和校招） 👬 贡献者 🍭 支持赞助**Avalive**：一个面部捕捉的虚拟形象扮演软件。 📜 License本仓库遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/12/08/%E7%BD%91%E7%BB%9C%E4%B8%93%E4%B8%9A%E7%9B%B8%E5%85%B3/"},{"title":"Database","text":"数据库知识点整理 Term Review 第1章 绪论 了解 数据管理技术的产生和发展过程 数据库系统优点 层次数据模型及网状数据模型基本概念 数据库系统的组成 数据库管理员（DBA）的职责 掌握 概念模型的基本概念 关系数据模型的相关概念 数据库系统三级模式和两级映像的体系结构 数据库系统的逻辑独立性和物理独立性 知识点 数据、数据库、数据库管理系统、数据库系统 数据（Data）：描述事物的符号记录称为数据。数据与其语义是不可分的 数据库（Data Base）：数据库是长期储存在计算机内的、有组织的、可共享的数据集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。 数据库系统（Data Base System）：在计算机系统中引入数据库后的系统构成。一般由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员构成。 数据库管理系统（DataBase Management System）：数据库管理系统是位于用户与操作系统之间的一层数据管理软件，用于科学地组织和存储数据、高效地获取和维护数据。DBMS主要功能包括数据定义功能、数据操纵功能、数据库的运行管理功能、数据库的建立和维护功能。 数据库的数据具有【永久储存】、【有组织】、【可共享】三个基本特点 DBS包括DB、DBMS、DBA 使用数据库系统的好处 使用数据库系统的好处是由数据库管理系统的特点或优点决定的 可以大大提高应用开发的效率 当数据的逻辑结构需要改变时，开发人员不必修改应用程序，或者只需要修改很少的应用程序 可以减轻DBA维护系统的负担 便于数据的集中管理、控制数据冗余、提高数据的利用率和一致性，又有利于应用程序的开发和维护 文件系统与数据库系统的区别和联系 区别 文件系统面向某一应用程序、共享性差、冗余度大、数据独立性差、记录内有结构、整体无结构、由应用程序自己控制 数据库系统面向现实世界、共享度高、冗余度小、具有较高物理独立性和一定的逻辑独立性、整体结构化、用数据模型描述、由数据库管理系统提供数据的安全性、完整性、并发控制和恢复能力 联系 都是计算机系统中管理数据的软件 文件系统是操作系统的重要组成部分，而DBMS是独立于操作系统的软件。但是DBMS是在操作系统的基础上实现的，数据库中的数据的组织和存储是通过操作系统中的文件系统来实现的 适用于文件系统或数据库系统的例子 适用于文件系统：数据的备份、软件或应用程序使用过程中的临时数据存储；早期功能比较简单、比较固定的应用系统（照片、短信、微信） 适用于数据库系统：企业或部门的信息系统（人事管理系统、学生管理系统） 数据库系统特点 数据结构化（数据库系统与文件系统的本质区别） 数据共享性高，冗余度低，易扩充 数据独立性高 数据独立性包括数据的【物理独立性】和数据的【逻辑独立性】 【物理独立性】：用户的应用程序与数据库中数据的物理存储是相互独立的 【逻辑独立性】：用户的应用程序与数据库的逻辑结构是相互独立的 数据库管理系统的模式结构和二级映像功能保证了数据库中的数据具有很高的物理独立性和逻辑独立性。 数据由DBMS统一管理和控制。提供统一的数据控制功能 数据的安全性保护：保护数据以防止不合法的使用造成的数据的泄密和破坏 数据的完整性检查：将数据控制在有效的范围内或保证数据之间满足一定的关系 并发控制：对多用户的并发操作加以控制和协调，保证并发操作的正确性 数据库恢复：当计算机系统发生硬件故障、软件故障，或者由于操作员的失误以及故意的破坏影响数据库中数据的正确性，甚至造成数据库部分或全部数据的丢失时，能将数据库从错误状态恢复到某一已知的正确状态（亦称为完整状态或一致状态） 什么是数据库 数据库是长期存储在计算机内有组织的大量的共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。 DBMS在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性、安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对系统进行恢复。 数据库系统的出现使信息系统从以加工数据的程序为中心转向围绕共享的数据库为中心的新阶段。 DBMS的主要功能 数据库定义功能 数据组织、存储和管理功能 数据操纵功能 数据库的事务管理和运行管理 数据库的建立和维护功能 其他功能，如不同数据库之间的互访和互操作功能等 概念模型、逻辑模型和物理模型 概念模型实际上是现实世界到机器世界的一个中间层次。概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有力工具，也是数据库设计人员和用户之间进行交流的语言。 概念模型强调语义表达能力，简单清晰易于用户理解 逻辑模型（数据模型）：按计算机系统的观点对数据建模，用于数据库管理系统的实现。 物理模型：是对数据最底层的抽象，描述数据在系统内部的表示方法和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。 实体、实体型、实体集、实体之间的联系、属性、码、实体联系图（E-R图） 实体：客观存在并可相互区分的事物 实体型：用实体名及其属性名集合来抽象和刻画同类实体 实体集：同型实体的集合 实体之间的联系 实体（型）内部的联系：组成实体的各属性之间的联系 实体（型）之间联系：不同实体集之间的联系。一对一、一对多、多对多 属性：实体所具有的某一特性，一个实体可由若干个属性来刻画。 码：唯一标识实体的属性集称为码。 实体联系图（E-R图）：提供了表示实体型、属性和联系的方法 实体型：用矩形表示，矩形框内写明实体名。 属性：用椭圆形表示，并用无向边将其与相应的实体连接起来。 联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1 : 1，1 : n或m : n）。 数据模型、数据模型的作用、数据模型三要素 数据模型是数据库系统中最重要的概念之一。数据模型是数据库中用来对现实世界进行抽象的工具，是数据库中用于提供信息表示和操作手段的形式构架 一般地讲，数据模型是严格定义的概念的集合。这些概念精确地描述系统的静态特性、动态特性和完整性约束条件。 数据模型是数据库系统的基础。任何一个DBMS都以某一个数据模型为基础，或者说支持某一个数据模型 数据模型通常由【数据结构】、【数据操作】、【完整性约束条件】三部分组成 层次模型概念 有且只有一个结点没有双亲结点，这个节点称为根节点 根以外的其他结点有且只有一个双亲结点 网状模型概念 允许一个以上的结点无双亲 一个结点可以有多于一个的双亲 层次数据库、网状数据库的优缺点 层次数据库 优点 层次模型数据结构简单清晰 层次数据库查询效率高 层次数据模型提供了良好的完整性支持 缺点：现实世界很多联系是非层次性的，层次模型不能自然地表示这类联系 网状数据库 优点 能够更为直接地描述现实世界 具有良好的性能，存取效率较高 缺点 结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握。 网状数据库的数据定义语言（DDL）、数据操纵语言（DML）比较复杂，要求用户掌握数据库结构和存取路径，不容易使用 关系、属性、域、元组、码、分量、关系模式 关系模型由【关系数据结构】、【关系操作集合】、【关系完整性约束】三部分组成。在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成 关系：一个关系对应通常说的一张表 属性：表中的一列 域：属性的取值范围 元组：表中的一行 码：表中的某个属性组，它可以唯一确定一个元组 分量：元组中的一个属性值 关系模式：对关系的描述，一般表示为 关系名（属性1，属性2，…，属性n） 关系数据库的特点 优点 关系模型与非关系模型不同，它具有严格的数学基础 关系模型的概念单一 关系模型的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。 缺点：存取路径对用户透明，查询效率往往不如非关系数据模型 数据库系统三级模式、两级映像 三级模式结构由外模式、模式、内模式组成 外模式：亦称子模式或用户模式，局部数据的逻辑结构和特征的描述，是数据库用户的数据视图 模式：亦称逻辑模式，是数据库中全体数据的逻辑结构和特性的描述，是所有用户的公共数据视图。模式描述的是数据的全局逻辑结构。外模式通常是模式的子集 内模式：亦称存储模式，对数据的物理结构和存储方式的描述 两级映像：外模式/模式映像、模式/内模式映像。在内部实现了三个抽象层次的联系和转换，保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性 数据定义语言、数据操纵语言 数据定义语言：用来定义数据库模式、外模式和内模式的语言 数据操纵语言：用来对数据库中的数据进行查询、插入、删除和修改的语句 数据与程序的物理独立性、逻辑独立性 【数据与程序的物理独立性】：当数据库的存储结构改变了，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变，这就是数据与程序的物理独立性，简称数据的物理独立性。 【数据与程序的物理独立性】：当数据的逻辑结构即模式改变时，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变，从而应用程序不必修改，这就是数据与程序的逻辑独立性，简称数据的逻辑独立性。 DBMS在三级模式之间提供的两级映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。 数据库系统组成 数据库系统一般由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员构成。 数据库管理员、系统分析师、数据库设计人员、应用程序员的职责 数据库管理员：全面负责管理和控制数据库系统。具体职责包括: 决定数据库的信息内容和结构 决定数据库的存储结构和存取策略 定义数据的安全性要求和完整性约束条件 监控数据库的使用和运行 数据库系统的改进和重组重构 系统分析员：负责应用系统的需求分析和规范说明，他要和用户及DBA相结合，确定系统的硬件软件配置，并参与数据库系统的概要设计 数据库设计人员：负责数据库中数据的确定和数据库各级模式的设计。参加用户需求调查和系统分析，然后进行数据库设计 应用程序员：负责设计和编写应用程序的程序模块，并进行调试和安装 补充 数据库的核心和基础是【数据模型】 实现时将现实世界抽象为信息世界的是【概念模型】 文件系统阶段比人工管理阶段的优势是【数据可以长期保存】 保证数据库系统数据具有较高逻辑独立性的是【外模式/模式映像】 IBM公司的IMS数据库管理系统采用【层次模型】 DBMS是一类系统软件，建立在【操作系统】之上 网状数据库【一个结点可以由多于一个的双亲】 从逻辑模型到物理模型的转换一般由DBMS完成 长期存储在计算机内，有组织的、可共享的大量数据集合是【数据库】 【人工管理阶段】需要应用程序管理数据 通常情况下，外模式是模式的子集 通常按照数据结构的类型来命名数据模型 常用的数据模型有：层次模型、网状模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型 最经常使用的概念模型是【E-R图】 数据库管理系统提供的数据控制方面的功能包括：数据的【安全性】保护、数据的【完整性】检查、【并发控制】、数据库恢复 层次模型和网状模型中的单位是基本层次联系，这是指两个【记录(型)】以及它们之间的【一对多】（包括一对一）的联系 数据模型的组成要素中描述系统的静态特性和动态特性的分别是【数据结构】和【数据操纵】 试述数据管理的文件管理阶段和数据库系统阶段“数据独立性”有何不同？ 答：文件系统中数据被组织成相互独立的数据文件，程序按照文件名访问数据，“数据独立性”是一种“设备独立性”。数据库系统的“数据独立性”包括“物理独立性”和“逻辑独立性”，物理独立性是指用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的；逻辑独立性是指用户的应用与数据库的逻辑结构是相互独立的。 文件系统管理数据的缺点：数据共享性差，冗余度大；数据独立性差 三级模式中，描述数据库中全体数据的全局逻辑结构和特征的是【模式】 层次模型不能直接表示【m:n关系】 DBS是一个集合体，包含数据库、计算机硬件、软件和【数据库管理员】 数据库（DB），数据库系统（DBS）和数据库管理系统（DBMS）之间的关系是【DBS包括DB和DBMS】 【人工管理阶段】没有专门的软件对数据进行管理 【数据冗余度高】不属于数据库系统特点 数据库系统的数据独立性体现在【不会因为系统数据存储结构与数据逻辑结构的变化而影响应用程序】 要保证数据库的数据独立性，需要修改的是【三层之间的两种映射】 要保证数据库的逻辑数据独立性，需要修改的是【模式与外模式的映射】 用户或应用程序看到的那部分局部逻辑结构和特征的描述是【子模式】，它是模式的逻辑子集 【数据库管理系统设计】不是DBA数据库管理员的职责 给出三个实际部门的E-R图，要求实体型之间具有一对一，一对多，多对多各种不同的联系 第2章 关系数据库（重点） 了解：关系数据结构及形式化定义、关系操作、关系的完整性、关系代数 掌握 关系模型的三个组成部分及各部分所包括的主要内容 关系数据结构及其形式化定义 关系的三类完整性约束 关系代数及其运算，包括并、交、差、选择、投影、连接、除、广义笛卡儿积 知识点 关系模型三个组成部分 关系数据结构 关系操作集合 关系完整性约束 实体完整性规则：若属性A是基本关系R的主属性，则属性A不能取空值 参照完整性规则：若属性（或属性组）F是基本关系R的外码它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为： 或者取空值（F的每个属性值均为空值） 或者等于S中某个元组的主码值 用户定义的完整性：针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求 关系数据语言的特点和分类 关系代数语言 关系演算语言 具有关系代数和关系演算双重特点的语言 域、笛卡儿积、关系、元组、属性 域：域是一组具有相同数据类型的值的集合 笛卡儿积：D1D2…*Dn={(d1,d2,…,dn)|di∈Di,i=1,2,…,n} 关系：在域D1，D2，…，Dn上笛卡儿积D1D2…*Dn的子集，表示为R(D1,D2,…,Dn) 元组：关系中的每个元素是关系中的元组 属性：关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，对每列起一个名字，称为属性 候选码、主码、外码 候选码：若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码（candidate key） 主码：若一个关系有多个候选码，选定其中一个为主码（primary key） 外码：设F是基本关系R的一个或一组属性，但不是关系R的码，如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外部码（foreign key），简称外码 关系模式、关系、关系数据库 关系模式：关系的描述称为关系模式（relation schema）， 关系模式形式化表示为R(U，D，DOM，F)。R为关系名，U为组成该关系的属性名集合，D为属性组U中属性来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合 关系：在域D1，D2，…，Dn上笛卡儿积D1D2…*Dn的子集，表示为R(D1,D2,…,Dn) 关系是关系模式在某一时刻的状态或内容 关系数据库：关系数据库也有型和值之分。 关系数据库的型：称为关系数据库模式，是对关系数据库的描述，它包括若干域的定义以及在这些域上定义的若干关系模式。 关系数据库的值：是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。 关系模式和关系的区别 关系模式是型；关系是值，是关系模式的实例 关系模型的完整性规则 实体完整性规则：若属性A是基本关系R的主属性，则属性A不能取空值 参照完整性规则：若属性（或属性组）F是基本关系R的外码它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为： 或者取空值（F的每个属性值均为空值） 或者等于S中某个元组的主码值 用户定义的完整性：针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求 用关系代数完成查询 设有一个SPJ数据库，包括S，P，J，SPJ四个关系模式： S( SNO，SNAME，STATUS，CITY)； P(PNO，PNAME，COLOR，WEIGHT)； J(JNO，JNAME，CITY)； SPJ(SNO，PNO，JNO，QTY)； 供应商表S由供应商代码（SNO）、供应商姓名（SNAME）、供应商状态（STATUS）、供应商所在城市（CITY）组成；零件表P由零件代码（PNO）、零件名（PNAME）、颜色（COLOR）、重量（WEIGHT）组成；工程项目表J由工程项目代码（JNO）、工程项目名（JNAME）、工程项目所在城市（CITY）组成；供应情况表SPJ由供应商代码（SNO）、零件代码（PNO）、工程项目代码（JNO）、供应数量（QTY）组成，表示某供应商供应某种零件给某工程项目的数量为QTY。 求供应工程J1零件的供应商号码SNO： 求供应工程J1零件P1的供应商号码SNO： 求供应工程J1零件为红色的供应商号码SNO： 求没有使用天津供应商生产的红色零件的工程号JNO： 求至少用了供应商S1所供应的全部零件的工程号JNO： 等值连接与自然连接区别和联系 自然连接是一种特殊的等值连接，它要求两个关系中进行比较分量，即连接属性必须是相同的属性组，并且要在结果中去掉其中一个的重复属性 代数运算，用基本运算表示其他运算 基本运算 【并】：RUS仍为n目关系，由属于R或属于S的元组组成 【差】：R-S仍为n目关系，由属于R而不属于S的所有元组组成 【笛卡儿积】（全排列组合）：RS列：（n+m）列元组的集合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组，行：k1k2各元组 【投影】：从Ｒ中选择出若干属性列组成新的关系 πA(R) = { t[A] | t∈R } 例:查询学生的姓名和所在系，即求Student关系上学生姓名和所在系两个属性上的投影 πSname，Sdept(Student) 【选择】：在关系Ｒ中选择满足给定条件的诸元组 σF(R) = {t|t∈R∧F(t)= ‘真’} F：选择条件，是一个 例:查询信息系（IS系）全体学生 σSdept = ‘IS’ (Student) 其他运算 【交】：RnS仍为n目关系，由既属于R又属于S的元组组成 【连接】：从两个关系的笛卡儿积中选取属性间满足一定条件的元组 【除】：给定关系R(X，Y) 和S(Y，Z)，其中X，Y，Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在 X 属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合，R÷S = {tr[X] | tr∈R ∧ πY(S) 真包含于 Yx } 补充 关于关系模型 一个关系至少要有一个候选码 行、列的次序可以任意交换 一个列的值只能来自一个域 不同的列应有不同的列名 一个码是【可有多个或者一个其值能够唯一表示该关系模式中任何元组的属性组成】 实体以及实体之间的联系都可以使用相同的结构类型来表示 非主属性不可能出现在任何候选码中 候选码都可以唯一地标识一个元组 关系操作中，操作的对象和结果都是【集合】 “性别”属性要求只能取“男”/“女”，这属于【用户定义的完整性】 两个关系R（A，B，C）和S（B，C，D）自然连接，得到结果包含【4】列 在左外连接中，保留的是左边关系中所有的元组 在关系模型中，关系操作包括【查询】【插入】【修改】【删除】 关系模型包括8种查询操作，【并】【笛卡儿积】【选择】【投影】【差】是基本操作 职工（[职工号]，姓名，年龄，部门号）和部门（[部门号]，部门名称）存在引用关系，其中【职工】是参照关系，【部门号】是外码 候选码和主码的关系 若关系中的某一属性组的值能唯一标识一个元组，该属性组称为候选码 如果一个关系有多个候选码，其中一个被选为主码 候选码可以有多个，主码是其中的一个 什么是关系完备性？关系演算在语言表达能力上是完备的吗？ 关系完备性是指一个查询语言能够表示关系代数可以表示的所有查询。 关系演算具有完备的表达能力 现有如下关系：患者（患者编号，患者姓名，性别，出生日起，所在单位）；医疗（患者编号，患者姓名，医生编号，医生姓名，诊断日期，诊断结果）其中，医疗关系中的外码是【医生编号和患者编号】 现有一个关系：借阅（书号，书名，库存数，读者号，借期，还期），假如同一本书允许一个读者多次借阅，但不能同时对一种书借多本，则该关系模式的外码是【书号+读者号+借期】 关系模型中实现实体间 N：M 联系是通过增加一个【关系】实现 关系代数运算是以【集合运算】为基础的运算 关系数据库管理系统应能实现的专门关系运算包括【选择、投影、连接】 五种基本关系代数运算是【∪ － × σ π】 关系代数表达式的优化策略中，首先要做的是【尽早执行选择运算】 关系数据库中的投影操作是指从关系中【抽出特定字段】 从一个数据库文件中取出满足某个条件的所有记录形成一个新的数据库文件的操作是【选择】操作 关系代数中的连接操作是由【选择和笛卡尔积】操作组合而成 自然连接是构成新关系的有效方法。一般情况下，当对关系R和S是用自然连接时，要求R和S含有一个或者多个共有的【属性】 假设有关系R和S，在下列的关系运算中，【R×S】运算不要求：“R和S具有相同的元数，且它们的对应属性的数据类型也相同” 假设有关系R和S，关系代数表达式R－（R－S）表示的是【R∩S】 有关系SC（S_ID，C_ID，AGE，SCORE），查找年龄大于22岁的学生的学号和分数，正确的关系代数表达式是【πS_ID，SCORE (σ age&gt;22 (SC) ) 】【πS_ID，SCORE (σ age&gt;22 (πS_ID，SCORE，AGE (SC) ) ) 】 下面四个关系表达式是等价的，是判别它们的执行效率【E3最快】E1 =πA (σ B=C ∧ D=E′ (R×S) )E2 =πA (σ B=C (R× σD=E′ (S) )E3 =πA (R∞B=CσD=E′(S) )E4 =πA (σD=E′ (R∞B=C S) ) 综合题 第3章 关系数据库标准语言SQL（重点） 了解 SQL语言发展过程 关系数据库技术和关系数据库管理系统RDBMS产品的发展过程 掌握 SQL语言的特点和优点 面向过程的语言和SQL语言的区别 关系数据库系统为数据库应用系统的开发提供良好环境，减轻了用户负担，提高用户生产率的原因 用SQL语言完成对数据库的增删改查，特别是各种查询 知识点 SQL的特点 综合统一。SQL语言集数据定义语言DDL、数据操纵语言DML、数据控制语言DCL的功能于一体 高度非过程化。用 SQL 语言进行数据操作， 只要提出 “做什么”，而无需指明 “怎么做”，因此无需了解存取路径，存取路径的选择以及 SQL 语句的操作过程由系统自动完成。 面向集合的操作方式。 SQL 语言采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。 以同一种语法结构提供两种使用方式。 sQL 语言既是自含式语言，又是嵌入式语言。作为自含式语言， 它能够独立地用于联机交互的使用方式； 作为嵌入式语言， 它能够嵌入到高级语言程序中，供程序员设计程序时使用。 语言简捷，易学易用。 在DROP TABLE时，RESTRICT和CASCADE的区别 RESTRICT表示表的删除是有限制条件的。要删除的基本表不能被其他表的约束所引用，不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则表不能被删除 CASCADE表示表的删除没有限制条件，在删除基本表的同时，相关的依赖对象（如视图）都将被删除 有两个关系S（A，B，C，D）和T（C，D，E，F），写出与下列查询等价的SQL表达式 (1)SELECT * FROM S WHERE A=10 (2)SELECT DISTINCT A,B FROM S (3)SELECT A,B,S.C,S.D,E,F FROM S,T WHERE S.C=T.C AND S.D=T.D (4)SELECT A,B,S.C,S.D,T.C,T.D,E,F FROM S,T WHERE S.C=T.C (5)SLEECT A,B,S.C,S.D,T.C,T.D,E,F FROM S,T WHERE A&lt;E (6)SELECT S1.C,S1.D,T.C,T.D,E,F FROM T,(SELECT DISTINCT C,D FROM S) AS S1 用SQL语句建立第2章习题6中的4个表，针对建立的4个表用SQL语言完成第2章习题6中的查询 建S表 S(SNO,SNAME,STATUS,CITY);​CREATE TABLE S(SNO CHAR(3).​ SNAME CHAR(10), STATUS CHAR(2), CITY CHAR(10)​​​)​; 建P表 P(PNO,PNAME,COLOR,WEIGHT);CREATE TABLE P(PNO CHAR(3), PNAME CHAR(10), COLOR CHAR(4), WEIGHT INT​​​);​ 建J表 J(JNO,JNAME,CITY);CREATE TABLE J(JNO CHAR(3), JNAME CHAR(10),CITY CHAR(10)​​);​ 建SPJ表 SPJ(SNO,PNO,JNO,QTY);CREATE TABLE SPJ(SNO CHAR(3), PNO CHAR(3),JNO CHAR(3), QTY INT​​​);​ 求供应工程J1零件的供应商号码SNOSELECT SNO​FROM SPJWHERE JNO=’J1’;​ 求供应工程J1零件P1的供应商号码SNOSELECT SNOFROM SPJWHERE JNO=’J1’ AND PNO=’P1’;​​ 求供应工程J1零件为红色的供应商号码SNOSELECT SNOFROM SPJWHERE JNO=’J1’ AND PNO IN (SELECT PNO FROM P WHERE COLCO=‘红’​​);或SELECT SNOFROM SPJ,PWHERE JNO=’J1’ AND SPJ.PNO=P.PNO AND COLOR=’红’;​​​​​​​​​ 求没有使用天津供应商生产的红色零件的工程号JNOSELECT JNOFROM JWHERE NOT EXISTS (SELECT * ​FROM SPJ WHERE SPJ.JNO=J.JNO AND SNO IN (SELECT SNO FROM S WHERE CITY=’天津’​​) AND​ PNO IN (SELECT PNO FROM P WHERE COLOR=’红’​​)​​​​);​​​或SELECT JNOFROM JWHERE NOT EXISTS (SELECT * FROM SPJ,S,P WHERE SPJ.JNO=J.JNO AND SPJ.SNO=S.SNO AND SPJ.PNO=P.PNO AND S.CITY=’天津’ AND P.COLOR=’红’​​​);​​​​​ 求至少用了供应商S1所供应的全部零件的工程号JNOSELECT DISTINCT JNOFROM SPJ SPJZWHERE NOT EXISTS (SELECT * ​FROM SPJ SPJX WHERE SNO=’S1’​ AND NOT EXISTS​ (SELECT * FROM SPJ SPJY WHERE SPJY.PNO=SPJX.PNO AND SPJY.JNO=SPJZ.JNO​​​)​);​​​ 针对习题3中的4个表，用SQL语言完成以下各项操作 找出所有供应商的姓名和所在城市。SELECT SNAME,CITY ​FROM S； 找出所有零件的名称、颜色、重量。SELECT PNAME,COLOR,WEIGHT ​FROM P； 找出使用供应商 S1 所供应零件的工程号码。SELECT DIST JNO ​FROM SPJ ​WHERE SNO=’S1’； 找出工程项目 J2 使用的各种零件的名称及其数量。SELECT P.PNAME,SPJ.QTY ​FROM P,SPJWHERE P.PNO=SPJ.PNO ​AND SPJ.JNO=’J2’;​ 找出上海厂商供应的所有零件号码。SELECT DISTINCT PNO ​FROM SPJ​WHERE SNO IN (SELECT SNO FROM S WHERE CITY=’上海’​​);​ 找出使用上海产的零件的工程名称。SELECT JNAME ​FROM SPJ,S,JWHERE S.SNO=SPJ.SNO AND S.CITY=’ 上海 ‘ AND J.JNO=SPJ.JNO或​SELECT JNAME FROM J WHERE JNO IN (SELECT JNO FROM SPJ, S WHERE SPJ. SNO=S.SNO AND S.CITY=’上海’); 找出没有使用天津产的零件的工程号码。SELECT JNO FROM J WHERE NOT EXISTS (SELECT * FROM SPJ WHERE SPJ.JNO=J.JNO AND SNO IN (SELECT SNO FROM S WHERE CITY=‘天津’))； 或 SELECT JNO FROM J WHERE NOT EXISTS (SELECT *1 FROM SPJ, S WHERE SPJ.JNO=J.JNO AND SPJ.SNO=S.SNO AND ​S.CITY=‘天津’)；​ 把全部红色零件的颜色改成蓝色。UPDATE P SET COLOR=’蓝’ WHERE COLOR=’红’ ; ​ 由S5供给J4的零件P6改为由S3供应，请作必要的修改。UPDATE SPJ SET SNO=’S3’ WHERE SNO=’S5’ AND JNO=’J4’ AND PNO=’P6’; ​ 从供应商关系中删除S2的记录，并从供应情况关系中删除相应的记录。DELETE FROM SPJ WHERE SNO=’S2’; 或 DELETE FROM S WHERE SNO=’S2’; ​注意删除顺序，应该先从SPJ表中删除供应商S2所供应零件的记录，然后从从S表中删除S2。 请将 (S2，J6，P4，200) 插入供应情况关系。INSERT INTOSPJ(SNO, JNO, PNO, QTY) VALUES (S2，J6，P4，200); 或 INSERT INTO SPJ VALUES (S2，P4，J6，200); 基本表、视图，两者的区别和联系 基本表是本身独立存在的表，在SQL中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表。即数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。视图在概念上与基本表等同，用户可以如同基本表那样使用视图，可以在视图上再定义视图。 视图的优点 视图能够简化用户的操作。 视图使用户能以多种角度看待同一数据。 视图对重构数据库提供了一定程度的逻辑独立性。 视图能够对机密数据提供安全保护。 所有的视图是否都可以更新？为什么？ 不是。视图是不实际存储数据的虚表，因此对视图的更新，最终要转换为对基本表的更新。因为有些视图的更新不能唯一地有意义地转换成对相应基本表的更新，所以，并不是所有的视图都是可更新的。如《概论》3.5.1中的视图S_G（学生的学号及他的平均成绩）CREAT VIEW S_G(Sno，Gavg)AS SELECT Sno，AVG(Grade)FROM SCGROUP BY Sno； 要修改平均成绩，必须修改各科成绩，而我们无法知道哪些课程成绩的变化导致了平均成绩的变化。 哪类视图是可以更新的，哪类视图是不可更新的？ 各举一例说明 基本表的行列子集视图一般是可更新的。如《概论》3.5.3中的例1。 若视图的属性来自集函数、表达式，则该视图肯定是不可以更新的。如《概论》3.5.3中的S_G视图。 综合题 请为三建工程项目建立一个供应情况的视图，包括供应商代码（SNO）、零件代码（PNO）、供应数量（QTY）。针对该视图完成下列查询：（1）找出三建工程项目使用的各种零件代码及其数量。（2）找出供应商S1的供应情况。 建视图CREATE VIEW V_SPJ ASSELECT SNO, PNO, QTYFROM SPJWHERE JNO=（SELECT JNOFROM JWHERE JNAME=’三建’）; 对该视图查询(1) 找出三建工程项目使用的各种零件代码及其数量。SELECT PNO, QTYFROM V_SPJ;(2) 找出供应商S1的供应情况。SELECT PNO, QTY FROM V_SPJWHERE SNO=’S1’; 补充 SQL是【非过程化】的语言，用户无须指定存取路径 对表中数据进行删除的操作是【DELECT】 数据库中建立索引的目的是为了【加快存取速度】 视图是数据库系统三级模式中的【外模式】 基本表和视图一样，都是关系 可以使用SQL对基本表和视图进行操作 可以从基本表或视图上定义视图，视图不仅可以从单个基本表导出，还可以从多个基本表导出 视图不存储数据 SELECT子句中的目标列可以是表中的属性列，也可以是表达式 使用ANY或ALL谓词时必须与比较运算符同时使用 SQL语言具有【数据定义】【数据查询】【数据操纵】【数据控制】的功能 SQL语句中用来消除重复的关键词是【DISTINCT】 若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和列，但保留了主码，这类视图称为【行列子集视图】 SQL语言的数据定义功能包括【模式定义】【表定义】【视图定义】【索引定义】 在视图上不能完成的操作是【在视图上定义新的表】 CREATE、DROP、ALTER实现【数据定义】功能 删除一个视图的命令是【DROP】 删除表S的命令是【DROP TABLE S】 在基本表S中增加一列CN（课程名），可用【ALTER TABLE S ADD (CN CHAR(8))】 在基本表S中删除一个属性“年龄”，可用【ALTER TABLE S DROP Age】 有关系S（S＃，SNAME，SAGE），C（C＃，CNAME），SC（S＃，C＃，GRADE）。其中S＃是学生号，SNAME是学生姓名，SAGE是学生年龄， C＃是课程号，CNAME是课程名称。要查询选修“ACCESS”课的年龄不小于20的全体学生姓名的SQL语句是SELECT SNAME FROM S，C，SC WHERE子句。这里的WHERE子句的内容是【S.S# = SC.S# and C.C# = SC.C# and SAGE&gt;=20 and CNAME=‘ACCESS’】 设关系数据库中一个表S的结构为S（SN，CN，grade），其中SN为学生名，CN为课程名，二者均为字符型；grade为成绩，数值型，取值范围0－100。若要把“张二的化学成绩80分”插入S中，则可用【INSERT INTO S VALUES（’张二’，’化学’，80）】 设关系数据库中一个表S的结构为：S（SN，CN，grade），其中SN为学生名，CN为课程名，二者均为字符型；grade为成绩，数值型，取值范围0－100。若要更正王二的化学成绩为85分，则可用【UPDATE S SET grade＝85 WHERE SN＝’王二’ AND CN＝’化学’】 在SQL语言中，子查询是【嵌入到另一个查询语句之中的查询语句】 SQL是一种【关系数据库】语言 有关系S（S＃，SNAME，SEX），C（C＃，CNAME），SC（S＃，C＃，GRADE）。其中S＃是学生号，SNAME是学生姓名，SEX是性别， C＃是课程号，CNAME是课程名称。要查询选修“数据库”课的全体男生姓名的SQL语句是SELECT SNAME FROM S，C，SC WHERE子句。这里的WHERE子句的内容是【A.S.S# = SC.S# and C.C# = SC.C# and SEX=’男’ and CNAME=’数据库’】 CREATE TABLE SC （S# CHAR（6） NOT NULL，C# CHAR（3） NOT NULL，SCORE INTEGER，NOTE CHAR（20））；向SC表插入如下行时，【（’200823’，’101’，NULL，NULL）】行可以被插入 假设学生关系S（S＃，SNAME，SEX），课程关系C（C＃，CNAME），学生选课关系SC（S＃，C＃，GRADE）。要查询选修“Computer”课的男生姓名，将涉及到关系【S，C，SC】 【GRANT】不是数据定义语句 相关子查询和不相关子查询 在嵌套查询中，如果子查询的查询条件不依赖于父查询，称为不相关子查询 如果子查询的查询条件依赖于父查询，称为相关子查询 ANY和ALL谓词与聚集函数或IN谓词可能存在的等价转换关系 综合题 关系R包含A、B、C三个属性，包含的数据如下 写出对查询语句SELECT * FROM R WHERE X；当X为下列条件时的查询结果 A IS NULL空的结果集 A&gt;8 AND B&lt;20空的结果集 A&gt;10 OR B&lt;20 C+10&gt;25 EXISTS(SELECT B FROM R WHERE A=10) C IN (SELECT B FROM R)空的结果集 第4章 数据库安全性 了解 计算机系统安全性问题 数据库安全性问题 威胁数据库安全性因素 掌握 TCSEC和CC标准的主要内容 C2级DBMS、B1级DBMS的主要特征 DBMS提供的安全措施 用户身份鉴别、自主存取控制、强制存取控制技术 视图技术和审计技术 数据加密存储和加密传输 使用SQL语言中的GRANT语句和REVOKE语句来实现自主存取控制 知识点 什么是数据库的安全性 数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏 举例说明对数据库安全性产生威胁的因素 非授权用户对数据库的恶意存取和破坏 数据库中重要或敏感的数据被泄露 安全环境的脆弱性 信息安全标准的发展历史，CC评估保证级划分的基本内容 TCSEC/TDI 安全级别划分 安全级别 定义 A1 验证设计（verified design） B3 安全域（security domains） B2 结构化保护（structural protection） B1 标记安全保护（labeled security protection） C2 受控的存取保护（controlled access protection） C1 自主安全保护（discretionary security protection） D 最小保护（minimal protection） CC评估保证级（EAL）的划分 评估保证级 定义 TCSEC安全级别（近似相当） EAL1 功能测试（functionally tested） EAL2 结构测试（structurally tested） C1 EAL3 系统地测试和检查（methodically tested and checked） C2 EAL4 系统地设计、测试和复查（methodically designed，tested and reviewed） B1 EAL5 半形式化设计和测试（semiformally designed and tested） B2 EAL6 半形式化验证的设计和测试（semiformally verified design and tested） B3 EAL7 形式化验证的设计和测试（formally verified design and tested） A1 实现数据库安全性控制的常用方法和技术 用户身份鉴别该方法由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供系统的使用权。 多层存取控制通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未被授权的人员无法存取数据。例如C2级中的自主存取控制（DAC），B1级中的强制存取控制（MAC） 视图机制为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护 审计建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中， DBA可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等 数据加密对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容 数据库自主存取控制方法和强制存取方法 自主存取控制方法：定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。 强制存取控制方法：每一个数据对象被（强制地）标以一定的密级，每一个用户也被（强制地）授予某一个级别的许可证。系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象。 自主存取控制中自主的含义是：用户可以将自己拥有的存取权限“自主”地授予别人。即用户具有一定的“自主”权。 SQL语言中提供了哪些数据控制（自主存取控制）的语句？请试举几例说明它们的使用方法。 SQL中 的自主存取控制是通过GRANT 语句和 REVOKE 语句来实现的。如：GRANT SELECT， INSERT ON Student TO 王平 WITH GRANT OPTION； 就将Student表的SELECT和INSERT权限授予了用户王平，后面的“WITH GRANT OPTION”子句表示用户王平同时也获得了“授权”的权限，即可以把得到的权限继续授予其他用户。REVOKE INSERT ON Student FROM 王平 CASCADE； 就将Student表 的INSERT权限从用户王平处收回，选项 CASCADE 表示，如果用户王平将Student 的 INSERT 权限又转授给了其他用户，那么这些权限也将从其他用户处收回。 使用GRANT完成下列授权功能 学生（学号，姓名，年龄，性别，家庭住址，班级号）班级（班级号，班级名，班主任，班长） 授予用户U1拥有对两个表的所有权限，并可给其他用户授权GRANT ALL PRIVILEGES ON TABLE 学生,班级 TO U1 WITH GRANT OPTION; 授予用户U2对学生表具有查看权限，对家庭住址具有更新权限GRANT SELECT,UPDATE(家庭住址) ON TABLE 学生 TO U2; 将对班级表查看权限授予所有用户GRANT SELECT ON TABLE 班级 TO PUBLIC; 将对学生表的查询、更新权限授予角色R1GRANT SELECT,UPDATE ON TABLE 学生 TO R1; 将角色R1授予用户U1，并且U1可继续授权给其他角色GRANT R1 TO U1 WITH ADMIN OPTION; 用GRANT和REVOKE语句（加上视图机制）完成以下授权定义或存取控制功能以及权限撤销 职工（职工号，姓名，年龄，职务，工资，部门号）部门（部门号，名称，经理名，地址，电话号） 用户王明对两个表有SELECT权限GRANT SELECT ON TABLE 职工,部门 TO 王明;REVOKE SELECT ON TABLE 职工,部门 FROM 王明; 用户李勇对两个表有INSERT和DELETE权限GRANT INSERT,DELETE ON TABLE 职工,部门 TO 李勇;REVOKE INSERT,DELETE ON TABLE 职工,部门 FROM 李勇;​ 每个职工只对自己的记录有SELECT权限GRANT SELECT ON TABLE 职工 WHEN USER()=NAME TO ALL;/这里假定系统的GRANT语句支持WHEN子句和USER()的使用。用户将自己的名字作为ID。/​​REVOKE SELECT ON TABLE 职工 WHEN USER()=NAME FROM ALL; 用户刘星对职工表有SELECT权限，对工资字段具有更新权限GRANT SELECT,UPDATE(工资) ON TABLE 职工 TO 刘星;REVOKE SELECT,UPDATE(工资) ON TABLE 职工 FROM 刘星;​ 用户张新具有修改这两个的结构的权限GRANT ALTER TABLE ON TABLE 职工,部门 TO 张新;REVOKE ALTER TABLE ON TABLE 职工,部门 FROM 张新;​ 用户周平具有对两个表的所有权限（读，插、改、删数据），并具有给其他用户授权的权限GRANT ALL PRIVILEGES ON TABLE 职工,部门 TO 周平 WITH GRANT OPTION;REVOKE ALL PRIVILEGES ON TABLE 职工,部门 FROM 周平; 用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限，他不能查看每个人的工资/首先建立一个视图，然后对这个视图定义杨兰的存取权限/GRANT VIEW 部门工资 ASSELECT 部门.名称,MAX(工资),MIN(工资),AVG(工资)FROM 职工,部门WHERE 职工.部门号=部门.部门号GROUP BY 职工.部门号;GRANT SELECT ON TABLE 部门工资 TO 杨兰;​​​​​​​REVOKE SELECT ON TABLE 部门工资 FROM 杨兰;​​​​​​DROP VIEW 部门工资;​ 理解并解释MAC机制中主体、客体、敏感度标记的含义 主体是系统中的活动实体，既包括DBMS所管理的实际用户，也包括代表用户的各进程 客体是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引、视图等 对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记。敏感度标记被分成若干级别，如绝密、机密、可信、公开等。主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级 强制存取控制机制是如何确定主体能否存取客体 假设要对关系变量S进行强制存取控制，为简化起见，假设要控制存取的数据单元是元组，则每个元组标以密级，如下表所示（4=绝密，3=机密，2=秘密） 假设系统的存取规则是 仅当主体的许可证级别大于或等于客体的密级时才能读取相应的客体 仅当主体的许可证级别小于或等于客体的密级时才能写相应的客体 假定用户U1和U2的许可证级别分别为3和2，则根据规则用户U1能读元组S1和S2，可修改元组S2；用户U2只能读元组S1，修改元组S1 什么是数据库的审计功能，为什么要提供审计功能 审计功能是指DBMS的审计模块在用户对数据库执行操作的同时，把所有操作自动记录到系统的审计日志中 因为任何系统的安全保护措施都不是完美无缺的，蓄意盗窃破坏数据的人总可能存在。利用数据库的审计功能，审计员可以根据审计日志中记录的信息，分析和重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等 补充 强制存取控制策略是TCSEC/TDI【B1】级安全级别的特色 SQL的GRANT和REVOKE语句可以用来实现【自主存取控制】 在强制存取控制机制中，当主体的许可证级别等于客体的密级时，主体可以对客体进行【读取、写入】 数据库安全技术包括【用户身份鉴别】【自主存取控制和强制存取控制】【视图】【审计】【数据加密】 在数据加密技术中，原始数据通过某种加密算法变换为不可直接识别的格式，称为【密文】 数据库角色实际上是一组与数据库操作相关的各种【权限】 在对用户授予列INSERT权限时，一定要包含对【主码】的INSERT权限，否则用户的插入会因为空值被拒绝。除了授权的列，其他列的值或者取【空值】，或者为【默认值】 【出入机房登记和加锁】不属于实现数据库系统安全性主要技术和方法 SQL中的视图提高了数据库系统的【安全性】 SQL语言的GRANT和REMOVE语句主要是用来维护数据库的【安全性】 在数据库的安全性控制中，授权的数据对象的【范围越小】，授权子系统就越灵活 第5章 数据库完整性 了解 数据库的完整性约束条件 完整性约束条件分类 数据库完整性概念与数据库安全性概念的区别和联系 掌握 DBMS完整性控制机制的三个方面 完整性约束条件的定义 完整性约束条件的检查和违约处理 使用触发器实现数据库完整性的方法 用SQL语言定义关系模式的完整性约束条件 定义每个模式的主码 定义参照完整性 定义于应用有关的完整性 知识点 什么是数据库的完整性 数据库的完整性是指数据的【正确性】和【相容性】 数据库完整性概念与数据库安全性概念的区别和联系 数据库的完整性和安全性是两个不同的概念，但是有一定的联系 前者是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出，即所谓垃圾进垃圾出（Garbage In Garbage Out）所造成的无效操作和错误操作 后者是保护数据库防止恶意的破坏和非法的存取。 也就是说，安全性措施的防范对象是【非法用户和非法操作】，完整性措施的防范对象是【不合语义的数据】 什么是数据库的完整性约束条件，分类 完整性约束条件是指数据库中的数据应该满足的语义约束条件 一般可以分为六类 静态列级约束、静态元组约束、静态关系约束、动态列级约束、动态元组约束、动态关系约束。 静态列级约束是对一个列的取值域的说明，包括以下几方面： 对数据类型的约束，包括数据的类型、长度、单位、精度等 对数据格式的约束 对取值范围或取值集合的约束。 对空值的约束 其他约束 静态元组约束就是规定组成一个元组的各个列之间的约束关系，静态元组约束只局限在单个元组上。 静态关系约束是在一个关系的各个元组之间或者若干关系之间常常存在各种联系或约束。常见的静态关系约束有： 实体完整性约束。 参照完整性约束。 函数依赖约束。 动态列级约束是修改列定义或列值时应满足的约束条件，包括下面两方面： 修改列定义时的约束 修改列值时的约束 动态元组约束是指修改某个元组的值时需要参照其旧值，并且新旧值之间需要满足某种约束条件。 动态关系约束是加在关系变化前后状态上的限制条件，例如事务一致性、原子性等约束条件。 DBMS的完整性控制机制应具有哪三个方面的功能 定义功能，即提供定义完整性约束条件的机制 检查功能：即检查用户发出的操作请求是否违背了完整性约束条件 违约处理功能：如果发现用户的操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性 RDBMS在实现参照完整性时需要考虑哪些方面 RDBMS在实现参照完整性时需要考虑可能破坏完整性的各种情况以及用户违约后的处理策略 外码是否可以接受空值 删除被参照关系的元组时的考虑，这时系统可能采取的作法有三种 级联删除（CASCADES） 受限删除（RESTRICTED） 置空值删除（NULLIFIES） 在参照关系中插入元组时的问题，这时系统可能采取的作法有 受限插入 递归插入 修改关系中主码的问题 一般是不能用UPDATE语句修改关系主码的。如果需要修改主码值，只能先删除该元组，然后再把具有新主码值的元组插入到关系中。 如果允许修改主码，首先要保证主码的唯一性和非空，否则拒绝修改。然后要区分是参照关系还是被参照关系。 用SQL语言定义这两个关系模式，要求在模式中完成以下完整性约束条件的定义 职工（[职工号]，姓名，年龄，职务，工资，部门号）部门（[部门号]，名称，经理名，电话） 定义每个模式的主码 定义参照完整性 定义职工年龄不得超过60岁CREATE TABLE DEPT (Deptno NUMBER(2) PRIMARY KEY, Deptname VARCHAR(10), Manager VARCHAR(10), PhoneNumber CHAR(12)​​​​)​;CREATE TABLE EMP (Empno NUMBER(4) PRIMARY KEY, Ename VARCHAR(10), Age NUMBER(2), Job VARCHAR(9), Sal NUMBER(7,2), Deptno NUMBER(2), CONSTRAINT C1 CHECK(Age&lt;=60), CONSTRAINT FK_DEPTNO FOREIGN KEY(Deptno) REFERENCES DEPT(Deptno)​​​​​​​​);​​​ 在关系系统中，当操作违反实体完整性、参照完整性和用户定义的完整性约束条件时，一般是如何分别进行处理的 对于违反实体完整性和用户定义的完整性的操作，一般都采用拒绝执行的方式进行处理； 而对于违反参照完整性的操作，并不都是简单地拒绝执行，有时要根据应用语义执行一些附加的操作，以保证数据库的正确性 某单位想举行一个小型的联谊会，关系Male记录注册的男宾信息，关系Female记录注册的女宾信息。建立一个断言，将来宾的人数限制在50人以内 CREATE TABLE Male (SerialNumber SmallInt PRIMARY KEY, Name CHAR(8), Age SmallInt, Occuptation CHAR(20) );CREATE TABLE Female (SerialNumber SmallInt PRIMARY KEY, Name CHAR(8), Age SmallInt, Occuptation CHAR(20) );CREATE ASSERTION Party /建立断言PARTY/CHECK((SELECT COUNT() FROM Male)+(SELECT COUNT() FROM Female)&lt;=50); 补充 定义关系的主码意味着主码属性【唯一且所有主码属性不为空】 关于语句CREATE TABLE R(no int,sum int CHECK(sum&gt;0))和CREATE TABLE R(no int,sum int,CHECK(sum&gt;0))，【两条语句都合法且约束效果一样】【前者定义了属性上的约束条件，后者定义了元组上的约束条件】【当sum属性改变时检查，上述两种CHECK约束都要被检查】 在CREATE TABLE时，用户定义的完整性可以通过【NOT NULL】【UNIQUE】【CHECK】等子句实现 关系R的属性A参照引用关系T的属性A，T的某条元组对应的A属性值在R中出现，当要删除T的这条元组时，系统可以采用的策略包括【拒绝执行】【级联删除】【设为空值】 定义数据库完整性一般是由SQL的【DDL】语句实现的 【GRANT】是SQL语言中的数据控制命令 【REFERENCES】允许用户定义新关系时，引用其他关系的主码作为外码 综合题 第6章 关系数据理论（重点） 了解 “不好”的数据库模式 模式的插入异常和删除异常 规范化理论的重要意义 掌握 关系的形式化定义 数据依赖的基本概念（函数依赖、平凡/非平凡/部分/完全/传递函数依赖，码、候选码、外码、多值依赖） 范式的概念，1NF-4NF，规范化的含义和作用 4个范式的理解与应用 各个级别范式中存在的问题和解决方法（插入异常，删除异常，数据冗余） 根据应用语义完整地写出关系模式的数据依赖集合，根据数据依赖分析某一个关系模式属于第几范式 知识点 函数依赖、部分函数依赖、完全函数依赖、传递依赖、候选码、主码、外码、全码、1NF、2NF、3NF、BCNF、多值依赖、4NF 函数依赖：设R (U)是一个关系模式，U是R的属性集合，X和Y是U的子集。对于R (U)的任意一个可能的关系r，如果r中不存在两个元组，它们在X上的属性值相同， 而在Y上的属性值不同， 则称”X函数确定Y”或”Y函数依赖于X”，记作X→Y 函数依赖是最基本的一种数据依赖，也是最重要的一种数据依赖。 函数依赖是属性之间的一种联系，体现在属性值是否相等。由上面的定义可以知道，如果X→Y，则r中任意两个元组，若它们在X上的属性值相同，那么在Y上的属性值一定也相同。 我们要从属性间实际存在的语义来确定他们之间的函数依赖，即函数依赖反映了（描述了）现实世界的一种语义。 函数依赖不是指关系模式R的在某个时刻的关系（值）满足的约束条件，而是指R任何时刻的一切关系均要满足的约束条件 完全函数依赖、部分函数依赖：在R（U）中，如果X→Y，并且对于X的任何一个真子集X，都有X′→Y，则称Y对X完全函数依赖;若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖 候选码、主码： 设K为R(U，F)中的属性或属性组合，若K → U则K为R的候选码。若候选码多于一个，则选定其中的一个为主码 外码：关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码也称外码 全码：整个属性组是码，称为全码（All-key） 1NF：如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF 第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库 2NF：若关系模式R∈1NF，并且每一个非主属性都完全依赖于R的码，则R∈2NF 3NF：关系模式R&lt;U，F&gt;中若不存在这样的码X，属性组Y及非主属性Z（Z不包含于Y）使得X→ Y，（Y不→ X），Y→ Z成立，则称R&lt;U，F&gt;∈3NF BCNF：关系模式R&lt;U，F&gt;∈1NF.若X→ Y且（Y不包含于X）时X必含有码，则R&lt;U，F&gt;∈BCNF 多值依赖：设R (U)是属性集U上的一个关系模式，X、Y、Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X→ → Y成立，当且仅当对R(U)的任一关系r，给定的一对(x，z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关 4NF：关系模式R&lt;U，F&gt;∈1NF，如果对于R的每个非平凡多值依赖X→ → Y（Y不包含于X），X都含有码，则称R&lt;U，F&gt;∈4NF 综合题 建立一个关于系、学生、班级、学会等诸信息的关系数据库。 描述学生的属性有：学号、姓名、出生年月、系名、班号、宿舍区。 描述班级的属性有：班号、专业名、系名、人数、入校年份。 描述系的属性有：系名、系号、系办公室地点、人数。 描述学会的属性有：学会名、成立年份、地点、人数。 有关语义如下：一个系有若干专业，每个专业每年只招一个班，每个班有若干学生。一个系的学生住在同一宿舍区。每个学生可参加若干学会，每个学会有若干学生。学生参加某学会有一个入会年份。 请给出关系模式，写出每个关系模式的极小函数依赖集，指出是否存在传递函数依赖，对于函数依赖左部是多属性的情况讨论函数依赖是完全函数依赖，还是部分函数依赖。 指出各关系的候选码、外部码，有没有全码存在？ 关系模式 学生S（S#，SN，SB，DN，C#，SA）S#—学号，SN—姓名，SB—出生年月，SA—宿舍区 班级C（C#，CS，DN，CNUM，CDATE） C#—班号，CS—专业名，CNUM—班级人数，CDATE—入校年份 系 D（D#，DN，DA，DNUM）D#—系号，DN—系名，DA—系办公室地点，DNUM—系人数 学会P（PN，DATE1，PA，PNUM）PN—学会名，DATE1—成立年月，PA—地点，PNUM—学会人数 学生–学会SP（S#，PN，DATE2）DATE2—入会年份 每个关系模式的极小函数依赖集 S：S#→SN，S#→SB，S#→C#，C#→DN，DN→SA C：C#→CS，C#→CNUM，C#→CDATE，CS→DN，(CS,CDATE)→C# D：D#→DN，DN→D#，D#→DA，D#→DNUM P：PN→DATE1，PN→PA，PN→PNUM SP：（S#，PN）→DATE2 S中存在传递函数依赖 S#→DN, S#→SA, C#→SA C中存在传递函数依赖 C#→DN （S#，PN）→DATE2 （CS，CDATE）→C# 均为SP中的函数依赖，是完全函数依赖 关系 候选码 外部码 全码 S S# C#，DN 无 C C#，(CS,CDATE) DN 无 D D#和DN 无 无 P PN 无 无 SP （S#，PN） S#，PN 无 试由Armostrong公理系统推导出下面三条推理规则 合并规则：若X→Z，X→Y，则有X→YZ已知X→Z，由增广律知XY→YZ，又因为X→Y，可得XX→XY→YZ，最后根据传递律得X→YZ。 伪传递规则：由X→Y，WY→Z有XW→Z已知X→Y，据增广律得XW→WY，因为WY→Z，所以XW→WY→Z，通过传递律可知XW→Z。 分解规则：X→Y，Z 包含于 Y，有X→Z已知Z 包含于 Y，根据自反律知Y→Z，又因为X→Y，所以由传递律可得X→Z。 试举出三个多值依赖的实例 关系模式MSC（M，S，C）中，M表示专业，S表示学生，C表示该专业的必修课。假设每个专业有多个学生，有一组必修课。设同专业内所有学生的选修的必修课相同，实例关系如下。按照语义对于M的每一个值M i，S有一个完整的集合与之对应而不问C取何值，所以M→→S。由于C与S的完全对称性，必然有M→→C成立。M S CM 1 S1 C1M 1 S1 C2M 1 S2 C1M 1 S2 C2…… …… ……​ 关系模式ISA（I，S，A）中，I表示学生兴趣小组，S表示学生，A表示某兴趣小组的活动项目。假设每个兴趣小组有多个学生，有若干活动项目。每个学生必须参加所在兴趣小组的所有活动项目，每个活动项目要求该兴趣小组的所有学生参加。按照语义有I→→S，I→→A成立。 关系模式RDP（R，D，P）中，R表示医院的病房，D表示责任医务人员，P表示病人。假设每个病房住有多个病人，有多个责任医务人员负责医治和护理该病房的所有病人。按照语义有R→→D，R→→P成立。 辨析题 任何一个二目关系都是属于3NF的。√ 任何一个二目关系都是属于BCNF的。√ 任何一个二目关系都是属于4NF的。√ 当且仅当函数依赖A→B在R上成立，关系R(A，B，C)等于其投影R1(A，B)和R2(A，C)的连接 ×当且仅当函数依赖A→→B在R上成立，关系R(A，B，C)等于其投影R1(A，B)和R2(A，C)的连接 若R.A→R.B，R.B→R.C，则R.A→R.C √ 若R.A→R.B，R.A→R.C，则R.A→R.(B, C) √ 若R.B→R.A，R.C→R.A，则R.(B, C)→R.A √ 若R.(B, C)→R.A，则R.B→R.A，R.C→R.A ×反例：关系模式 SC（S#，C#，G） （S#，C#）→G，但是S# → G，C#→G 证明 补充 为了设计出性能较优的关系模式，必须进行规范化，规范化主要的理论依据是【关系规范化理论】 规范化理论是关系数据库进行逻辑设计的理论依据，根据这个理论，关系数据库中的关系必须满足：每一个属性都是【不可分解的】 已知关系模式R（A，B，C，D，E）及其上的函数相关性集合F＝{A→D，B→C ，E→A }，该关系模式的候选关键字是【BE】 设学生关系S（SNO，SNAME，SSEX，SAGE，SDPART）的主键为SNO，学生选课关系SC（SNO，CNO，SCORE）的主键为SNO和CNO，则关系R（SNO，CNO，SSEX，SAGE，SDPART，SCORE）的主键为SNO和CNO，其满足【1NF】 设有关系模式W（C，P，S，G，T，R），其中各属性的含义是：C表示课程，P表示教师，S表示学生，G表示成绩，T表示时间，R表示教室，根据语义有如下数据依赖集：D={ C→P，（S，C）→G，（T，R）→C，（T，P）→R，（T，S）→R }，关系模式W的一个关键字是【（T，S）】 关系模式中，满足2NF的模式【必定是1NF】 关系模式R中的属性全是主属性，则R的最高范式必定是【3NF】 消除了部分函数依赖的1NF的关系模式，必定是【2NF】 如果A－&gt;B ,那么属性A和属性B的联系是【多对一】 关系模式的候选关键字可以有1个或多个，而主关键字有【1个】 候选关键字的属性可以有【1个或多个】 关系模式的任何属性【不可再分】 设有关系模式W（C，P，S，G，T，R），其中各属性的含义是：C表示课程，P表示教师，S表示学生，G表示成绩，T表示时间，R表示教室，根据语义有如下数据依赖集：D={ C→P，（S，C）→G，（T，R）→C，（T，P）→R，（T，S）→R }，若将关系模式W分解为三个关系模式W1（C，P），W2（S，C，G），W2（S，T，R，C），则W1的规范化程序最高达到【BCNF】 在关系数据库中，任何二元关系模式的最高范式必定是【BCNF】 在关系规范式中，分解关系的基本原则是【实现无损连接、保持原有的依赖关系】 不能使一个关系从第一范式转化为第二范式的条件是【每一个非属性都部分函数依赖主属性】 任何一个满足2NF但不满足3NF的关系模式都不存在【非主属性对键的传递依赖】 设数据库关系模式R＝（A，B，C，D，E），有下列函数依赖：A→BC，D→E，C→D；下述对R的分解中，哪些分解是R的无损连接分解【（A，B，C）（C，D，E） 】【（A，B）（A，C，D，E）】 设U是所有属性的集合，X、Y、Z都是U的子集，且Z＝U－X－Y。下面关于多值依赖的叙述中，不正确的是【若X→→Y，且Y′∈Y，则X→→Y′】 ,正确的是【若X→→Y，则X→→Z 】【若X→Y，则X→→Y 】【若Z＝∮，则X→→Y 】 若关系模式R（U，F）属于3NF，则【仍存在一定的插入和删除异常】 下列说法不正确的是【任何一个包含三个属性的关系模式一定满足3NF】 设关系模式R（A，B，C），F是R上成立的FD集，F＝{B→C}，则分解P＝{AB，BC}相对于F【是无损联接，也是保持FD的分解】 关系数据库规范化是为了解决关系数据库中【插入、删除和数据冗余】的问题而引入的。 关系的规范化中，各个范式之间的关系是【1NF∈2NF∈3NF】 数据库中的冗余数据是指可【由基本数据导出】的数据 学生表（id，name，sex，age，depart_id，depart_name），存在函数依赖是id→name，sex，age，depart_id；dept_id→dept_name，其满足【2NF】 设有关系模式R（S，D，M），其函数依赖集：F＝{S→D，D→M}，则关系模式R的规范化程度最高达到【2NF】 设有关系模式R（A，B，C，D），其数据依赖集：F＝{（A，B）→C，C→D}，则关系模式R的规范化程度最高达到【2NF】 下列关于函数依赖的叙述中，哪一条是不正确的【由X→YZ，则X→Y， Y→Z】，正确的是【由X→Y，Y→Z，则X→YZ】【由X→Y，WY→Z，则XW→Z 】【由X→Y，Z∈Y，则X→Z】 X→Y，当下列哪一条成立时，称为平凡的函数依赖【Y∈X】 关系数据库的规范化理论指出：关系数据库中的关系应该满足一定的要求，最起码的要求是达到1NF，即满足【每个属性都是不可分解的】 根据关系数据库规范化理论，关系数据库中的关系要满足第一范式，部门（部门号，部门名，部门成员，部门总经理）关系中，因哪个属性而使它不满足第一范式【部门成员】 有关系模式A（C，T，H，R，S），其中各属性的含义是： C：课程 T：教员 H：上课时间 R：教室 S：学生 根据语义有如下函数依赖集： F={C→T，（H，R）→C，（H，T）RC，（H，S）→R} 关系模式A的码是【（H，S）】 关系模式A的规范化程度最高达到【2NF】 现将关系模式A分解为两个关系模式A1（C，T），A2（H，R，S），则其中A1的规范化程度达到【BCNF】 数据库外模式在【数据库逻辑结构设计】阶段设计 生成DBMS系统支持的数据模型在【数据库逻辑结构设计】阶段完成 根据应用需求建立索引在【数据库物理设计】阶段完成 员工性别取值“男”女”/“1”“0”属于【属性冲突】 数据库设计方法包括【新奥尔良方法】【基于E-R模型的方法】【3NF的设计方法】【面向对象的设计方法】【统一建模语言（UML）方法】 数据库设计的基本步骤包括【需求分析】【概念结构设计】【逻辑结构设计】【物理结构设计】【数据库实施】【数据库运行和维护】 集成E-R图要分两个步骤【合并、修改】和【重构】 数据库常见存取方法【索引】【聚簇】【Hash方法】 在进行概念结构设计时，将事物作为属性的基本准则是什么 作为属性，不能再具有需要描述的性质，属性必须是不可分的数据项，不能包含其他属性 属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系 将E-R图转换为关系模式时，可以如何处理实体型间的联系 第7章 数据库设计 了解 数据库设计的特点 数据库物理设计的内容和评价 数据库的实施和维护 掌握 数据库设计基本步骤 数据库设计过程中数据字典的内容 数据库设计各个阶段的具体设计内容、设计描述、设计方法 E-R图的设计 E-R图向关系模型的转换 知识点 数据库设计过程 这是一个完整的实际数据库及其应用系统的设计过程。不仅包括设计数据库本身，还包括数据库的实施、数据库运行和维护。 需求分析准确了解与分析用户需求（包括数据与处理）。 概念结构设计通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型。 逻辑结构设计将概念结构转换为某个DBMS所支持的数据模型，并对其进行优化。 数据库物理设计为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法） 数据库实施设计人员运用DBMS提供的数据语言、工具及宿主语言，根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。 数据库运行和维护在数据库系统运行过程中对其进行评价、调整与修改。 试述数据库设计过程中形成的数据库的各级模式 在概念设计阶段形成独立于机器特点，独立于各个DBMS产品的概念模式，在本篇中就是E-R图 在逻辑设计阶段将E-R图转换成具体的数据库产品支持的数据模型，如关系模型，形成数据库逻辑模式；然后在基本表的基础上再建立必要的视图(View)，形成数据的外模式 在物理设计阶段，根据DBMS特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式。 试述数据库设计的特点 数据库设计既是一项涉及多学科的综合性技术又是一项庞大的工程项目。其主要特点有： 数据库建设是硬件、软件和干件（技术与管理的界面）的结合。 从软件设计的技术角度看，数据库设计应该和应用系统设计相结合，也就是说，整个设计过程中要把结构（数据）设计和行为（处理）设计密切结合起来。 什么叫数据抽象？试举例说明。 数据抽象是对实际的人、物、事和概念进行人为处理，抽取所关心的共同特性，忽略非本质的细节，并把这些特性用各种概念精确地加以描述，这些概念组成了某种模型。 如分类这种抽象是：定义某一类概念作为现实世界中一组对象的类型。这些对象具有某些共同的特性和行为。它抽象了对象值和型之间的“is member of”的语义。在E-R模型中，实体型就是这种抽象。例如在学校环境中，李英是老师，表示李英是教师类型中的一员，则教师是实体型，李英是教师实体型中的一个实体值，具有教师共同的特性和行为：在某个系某个专业教学，讲授某些课程，从事某个方向的科研。 需求分析阶段的设计目标、调查内容 需求分析阶段的设计目标是通过详细调查现实世界要处理的对象（组织、部门、企业等），充分了解原系统（手工系统或计算机系统）工作概况，明确用户的各种需求，然后在此基础上确定新系统的功能。 调查的内容是“数据”和“处理”，即获得用户对数据库的如下要求： 信息要求。指用户需要从数据库中获得信息的内容与性质。由信息要求可以导出数据要求，即在数据库中需要存储哪些数据。 处理要求。指用户要完成什么处理功能，对处理的响应时间有什么要求，处理方式是批处理还是联机处理。 安全性与完整性要求。 数据字典的内容和作用 数据字典的内容通常包括：数据项、数据结构、数据流、数据存储、处理过程5个部分。其中数据项是数据的最小组成单位，若干个数据项可以组成一个数据结构。数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。 数据字典的作用：数据字典是关于数据库中数据的描述，在需求分析阶段建立，是下一步进行概念设计的基础，并在数据库设计过程中不断修改、充实、完善。 数据库的概念结构，特点和设计策略 概念结构是信息世界的结构，即概念模型，其主要特点是 能真实、充分地反映现实世界，包括事物和事物之间的联系，能满足用户对数据的处理要求。是对现实世界的一个真实模型。 易于理解，从而可以用它和不熟悉计算机的用户交换意见，用户的积极参与是数据库的设计成功的关键。 易于更改，当应用环境和应用要求改变时，容易对概念模型修改和扩充。 易于向关系、网状、层次等各种数据模型转换。 概念结构的设计策略通常有四种 自顶向下。即首先定义全局概念结构的框架，然后逐步细化； 自底向上。即首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构； 逐步扩张。首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构； 混合策略。即将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构。 试述数据库概念结构设计的重要性和设计步骤 重要性：数据库概念设计是整个数据库设计的关键，将在需求分析阶段所得到的应用需求首先抽象为概念结构，以此作为各种数据模型的共同基础，从而能更好地、更准确地用某一DBMS实现这些需求。 设计步骤：概念结构的设计方法有多种，其中最经常采用的策略是自底向上方法，该方法的设计步骤通常分为两步：第1步是抽象数据并设计局部视图，第2步是集成局部视图，得到全局的概念结构 为什么要视图集成？视图集成的方法是什么？ 在对数据库系统进行概念结构设计时一般采用自底向上的设计方法，把繁杂的大系统分解子系统。首先设计各个子系统的局部视图，然后通过视图集成的方式将各子系统有机的融合起来，综合成一个系统的总视图。这样设计清晰，由简到繁。由于数据库系统是从整体角度看待和描述数据的，因此数据不再面向某个应用而是整个系统。因此必须进行视图集成，使得数据库能被全系统的多个用户、多个应用共享使用。 一般说来，视图集成可以有两种方式： 多个分E-R图一次集成； 逐步集成，用累加的方式一次集成两个分E-R图。 无论采用哪种方式，每次集成局部E-R图时都需要分两步走： 合并。解决各分E-R图之间的冲突，将各分E-R图合并起来生成初步E-R图。 修改和重构。消除不必要的冗余，生成基本E-R图。 什么是E-R图？构成E-R图的基本要素是什么？ E-R图为实体-联系图，提供了表示实体型、属性和联系的方法，用来描述现实世界的概念模型。 构成E-R图的基本要素是实体型、属性和联系，其表示方法为： 实体型：用矩形表示，矩形框内写明实体名； 属性：用椭圆形表示，并用无向边将其与相应的实体连接起来； 联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1 : 1，1 : n或m : n） 画E-R图 画E-R图 数据库的逻辑结构设计，设计步骤。 数据库的逻辑结构设计就是把概念结构设计阶段设计好的基本E-R图转换为与选用的DBMS产品所支持的数据模型相符合的逻辑结构。 设计步骤为： 将概念结构转换为一般的关系、网状、层次模型； 将转换来的关系、网状、层次模型向特定DBMS支持下的数据模型转换； 对数据模型进行优化。 试述把E-R图转换为DBTG模型和关系模型的转换规则。 E-R图向DBTG模型的转换规则： 1)每个实体型转换为记录型，实体的属性转换为记录的数据项； 2)实体型之间1：n（n≥1）的联系转换为一个系，没有任何联系的实体型转换为奇异系； 3)K（K≥2）个实体型之间多对多的联系，引入一个连结记录，形成K个实体型和连结记录之间的K个系。连结记录的属性由诸首记录的码及联系属性所组成； 4)同一实体型内的1：n，n：m联系，引入连结记录，转换为两个系。 E-R图向关系模型的转换规则： 一个实体型转换为一个关系模式。实体的属性就是关系的属性，实体的码就是关系的码。 对于实体间的联系则有以下不同的情况： 一个1：1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码。如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。 一个1：n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为n端实体的码。 一个m：n联系转换为一个关系模式。与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，各实体码的组合组成该关系的码，或码的一部分。 三个或三个以上实体间的一个多元联系可以转换为一个关系模式。与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。 具有相同码的关系模式可合并。 由E-R图转换为IMS模型的转换规则 1)每个实体型转换为记录型，实体的属性转换为记录的数据项； 2)实体型之间1：n（n≥1）的联系转换记录型之间的有向边； 3)实体型之间m：n（m&gt;1，n&gt;1）的联系则分解成一对多联系，再根据2)转换； 4)K（K≥2）个实体型之间多对多的联系，可先转换成多对两个实体型之间的联系，再根据3)转换。 E-R转换关系模型 补充 数据流程图是用于描述结构化方法中【需求分析】阶段的工具。 数据库设计中，用E－R图赖描述信息结构但不涉及信息在计算机中的表示，这是数据库设计的【概念设计阶段】 在数据库设计中，将E-R图转换成关系数据模型的过程属于【逻辑设计阶段】 子模式DDL是用来描述【数据库的局部逻辑结构】 数据库设计的概念设计阶段，表示概念结构的常用方法和描述工具是【实体联系法和实体联系图】 在E－R模型向关系模型转换时，M：N的联系转换为关系模式时，其关键字是【M、N端实体的关键字组合】 某学校规定，每一个班级最多有50名学生，至少有10名学生；每一名学生必须属于一个班级。在班级与学生实体的联系中，学生实体的基数是【（1，1）】 在关系数据库设计中，设计关系模式是数据库设计中【逻辑设计阶段】阶段的任务 关系数据库的规范化理论主要解决的问题是【如何构造合适的数据逻辑结构】 数据库设计可划分为七个阶段，每个阶段都有自己的设计内容，“为哪些关系，在哪些属性上、键什么样的索引”这一设计内容应该属于【物理设计】设计阶段。 假设设计数据库性能用“开销”，即时间、空间及可能的费用来衡量，则在数据库应用系统生存期中存在很多开销。其中，对物理设计者来说，主要考虑的是【操作开销】 数据库物理设计完成后，进入数据库实施阶段，下述工作中，【扩充功能】一般不属于实施阶段的工作。 从ER图导出关系模型时，如果实体间的联系是M：N的，下列说法中正确的是【增加一个关系表示联系，其中纳入M方和N方的关键字】 在ER模型中，如果有3个不同的实体集，3个M：N联系，根据ER模型转换为关系模型的规则，转换为关系的数目是【6】 数据库外模式在【数据库逻辑结构设计】阶段设计 生成DBMS系统支持的数据模型在【数据库逻辑结构设计】阶段完成 根据应用需求建立索引在【数据库物理设计】阶段完成 员工性别取值“男”女”/“1”“0”属于【属性冲突】 数据库设计方法包括【新奥尔良方法】【基于E-R模型的方法】【3NF的设计方法】【面向对象的设计方法】【统一建模语言（UML）方法】 数据库设计的基本步骤包括【需求分析】【概念结构设计】【逻辑结构设计】【物理结构设计】【数据库实施】【数据库运行和维护】 集成E-R图要分两个步骤【合并、修改】和【重构】 数据库常见存取方法【索引】【聚簇】【Hash方法】 在进行概念结构设计时，将事物作为属性的基本准则是什么 作为属性，不能再具有需要描述的性质，属性必须是不可分的数据项，不能包含其他属性 属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系 将E-R图转换为关系模式时，可以如何处理实体型间的联系 一个1：1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。 一个1：n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。 一个m：n联系转换为一个关系模式。 三个或三个以上实体间的一个多元联系可以转换为一个关系模式。 具有相同码的关系模式可合并。 综合题 第8章 数据库编程 了解 SQL编程技术可以有效客服SQL实现复杂应用方面的不足 提高应用系统和RDBMS间的互操作性 掌握 嵌入SQL中游标的概念和使用方法 PL/SQL和存储过程的基本概念、基本结构、语句语法和用法 ODBC开发应用系统的体系结构 ODBC API和ODBC的应用程序的工作流程 在实际安装的RDBMS上通过编程的方式开发应用程序，完成对数据库的各种操作 使用ODBC进行数据库应用程序的设计，使设计的应用程序可移植性好，并且能同时访问不同的数据库，共享数据资源 知识点 嵌入式SQL语言与主语言之间的通信 向主语言传递SQL语句的执行状态信息，使主语言能够据此信息空值程序流程，主要用【SQL通信区】（SQL Communication Area，简称SQLCA）实现 主语言向SQL语句提供参数，使用【主变量】（host variable）输入数据实现 程序把SQL语句查询数据库的结果交主语言处理，用【主变量】和【游标】（cursor）向主语言输出数据 嵌入式SQL语句为了和主语言语句进行区分，在SQL语句前加前缀【EXEC SQL】，以【分号;】结束 主变量可以附加一个指示变量，指示变量可以表示输入主变量是否为【空值】 SQL是面向集合的，主语言是面向记录的，可以使用【游标】解决这一问题 存储过程经过编译、优化之后存储在【数据库服务器中】 应用程序中访问和管理数据库的方法由【嵌入式SQL】【PL/SQL】【ODBC】【JDBC】【OLEDB】 综合题 第9章 关系查询处理和查询优化 了解 查询处理的基本步骤（查询分析、查询检查、查询优化、查询执行） 掌握 什么是关系系统的查询优化，查询优化的方法 画出查询的语法树以及优化后的语法树 代数优化算法、物理优化算法 知识点 查询处理的基本步骤 查询分析 查询检查 查询优化 查询执行 查询优化在关系数据库系统中的重要性和可能性 重要性 关系系统的查询优化既是RDBMS实现的关键技术，又是关系系统的优点所在，它减轻了用户选择存取路径的负担，用户只要提出“干什么”，不必指出“这么干” 查询优化的优点不仅在于用户不必考虑如何最好地表达查询以获得较好的效率，而且在于系统可以比用户程序的“优化”做得更好 可能性 优化器可以从数据字典中获取许多统计信息，例如各个关系中的元组数，关系中每个属性值的分布情况，这些属性上是否有索引，是什么索引（B+数索引、Hash索引、唯一索引、组合索引）等等。优化器可以根据这些信息选择有效的执行计划，而用户程序则难以获得这些信息 如果数据库的物理统计信息改变了，系统可以自动对查询进行重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的 优化器可以考虑数十甚至数百种不同的执行计划，从中选出较优的一个，而程序员一般只能考虑有限的几种可能性 优化器中包括了很多复杂的优化技术，这些优化技术往往只有最好的程序员才能掌握。系统的自动优化相当于使得所有人都拥有这些优化技术 语法树 语法树 关系数据库管理系统查询优化的一般准则 代数优化策略 选择运算应尽可能先做 把投影运算和选择运算同时进行 把投影同其前或其后的双目运算结合起来执行 把某些选择同在它前面要执行的笛卡儿积结合起来成为一个连接运算 找出公共子表达式 物理优化 选取合适的连接算法 关系数据库管理系统查询优化的一般步骤 把查询转换成某种内部表示，通常用的内部表示是语法树 把语法树转换成标准（优化）形式，即利用优化算法把原始的语法树转换成优化的形式 选择低层的存取路径 生成查询计划，选择所需代价最小的计划加以执行 第10章 数据库恢复技术 了解 数据库的一致性状态 数据库运行中可能产生的故障类型，它们如何影响事务的正常执行，如何破坏数据库数据 数据转储的概念及分类 数据库的镜像功能 掌握 事务的基本概念和事务的ACID性质 数据库恢复的实现技术 日志文件的内容及作用 登记日志文件所要遵循的原则 具有检查点的恢复技术 恢复的基本原理 针对不同故障的恢复策略和方法 日志文件的使用 知识点 事务的概念及事务的4个特性。恢复技术能保证事务的哪些特性 事务是用户定义的一个数据库操作序列，这些操作要么全做、要么全不，是一个不可分割的工作单位 事务具有4个特性（也称ACID特性） 原子性（Atomicity） 一致性（Consistency） 隔离性（Isolation） 持续性（Durability） 为什么事务非正常结束时会影响数据库数据的正确性，举例说明 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。 例如某工厂的库存管理系统中，要把数量为Q的某种零件从仓库1移到仓库2存放。则可以定义一个事务T，T包括两个操作；Q1=Q1-Q，Q2=Q2+Q。如果T非正常终止时只做了第一个操作，则数据库就处于不一致性状态，库存量无缘无故少了Q。 登记日志文件时为什么必须先写日志文件，后写数据库？ 把对数据的修改写到数据库中和把表示这个修改的日志记录写到日志文件中是两个不同的操作。有可能在这两个操作之间发生故障，即这两个写操作只完成了一个。 如果先写了数据库修改，而在运行记录中没有登记这个修改，则以后就无法恢复这个修改了。如果先写日志，但没有修改数据库，在恢复时只不过是多执行一次UNDO操作，并不会影响数据库的正确性。所以一定要先写日志文件，即首先把日志记录写到日志文件中，然后写数据库的修改。 针对不同的故障，试给出恢复的策略和方法（事务故障恢复/系统故障恢复/介质故障恢复） 事务故障的恢复步骤 反向扫描文件日志，查找该事务的更新操作。 对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库。直至读到此事务的开始标记，该事务故障的恢复就完成了。 系统故障的恢复步骤 正向扫描日志文件，找出在故障发生前已经提交的事务队列（REDO队列）和未完成的事务队列（UNDO队列）。 对未完成的事务队列中的各个事务进行UNDO处理。 对已经提交的事务队列中的各个事务进行REDO处理 介质故障的恢复步骤 装入最新的数据库后备副本（离故障发生时刻最近的转储副本），使数据库恢复到转储时的一致性状态。 装入转储结束时刻的日志文件副本 启动系统恢复命令，由DBMS完成恢复功能，即重做已完成的事务。 什么是检查点记录，包括哪些内容 检查点记录是一类新的日志纪录。它的内容包括 建立检查点时刻所有正在执行的事务清单，如下图中的T1、T2 这些事务的最近一个日志记录的地址，如下图中的D1、D2 具有检查点的恢复技术有什么优点？举例 利用日志技术进行数据库恢复时，恢复子系统必须搜索整个日志，这将耗费大量的时间。此外，需要REDO处理的事务实际上已经将它们的更新操作结果写到数据库中了，恢复子系统又重新执行了这些操作，浪费了大量时间。检查点技术就是为了解决这些问题。 例如 使用检查点方法进行恢复的步骤。 ① 从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。 ② 由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST。 这里建立两个事务队列: UNDO-LIST: 需要执行undo操作的事务集合 REDO-LIST: 需要执行redo操作的事务集合 把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。 ③ 从检查点开始正向扫描日志文件 如有新开始的事务Ti，把Ti暂时放入UNDO-LIST队列 如有提交的事务Tj，把Tj从UNDO-LIST队列移到REDO-LIST队列，直到日志文件结束 ④ 对UNDO-LIST中的每个事务执行UNDO操作, 对REDO-LIST中的每个事务执行REDO操作 什么是数据库镜像？它有什么用途？ 数据库镜像即根据DBA的要求，自动把整个数据库或者其中的部分关键数据复制到另一个磁盘上。每当主数据库更新时，DBMS自动把更新后的数据复制过去，即DBMS自动保证镜像数据与主数据的一致性。 数据库镜像的用途 用于数据库恢复。当出现介质故障时，镜像磁盘可继续使用，同时DBMS自动利用镜像磁盘数据进行数据库的恢复，不需要关闭系统和重装数据库副本。 提高数据库的可用性。在没有出现故障时，当一个用户对某个数据加排它锁进行修改时，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁。 补充 在系统故障的恢复策略中，为什么UNDO处理反向扫描日志文件，REDO处理正向扫描日志文件 如果存在同一个数据的多个UNDO操作，需要将数据恢复到第一个失败事务之前，如果正向扫描处理日志文件，无法实现这一目标，因此应该反向扫描日志文件。对于同一个数据的多个REDO操作，需要将数据恢复到最后一个成功事务之后，因此应该正向扫描日志文件 说明恢复系统是否可以保证事务的原子性和持续性 原子性是指操作要么都做，要么都不做，在恢复策略中UNDO可以保证将未成功提交的事务所有操作都取消，REDO可以保证将成功提交的事务所有操作都完成，因此需确保事务的原子性； 持续性是指一旦事务提交，对数据库中数据的改变是永久性的，REDO可以保证事务只要提交，改变一定被永久实现，因此要确保事务的持续性 综合题 数据库中为什么要有恢复子系统？它的功能是什么？ 答： 因为计算机系统中硬件的故障、软件的错误、操作员的失误以及恶意的破坏是不可避免的，这些故障轻则造成运行事务非正常中断，影响数据库中数据的正确性，重则破坏数据库，使数据库中全部或部分数据丢失，因此必须要有恢复子系统。 恢复子系统的功能是：把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）。 数据库运行中可能产生的故障有哪几类？哪些故障影响事务的正常执行？哪些故障破坏数据库数据？ 事务内部的故障 系统故障 介质故障 计算机病毒事务故障、系统故障和介质故障影响事务的正常执行；介质故障和计算机病毒破坏数据 数据库恢复的基本技术有哪些？ 数据转储和登录日志文件是数据库恢复的基本技术。 当系统运行过程中发生故障，利用转储的数据库后备副本和日志文件就可以将数据库恢复到故障前的某个一致性状态。 数据库转储的意义是什么？ 试比较各种数据转储方法。 数据转储是数据库恢复中采用的基本技术。所谓转储即DBA定期地将数据库复制到磁带或另一个磁盘上保存起来的过程。当数据库遭到破坏后可以将后备副本重新装入，将数据库恢复到转储时的状态。 静态转储：在系统中无运行事务时进行的转储操作。静态转储简单，但必须等待正运行的用户事务结束才能进行。同样，新的事务必须等待转储结束才能执行。显然，这会降低数据库的可用性。 动态转储：指转储期间允许对数据库进行存取或修改。动态转储可克服静态转储的缺点，它不用等待正在运行的用户事务结束，也不会影响新事务的运行。但是，转储结束时后援副本上的数据并不能保证正确有效。因为转储期间运行的事务可能修改了某些数据，使得后援副本上的数据不是数据库的一致版本。 为此，必须把转储期间各事务对数据库的修改活动登记下来，建立日志文件（log file）。这样，后援副本加上日志文件就能得到数据库某一时刻的正确状态。 转储还可以分为海量转储和增量转储两种方式。 海量转储是指每次转储全部数据库。 增量转储则指每次只转储上一次转储后更新过的数据。 从恢复角度看，使用海量转储得到的后备副本进行恢复一般说来更简单些。但如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效。 什么是日志文件？为什么要设立日志文件？ 日志文件是用来记录事务对数据库的更新操作的文件。 设立日志文件的目的是： 进行事务故障恢复；进行系统故障恢复；协助后备副本进行介质故障恢复。 登记日志文件时为什么必须先写日志文件，后写数据库？ 把对数据的修改写到数据库中和把表示这个修改的日志记录写到日志文件中是两个不同的操作。有可能在这两个操作之间发生故障，即这两个写操作只完成了一个。 如果先写了数据库修改，而在运行记录中没有登记这个修改，则以后就无法恢复这个修改了。如果先写日志，但没有修改数据库，在恢复时只不过是多执行一次UNDO操作，并不会影响数据库的正确性。所以一定要先写日志文件，即首先把日志记录写到日志文件中，然后写数据库的修改。 一个事务的执行，要么全部完成，要么全部不做，一个事务中对数据库的所有操作都是一个不可分割的操作序列的属性是【原子性】 表示两个或多个事务可以同时运行而不互相影响的是【独立性】 事务的持续性是指【事务一旦提交，对数据库的改变是永久的】 SQL语言中的COMMIT语句的主要作用是【提交事务】 SQL语言中用【ROLLBACK】语句实现事务的回滚 若系统在运行过程中，由于某种硬件故障，使存储在外存上的数据部分损失或全部损失，这种情况称为【介质故障】 在DBMS中实现事务持久性的子系统是【恢复管理子系统】 后援副本的作用是【故障后的恢复】 事务日志用于保存【对数据的更新操作】 数据库恢复的基础是利用转储的冗余数据。这些转储的冗余数据包括【日志文件、数据库后备副本】 第11章 并发控制 了解 数据库并发控制技术的必要性 活锁与死锁的概念 掌握 并发操作可能产生数据不一致的情况，包括丢失修改、不可重复读、读“脏”数据等 封锁的类型及不同封锁类型（X锁、S锁）的性质和定义，相关的相容控制矩阵 封锁协议的概念 封锁粒度的概念，多粒度封锁方法，多粒度封锁协议的相容控制矩阵 封锁协议与数据一致性的关系，并发调度的可串行性概念 两段锁协议与可串行性的关系，两段锁协议与死锁的关系 知识点 在数据库中为什么要并发控制？并发控制技术能保证事务的哪些特性？ 数据库是共享资源，通常有许多个事务同时在运行。当多个事务并发地存取数据库时就会产生同时读取和/或修改同一数据的情况。若对并发操作不加控制就可能会存取和存储不正确的数据，破坏数据库的一致性。所以数据库管理系统必须提供并发控制机制。 并发控制可以保证事务的【一致性】和【隔离性】 并发操作可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？ 并发操作带来的数据不一致性包括三类 丢失修改（LostUpdate）两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了（覆盖了）T1提交的结果，导致T1的修改被丢失。 不可重复读（Non-RepeatableRead）不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。不可重复读包括三种情况1.事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读改数据时，得到与前一次不同的值2.事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录消失了3.事务T1按一条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录后两种不可重复读有时也称为幻影（phantom row）现象​​​​​ 读“脏”数据（DirtyRead）读“脏”数据是指事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，则T2读到的数据就为“脏”数据，即不正确的数据。 避免不一致性的方法和技术就是并发控制。常用的并发控制技术包括封锁技术、时间戳方法、乐观控制方法、多版本并发控制方法等 什么是封锁？基本的封锁类型有几种？试述它们的含义。 封锁就是事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新此数据对象。 基本的封锁类型有两种: 排它锁(简称X锁) 和共享锁(简称S锁)。 排它锁又称为写锁。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。 共享锁又称为读锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 如何用封锁机制保证数据的一致性 DBMS在对数据进行读写操作之前首先对该数据执行封锁操作 什么是活锁？活锁的产生原因和解决方法 - 活锁产生的原因：当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁，从而导致活锁。 避免活锁的简单方法是采用先来先服务的策略。当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。 什么是死锁？请给出预防死锁的若干方法。 在数据库中，产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求已被其他事务封锁的数据加锁，从而出现死等待。 防止死锁的发生其实就是要破坏产生死锁的条件。预防死锁通常有两种方法： 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。 顺序封锁法预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。 请给出检测死锁发生的一种方法，当发生死锁后如何解除死锁？ 数据库系统一般采用允许死锁发生，DBMS检测到死锁后加以解除的方法。 DBMS中诊断死锁的方法与操作系统类似，一般使用超时法或事务等待图法。 超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。 DBMS并发控制子系统检测到死锁后，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有锁，使其他事务得以继续运行下去。 什么样的并发调度是正确的调度？ 可串行化的调度是正确的调度。 可串行化的调度的定义：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同，我们称这种调度策略为可串行化的调度。 综合题 证明题 为什么要引进意向锁？ 意向锁的含义是什么？ 引进意向锁是为了提高封锁子系统的效率。 原因是：在多粒度封锁方法中，一个数据对象可能以两种方式加锁—显式封锁和隐式封锁。因此系统在对某一数据对象加锁时不仅要检查该数据对象上有无（显式和隐式）封锁与之冲突；还要检查其所有上级结点和所有下级结点，看申请的封锁是否与这些结点上的（显式和隐式）封锁冲突；显然，这样的检查方法效率很低。为此引进了意向锁。 意向锁的含义是：对任一结点加锁时，必须先对它的上层结点加意向锁。引进意向锁后，系统对某一数据对象加锁时不必逐个检查与下一级结点的封锁冲突了。 试述常用的意向锁：IS锁，IX锁，SIX锁，给出这些锁的相容矩阵。 IS锁：如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。例如，要对某个元组加S锁，则要首先对关系和数据库加IS锁 IX锁：如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。例如，要对某个元组加X锁，则要首先对关系和数据库加IX锁。 SIX锁：如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX。 相容矩阵 补充 试述两段锁协议的概念。 两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁。 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁； 在释放一个封锁之后，事务不再申请和获得任何其他封锁。 “两段”的含义是，事务分为两个阶段： 第一阶段是获得封锁，也称为扩展阶段。在这阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁。 第二阶段是释放封锁，也称为收缩阶段。在这阶段，事务释放已经获得的锁，但是不能再申请任何锁。 不同封锁协议与系统一致性级别的关系是什么？ 不同的封锁协议对应不同的一致性级别。 一级封锁协议可防止丢失修改，并保证事务T是可恢复的。在一级封锁协议中，对读数据是不加S锁的，所以它不能保证可重复读和不读“脏”数据。 二级封锁协议除防止了丢失修改，还可进一步防止读“脏”数据。在二级封锁协议中，由于读完数据后立即释放S锁，所以它不能保证可重复读。 在三级封锁协议中，无论是读数据还是写数据都加长锁，即都要到事务结束时才释放封锁。所以三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。 什么是封锁协议？不同级别的封锁协议的主要区别是什么？ 在运用封锁技术对数据加锁时，要约定一些规则。例如，在运用X锁和S锁对数据对象加锁时，要约定何时申请X锁或S锁、何时释放封锁等。这些约定或者规则称为封锁协议（Locking Protocol）。对封锁方式约定不同的规则，就形成了各种不同的封锁协议。不同级别的封锁协议，例如《概论》中介绍的三级封锁协议，三级协议的主要区别在于什么操作需要申请封锁，何时申请封锁以及何时释放锁（即持锁时间的长短）。 一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。 二级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。 三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。 意向锁中为什么存在SIX锁，而没有XIS锁 完整性约束是否能够保证数据库在处理多个事务时处于一致状态 综合题 为了防止一个用户的工作不适当地影响另一个用户，应该采取【并发控制】 解决并发操作带来的数据不一致问题普遍采用【封锁】技术。 下列不属于并发操作带来的问题是【死锁】 DBMS普遍采用【封锁】方法来保证调度的正确性 事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放，这是【一级封锁协议】 如果事务T获得了数据项Q上的排他锁，则T对Q【既可读又可写】 设事务T1和T2，对数据库中地数据A进行操作，可能有如下几种情况，请问哪一种不会发生冲突操作【T1正在读A，T2也要读A】 如果有两个事务，同时对数据库中同一数据进行操作，不会引起冲突的操作是【两个都是SELECT】 在数据库系统中，死锁属于【事务故障】","link":"/2020/02/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"},{"title":"药房药品信息管理系统","text":"第一次写挺长的代码 还有点小激动 ---药品信息管理系统 ---2019.12.21 ---天气晴朗 万物生长 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;conio.h&gt;#include &lt;cstdlib&gt;#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;algorithm&gt;using namespace std;struct Node{ char serial_number[107];//编号 char name[107];//名称 int quantity;//数量 double sum;//成交额 int sale;//成交量 double sale_price;//销售价格 double purchase_price;//进货价格 char factor[107];//厂家// int Datepro_year,Datepro_mth,Datepro_day;//生产日期 int Date_year,Date_mth;//保质期（年.月） char f='0';//是否存在 bool operator &lt; (const Node&amp;a) const { return strcmp(this-&gt;serial_number,a.serial_number) == -1; }}drug[107];void Query (); void Print_name_acur ();void Save_Print ();int num=1,del_num;//药品种类数 //HOME 主界面 void Read_information_1 () { FILE *fp=fopen (&quot;data.txt&quot;,&quot;r&quot;); while (!feof (fp)) { fscanf(fp,&quot;%s&quot;,drug[num].serial_number); fscanf(fp,&quot;%s&quot;,drug[num].name); fscanf(fp,&quot;%d %lf&quot;,&amp;drug[num].quantity,&amp;drug[num].sale_price); fscanf(fp,&quot;%s&quot;,&amp;drug[num].factor); fscanf(fp,&quot;%d.%d.%d&quot;,&amp;drug[num].Datepro_year,&amp;drug[num].Datepro_mth,&amp;drug[num].Datepro_day); fscanf(fp,&quot;%lf %d.%d&quot;,&amp;drug[num].purchase_price,&amp;drug[num].Date_year,&amp;drug[num].Date_mth); fscanf(fp,&quot;%lf%d&quot;,&amp;drug[num].sum,&amp;drug[num].sale); fscanf(fp,&quot; %c&quot;,&amp;drug[num].f); num++; } return ;}void Read_information_2 (){ FILE *fp=fopen (&quot;dataout&quot;,&quot;rb&quot;); while (!feof (fp)) { fread(&amp;drug[num].serial_number,sizeof (struct Node),1,fp); fread(&amp;drug[num].name,sizeof (struct Node),1,fp); fread(&amp;drug[num].factor,sizeof (struct Node),1,fp); fread(&amp;drug[num].Datepro_year,sizeof (struct Node),1,fp); fread(&amp;drug[num].Datepro_mth,sizeof (struct Node),1,fp); fread(&amp;drug[num].Datepro_day,sizeof (struct Node),1,fp); fread(&amp;drug[num].purchase_price,sizeof (struct Node),1,fp); fread(&amp;drug[num].Date_year,sizeof (struct Node),1,fp); fread(&amp;drug[num].Date_mth,sizeof (struct Node),1,fp); fread(&amp;drug[num].sum,sizeof (struct Node),1,fp); fread(&amp;drug[num].sale,sizeof (struct Node),1,fp); fread(&amp;drug[num].f,sizeof (struct Node),1,fp); num++; } return ;}void Print_HOME (){ system (&quot;cls&quot;); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); printf (&quot;|||\\t欢迎使用药店药品信息管理系统: \\t||\\n&quot;); printf (&quot;|||\\t\\t1.增加 \\t\\t||\\n&quot;); printf (&quot;|||\\t\\t2.删除 \\t\\t||\\n&quot;); printf (&quot;|||\\t\\t3.修改 \\t\\t||\\n&quot;); printf (&quot;|||\\t\\t4.销售 \\t\\t||\\n&quot;); printf (&quot;|||\\t\\t5.查询 \\t\\t||\\n&quot;); printf (&quot;|||\\t\\t6.统计 \\t\\t||\\n&quot;); printf (&quot;|||\\t\\t7.退出 \\t\\t||\\n&quot;); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); if (num==2||num-del_num==2) printf (&quot;||| 请注意目前所有药品信息为空 谨慎操作! |||\\n&quot;); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); } //1.增加void Add_ (){ system (&quot;cls&quot;); printf (&quot;|||\\t请输入要增加的药品信息\\t\\t|||\\n&quot;); printf (&quot;|||\\t输入药品编号(输入@可退出) \\t|||\\n\\t&quot;); scanf (&quot;%s&quot;, drug[num].serial_number); if (!strcmp (drug[num].serial_number,&quot;@&quot;)) return ; printf (&quot;|||\\t输入药品名称 \\t\\t\\t|||\\n\\t&quot;); scanf (&quot;%s&quot;, drug[num].name); printf (&quot;|||\\t输入药品库存数量 \\t\\t|||\\n\\t&quot;); scanf (&quot;%d&quot;, &amp;drug[num].quantity); printf (&quot;|||\\t输入药品销售价格 \\t\\t|||\\n\\t&quot;); scanf (&quot;%lf&quot;, &amp;drug[num].sale_price); printf (&quot;|||\\t输入药品厂家 \\t\\t\\t|||\\n\\t&quot;); scanf (&quot;%s&quot;, drug[num].factor); printf (&quot;|||\\t输入药品生产日期 \\t\\t|||\\n\\t&quot;); scanf (&quot;%d.%d.%d&quot;, &amp;drug[num].Datepro_year, &amp;drug[num].Datepro_mth, &amp;drug[num].Datepro_day); printf (&quot;|||\\t输入药品进货价格 \\t\\t|||\\n\\t&quot;); scanf (&quot;%lf&quot;, &amp;drug[num].purchase_price); printf (&quot;|||\\t输入药品保质期 \\t\\t|||\\n\\t&quot;); scanf (&quot;%d.%d&quot;, &amp;drug[num].Date_year, &amp;drug[num].Date_mth); drug[num].f = '1'; num++; Save_Print (); printf (&quot;|||\\t 此次添加成功！ \\t\\t|||\\n&quot;); printf (&quot;|||\\t 是否继续添加？(Y/N) \\t\\t|||\\n&quot;); getchar (); if (getchar () == 'Y') Add_ (); return ; } //2.删除void Del_ (){ system (&quot;cls&quot;); printf (&quot;|||\\t请输入要删除的药品编号\\t|||\\n&quot;); char str[107]; int i = 1; scanf (&quot;%s&quot;, str); for (i = 1;i &lt; num; i++) if (strcmp (str,drug[i].serial_number) == 0) { if (drug[i].f == '1') drug[i].f = '0', del_num++, Save_Print (), printf (&quot;|||\\t删除成功！\\t|||\\n&quot;); else printf (&quot;|||\\t该药品不存在或已被删除!\\t|||\\n&quot;); break; } if (i == num) printf (&quot;|||\\t该药品不存在或已被删除!\\t|||\\n&quot;); printf (&quot;|||\\t是否继续删除其他药品？(Y/N)\\t|||\\n&quot;) ; getchar (); if (getchar () == 'Y') Del_ (); return ;} //3.修改void Modify (){ system (&quot;cls&quot;); printf (&quot;|||\\t请输入要修改的药品编号\\t|||\\n&quot;); int cmd; char str[107]; scanf (&quot;%s&quot;, str); for (int i = 1;i &lt; num;i++) if (strcmp (str,drug[i].serial_number) == 0) { if (drug[i].f=='1') { system (&quot;cls&quot;); for (int j=1; j&lt;=21; j++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); printf (&quot;|||\\t请输入要修改的信息编号\\t|||\\n&quot;); printf (&quot;|||\\t 1.药品名称 \\t\\t|||\\n&quot;); printf (&quot;|||\\t 2.药品库存数量 \\t|||\\n&quot;); printf (&quot;|||\\t 3.药品销售价格 \\t|||\\n&quot;); printf (&quot;|||\\t 4.药品厂家 \\t\\t|||\\n&quot;); printf (&quot;|||\\t 5.药品生产日期 \\t|||\\n&quot;); printf (&quot;|||\\t 6.药品进货价格 \\t|||\\n&quot;); printf (&quot;|||\\t 7.药品保质期 \\t\\t|||\\n&quot;); printf (&quot;|||\\t 8.药品编号 \\t\\t|||\\n&quot;); printf (&quot;|||\\t 9.返回HOME \\t\\t|||\\n&quot;); for (int j = 1; j &lt;= 21; j++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); scanf (&quot;%d&quot;, &amp;cmd); system (&quot;cls&quot;); switch (cmd) { case 1: printf (&quot;|||\\t 请输入修改后的药品名称 \\t|||\\n&quot;); scanf (&quot;%s&quot;,drug[i].name); break; case 2: printf (&quot;|||\\t 请输入修改后的药品库存数量 \\t|||\\n&quot;); scanf (&quot;%d&quot;,&amp;drug[i].quantity); break; case 3: printf (&quot;|||\\t 请输入修改后的药品销售价格 \\t|||\\n&quot;); scanf (&quot;%lf&quot;,&amp;drug[i].sale_price); break; case 4: printf (&quot;|||\\t 请输入修改后的药品厂家 \\t|||\\n&quot;); scanf (&quot;%s&quot;,drug[i].factor); break; case 5: printf (&quot;|||\\t 请输入修改后的药品生产日期 \\t|||\\n&quot;); scanf (&quot;%d.%d.%d&quot;,&amp;drug[i].Datepro_year,&amp;drug[i].Datepro_mth,&amp;drug[i].Datepro_day); break; case 6: printf (&quot;|||\\t 请输入修改后的药品进货价格 \\t|||\\n&quot;); scanf (&quot;%lf&quot;,&amp;drug[i].purchase_price); break; case 7: printf (&quot;|||\\t 请输入修改后的药品保质期 \\t|||\\n&quot;); scanf (&quot;%d.%d&quot;,&amp;drug[i].Date_year,&amp;drug[i].Date_mth); break; case 8: printf (&quot;|||\\t 请输入修改后的药品编号 \\t|||\\n&quot;); scanf (&quot;%s&quot;,drug[i].serial_number); break; case 9: return ; break; } system (&quot;cls&quot;); printf (&quot;|||\\t修改完成！\\t\\t\\t\\t|||\\n&quot;); } else system (&quot;cls&quot;), printf (&quot;|||\\t该药品信息不存在或已被删除！\\t|||\\n&quot;); break; } printf (&quot;|||\\t是否继续修改其他药品信息？(Y/N)\\t|||\\n&quot;); getchar (); if (getchar ()=='Y') Modify (); Save_Print (); return ; } //4.销售void Sale_ (){ system (&quot;cls&quot;); printf (&quot;|||\\t请输入要销售的药品编号\\t |||\\n&quot;); char str[107]; int cmd,num_,i = 1; scanf (&quot;%s&quot;, str); for (; i&lt;num; i++) if (strcmp (str,drug[i].serial_number) == 0) { if (drug[i].f == '1') { system (&quot;cls&quot;); printf (&quot;|||\\t请输入要销售的数量(输入-1退出) \\t|||\\n&quot;); scanf (&quot;%d&quot;, &amp;cmd); if (cmd==-1) return ; while (cmd &gt; drug[i].quantity) system (&quot;cls&quot;), printf (&quot;|||\\t库存不足！请重新输入！(输入-1退出)\\t|||\\n&quot;), scanf (&quot;%d&quot;, &amp;cmd); drug[i].quantity -= cmd; drug[i].sale += cmd; drug[i].sum += (drug[i].sale_price-drug[i].purchase_price)*cmd; system (&quot;cls&quot;); printf (&quot;|||\\t此次销售已完成\\t\\t|||\\n&quot;); } else system (&quot;cls&quot;), printf (&quot;|||\\t该药品信息不存在或已被删除！\\t|||\\n&quot;); break; } if (i == num) system (&quot;cls&quot;), printf (&quot;|||\\t该药品信息不存在或已被删除！\\t|||\\n&quot;); printf (&quot;|||\\t是否继续销售？(Y/N)\\t|||\\n&quot;); getchar (); if (getchar () == 'Y') Sale_ (); Save_Print (); return ; } //5.查询//编号查询 void Print_number (){ system (&quot;cls&quot;); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); printf (&quot;|||\\t请输入所查药品编号:\\t\\t|||\\n&quot;); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); int i=1; char str[107]; scanf (&quot;%s&quot;,str); system (&quot;cls&quot;); for (;i&lt;num;i++) if (!strcmp (str,drug[i].serial_number)) { if (drug[i].f=='0') printf (&quot;|||\\t该药品信息不存在或已被删除！\\t|||\\n&quot;); else { for (int j=1;j&lt;=21;j++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); printf (&quot;|||\\t该药品全部信息:\\t\\t\\t|||\\n&quot;); printf (&quot;|||\\t 1.药品编号: %s\\t\\t|||\\n&quot;,drug[i].serial_number); printf (&quot;|||\\t 2.药品名称: %s\\t\\t|||\\n&quot;,drug[i].name); printf (&quot;|||\\t 3.药品库存数量: %d\\t\\t|||\\n&quot;,drug[i].quantity); printf (&quot;|||\\t 4.药品销售价格: %.2lf\\t\\t|||\\n&quot;,drug[i].sale_price); printf (&quot;|||\\t 5.药品厂家: %s\\t\\t|||\\n&quot;,drug[i].factor); printf (&quot;|||\\t 6.药品生产日期: %d.%d.%d\\t|||\\n&quot;,drug[i].Datepro_year,drug[i].Datepro_mth,drug[i].Datepro_day); printf (&quot;|||\\t 7.药品进货价格: %.2lf\\t\\t|||\\n&quot;,drug[i].purchase_price); printf (&quot;|||\\t 8.药品保质期: %d.%d\\t\\t|||\\n&quot;,drug[i].Date_year,drug[i].Date_mth); for (int j=1;j&lt;=21;j++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); } break; } if (i==num) printf (&quot;|||\\t该药品信息不存在或已被删除！\\t|||\\n&quot;); printf (&quot;|||\\t是否继续进行编号查询？(Y/N)\\t|||\\n&quot;); getchar (); if (getchar ()=='Y') Print_number (); return ; }//精确查询 void Print_name_acur_ (int n){ system (&quot;cls&quot;); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); printf (&quot;|||\\t该药品全部信息:\\t\\t\\t|||\\n&quot;); printf (&quot;|||\\t 1.药品名称: %s\\t\\t|||\\n&quot;,drug[n].name); printf (&quot;|||\\t 2.药品库存数量: %d\\t\\t|||\\n&quot;,drug[n].quantity); printf (&quot;|||\\t 3.药品销售价格: %.2lf\\t\\t|||\\n&quot;,drug[n].sale_price); printf (&quot;|||\\t 4.药品厂家: %s\\t\\t|||\\n&quot;,drug[n].factor); printf (&quot;|||\\t 5.药品生产日期: %d.%d.%d\\t|||\\n&quot;,drug[n].Datepro_year,drug[n].Datepro_mth,drug[n].Datepro_day); printf (&quot;|||\\t 6.药品进货价格: %.2lf\\t\\t|||\\n&quot;,drug[n].purchase_price); printf (&quot;|||\\t 7.药品保质期: %d.%d\\t\\t|||\\n&quot;,drug[n].Date_year,drug[n].Date_mth); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); return ;}void Print_name_acur (){ system (&quot;cls&quot;); for (int i=1;i&lt;=25;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); printf (&quot;|||\\t请输入你要精确查询的名称: \\t\\t|||\\n&quot;); for (int i=1;i&lt;=25;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); int i=1; char str[107]; scanf (&quot;%s&quot;,str); system (&quot;cls&quot;); for (;i&lt;num;i++) if (!strcmp (drug[i].name,str)) { if (drug[i].f=='1') printf (&quot;|||\\t查询结果为: \\t\\t|||\\n&quot;), Print_name_acur_(i); else printf (&quot;|||\\t该药品信息不存在或已被删除！\\t|||\\n&quot;); break; } if (i==num) printf (&quot;|||\\t该药品信息不存在或已被删除！\\t|||\\n&quot;); printf (&quot;|||\\t是否继续精确查询？(Y/N)\\t\\t|||\\n&quot;); getchar (); if (getchar ()=='Y') Print_name_acur (); return ; } //模糊查询 void Print_name_fuzy_ (int n){ for (int i=1;i&lt;=17;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); printf (&quot;|||\\t药品名称: %s\\t\\t|||\\n&quot;,drug[n].name); printf (&quot;|||\\t库存数量: %d\\t\\t|||\\n&quot;,drug[n].quantity); printf (&quot;|||\\t销售价格: %.2lf\\t\\t|||\\n&quot;,drug[n].sale_price); printf (&quot;|||\\t厂家: %s\\t\\t|||\\n&quot;,drug[n].factor); printf (&quot;|||\\t生产日期: %d.%d.%d\\t|||\\n&quot;,drug[n].Datepro_year,drug[n].Datepro_mth,drug[n].Datepro_day); printf (&quot;|||\\t进货价格: %.2lf\\t\\t|||\\n&quot;,drug[n].purchase_price); printf (&quot;|||\\t保质期: %d.%d\\t\\t|||\\n&quot;,drug[n].Date_year,drug[n].Date_mth); printf (&quot;\\n\\n&quot;); return ;}void Print_name_fuzy (){ system (&quot;cls&quot;); for (int i=1;i&lt;=25;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); printf (&quot;|||\\t请输入你要查询的模糊名称: \\t\\t|||\\n&quot;); for (int i=1;i&lt;=25;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); bool tmp=false; char str[107]; scanf (&quot;%s&quot;,str); system (&quot;cls&quot;); sort (drug+1,drug+num); for (int i=1;i&lt;num;i++) if (strstr (drug[i].name,str)!=NULL) { if (drug[i].f=='1') { if (!tmp) printf (&quot;|||\\t查询结果为: \\t\\t|||\\n&quot;); tmp=true; Print_name_fuzy_ (i); } } if (!tmp) printf (&quot;|||\\t未找到相关药品信息！\\t|||\\n&quot;); printf (&quot;|||\\t是否继续模糊查询？(Y/N)\\t|||\\n&quot;); getchar (); if (getchar ()=='Y') Print_name_fuzy (); return ; } //名称查询void Print_name (){ while (true) { system (&quot;cls&quot;); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); printf (&quot;|||\\t请选择查询操作: \\t\\t|||\\n&quot;); printf (&quot;|||\\t1.精确查询 \\t\\t\\t|||\\n&quot;); printf (&quot;|||\\t2.模糊查询 \\t\\t\\t|||\\n&quot;); printf (&quot;|||\\t3.返回上层 \\t\\t\\t|||\\n&quot;); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); int cmd; scanf (&quot;%d&quot;,&amp;cmd); switch (cmd) { case 1: Print_name_acur (); break; case 2: Print_name_fuzy (); break; case 3: return ; } }} //厂家查询 void Print_factor (){ system (&quot;cls&quot;); sort (drug+1,drug+num); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); printf (&quot;|||\\t请选输入要查询的厂家名称: \\t|||\\n&quot;); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); char str[107]; bool tmp=false; scanf (&quot;%s&quot;,str); for (int i=1;i&lt;num;i++) if (!strcmp (drug[i].factor,str)) if (drug[i].f=='1') { if (!tmp) printf (&quot;|||\\t查询结果为: \\t\\t|||\\n&quot;); tmp=true; Print_name_fuzy_ (i); } if (!tmp) printf (&quot;|||\\t未找到该厂家药品信息\\t|||\\n&quot;); printf (&quot;|||\\t是否继续厂家查询？(Y/N)\\t|||\\n&quot;); getchar (); if (getchar ()=='Y') Print_factor (); return ; }void Query (){ while (true) { system (&quot;cls&quot;); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); printf (&quot;|||\\t请选择查询操作: \\t\\t|||\\n&quot;); printf (&quot;|||\\t1.按药品编号 \\t\\t|||\\n&quot;); printf (&quot;|||\\t2.按药品名称 \\t\\t|||\\n&quot;); printf (&quot;|||\\t3.按药品厂家 \\t\\t|||\\n&quot;); printf (&quot;|||\\t4.回到HOME \\t\\t\\t|||\\n&quot;); for (int i=1;i&lt;=21;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); int cmd; scanf (&quot;%d&quot;,&amp;cmd); switch (cmd) { case 1: Print_number (); break; case 2: Print_name (); break; case 3: Print_factor (); break; case 4: system (&quot;cls&quot;); return ; break; } } } //6.统计void Info_ (){ system (&quot;cls&quot;); sort (drug+1,drug+num); for (int i=1;i&lt;=37;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); printf (&quot;|||\\t药品编号 \\t名称 \\t销售数量 \\t成交额 \\t|||\\n&quot;); for (int i=1;i&lt;num;i++) if (drug[i].f=='1') printf (&quot;||| \\t%s \\t\\t%s \\t%d \\t\\t%.2lf\\t\\t|||\\n&quot;,drug[i].serial_number,drug[i].name,drug[i].sale,drug[i].sum); for (int i=1;i&lt;=37;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); for (int i=1;i&lt;num;i++) if (drug[i].f=='1') if (drug[i].quantity&lt;20) printf (&quot;|||\\t\\t%s库存不足，请尽快补货\\t\\t\\t\\t|||\\n&quot;,drug[i].name); for (int i=1;i&lt;=37;i++) printf (&quot;--&quot;); printf (&quot;\\n&quot;); for (int i=1;i&lt;num;i++) if (drug[i].f=='1') if (((drug[i].Date_year-drug[i].Datepro_year)*12+drug[i].Date_mth-drug[i].Datepro_mth)&lt;3) printf (&quot;|||\\t\\t%s保质期将近，请尽快销售\\t\\t\\t\\t|||\\n&quot;,drug[i].name); for (int i=1;i&lt;=37;i++) printf (&quot;--&quot;); printf (&quot;\\n\\n(任意键返回)&quot;); getchar (); getchar (); return ; } void Save_Print (){ sort (drug+1,drug+num); FILE *fp=fopen (&quot;dataout&quot;,&quot;wb&quot;); for (int i=1;i&lt;num;i++) if (drug[i].f=='1') { fwrite(&amp;drug[i].serial_number,sizeof (struct Node),1,fp); fwrite(&amp;drug[i].name,sizeof (struct Node),1,fp); fwrite(&amp;drug[i].factor,sizeof (struct Node),1,fp); fwrite(&amp;drug[i].Datepro_year,sizeof (struct Node),1,fp); fwrite(&amp;drug[i].Datepro_mth,sizeof (struct Node),1,fp); fwrite(&amp;drug[i].Datepro_day,sizeof (struct Node),1,fp); fwrite(&amp;drug[i].purchase_price,sizeof (struct Node),1,fp); fwrite(&amp;drug[i].Date_year,sizeof (struct Node),1,fp); fwrite(&amp;drug[i].Date_mth,sizeof (struct Node),1,fp); fwrite(&amp;drug[i].sum,sizeof (struct Node),1,fp); fwrite(&amp;drug[i].sale,sizeof (struct Node),1,fp); fwrite(&amp;drug[i].f,sizeof (struct Node),1,fp); } fclose (fp); return ;}void Run (){ while (true) { Print_HOME (); printf (&quot;\\n请输入指令编号\\n&quot;); int cmd; scanf (&quot;%d&quot;,&amp;cmd); switch (cmd) { case 1: Add_ (); break; case 2: Del_ (); break; case 3: Modify (); break; case 4: Sale_ (); break; case 5: Query (); break; case 6: Info_ (); break; case 7: Save_Print (); exit (0); break; } }}int main (){ FILE *fp =fopen (&quot;dataout&quot;,&quot;r&quot;); if (fp==NULL) Read_information_1 (); else Read_information_2 (); Run (); return 0;} data.txt 10001 drug1 70 10.00 factor7 2001.1.1 9.00 2001.3 0 0 1 10006 drug6 60 15.00 factor6 2000.6.1 1.00 2001.6 0 0 1 10003 drug3 30 12.00 factor3 2000.3.5 7.00 2001.3 0 0 1 10009 drug9 99 9.99 factor9 2001.9.9 9.00 2001.11 0 0 1 10002 drug2 19 11.00 factor4 2000.2.3 6.00 2001.2 0 0 1 程序设计基础课程报告附件 设计题目：药店药品信息管理系统 1 课程设计目的和要求 药店药品信息管理系统 药店药品信息包含以下信息项:药品编号、药品名称、药品库存数量、药品销售价格、药品厂家、药品生产日期、药品进货价格、药品保质期。 系统的主要功能包括: 1.创建药品信息文件，根据提示输入药品的各项信息，按药品编号对药品信息进行排序，并将排序后的药品信息存储到一个二进制文件中。 2.增加药品信息，在原有药品信息文件的基础上增加新的药品信息，要求:增加后的药品信息仍按编号排序，并继续保存至文件。 3.删除药品信息，提示用户输入要进行删除操作的药品编号，如果在文件中有该信息存在，则将该编号所对应的药品信息删除，否则输出提示信息，并提示用户选择是否继续进行删除操作。 4.修改药品信息，提示用户输入要进行修改操作的药品编号，如果在文件中有该息存在，则将提示用户输入该编号对应的要修改的选项，结果保存至原文件，并提示用户选择是否继续进行修改操作。 5.销售药品，提示用户输入要进行销售操作的药品编号，如果在文件中有该信息存在，则提示用户输入要销售的数量，检查输入数量是否大于库存数量，如果大于则让用户重新输入:然后将该编号所对应的药品库存数量减去销售数量后再重新存入药品库存数量中，完成销售操作。如果在文件中没有该信息存在，则输出提示信息，提示用户选择是否继续进行销售操作。 6.按不同条件对药品信息进行查询操作，输出满足条件的药品信息。 (1)按药品编号查询，输入一个编号，输出对应的药品信息。 (2)按药品名称查询，包括精确查询(输入全名),模糊查询(输入部分名称)。 (3)按药品厂家查询，输入药品厂家名称，输出此厂家的所有药品信息。 7.按不同条件对药品信息进行统计工作。 (1)统计当月各药品销售的数量和成交额。 (2)当某药品库存数量小于20时，进行库存警示，提示用户进行补货处理。 (3)计算各药品距离过期日期的月数，当月数少于3个月的进行销售警示。 2 系统总体设计2.1 系统功能模块图 创建信息模块：用于实现读入外部文件中已有数据 增加信息模块：用于实现读入手动输入药品信息 删除信息模块：用于实现删除已有信息 修改信息模块：用于实现修改已有信息 销售模块：用于实现销售数量和成交额的改变 查询模块：用于实现以不同方式查询药品信息 统计模块：用于实现对药品部分信息的统计 储存模块：用于实现对已修改信息的保存 2.2 数据结构设计系统使用一个数组存放一个集合。结构体类型定义如下： struct Node { char serial_number[107];//编号 char name[107];//名称 int quantity;//数量 double sum;//成交额 int sale;//成交量 double sale_price;//销售价格 double purchase_price;//进货价格 char factor[107];//厂家// int Datepro_year,Datepro_mth,Datepro_day;//生产日期 int Date_year,Date_mth;//保质期（年.月） char f='0';//是否存在 bool operator &lt; (const Node&amp;a) const { return strcmp(this-&gt;serial_number,a.serial_number) == -1; }//重载运算符 以编号为关键字排序 }drug[Size]; 3 系统详细设计3.1 函数说明void Read_information_1 ();读入初始数据 void Read_information_2 ();读入非初始数据 void Print_HOME ();//打印主界面 void Add_ ();//增加药品信息 void Del_ ();//删除药品信息 void Modify ();//修改药品信息 void Sale_ ();//销售药品 void Print_number ();//按照药品编号查询 void Print_name_acur_ (int n) ;//输出下标为n的药品信息（单） void Print_name_acur ();//按照药品名称精确查询 void Print_name_fuzy_ (int n) ;//输出下标为n的药品信息（多） void Print_name_fuzy ();//按照药品名称模糊查询 void Print_name ();//按照药品名称查询 void Print_factor ();//按照厂家名称查询 void Query ();//查询药品信息 void Info_ ();//统计功能 void Save_Print ();//将修改的数据保存至文件 void Run ();//辅助 3.2 函数调用关系 4 测试数据及程序运行情况测试见附件 5 系统存在的问题与不足1.界面不够美观，无法根据数据的不同输出整齐的格式。 2.模糊搜索时使用者输入数据必为目标数据的连续部分。 6 课程设计体会 软件中多数功能的实现用不着多么高深复杂的算法，在于编写者是否拥有较强的逻辑能力 与熟练恰当地运用基础知识。要想切实提高自己的编程能力，应多去参与这样的设计，而 不是只停留在书本与老师平常布置的作业中。","link":"/2019/12/24/%E8%8D%AF%E6%88%BF%E8%8D%AF%E5%93%81%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"title":"interview (Internet professional related)","text":"Reprinted from github—huihut 📖 Github &emsp;&emsp; | &emsp;&emsp; 📚 Docsify 简体中文 &emsp;&emsp; | &emsp;&emsp; English 💡 ON 📚 This repository is a summary of the basic knowledge of recruiting job seekers and beginners in the direction of C / C ++ technology, including language, program library, data structure, algorithm, system, network, link loading library and other knowledge and interview experience, recruitment, internal push, etc. information. 💡 Side directory support methods:📚 Docsify Doc、Github + TOC navigation（TOC preview.png） 📄 Save as PDF: Use the Chrome browser to open the 📚 Docsify document page, shrink the left directory-right click-print-select the target printer is Save as PDF-Save ( Print Preview.png ) 🙏 If there are any errors or improvements in the contents of the warehouse, issues or pr are welcome. Suggestions or discussions can be submitted at # 12. Due to my limited level, the knowledge points in the warehouse are from my original, reading notes, books, blog posts, etc. Non-original has been marked with the source, if there is any omission, please issue an issue. This warehouse follows the CC BY-NC-SA 4.0 agreement, please indicate the source for the reprint, and may not be used for commercial purposes. 📑 Table of contents ➕ C/C++ ⭐️ Effective 📦 STL 〽️ Data Structure ⚡️ Algorithm ❓ Problems 💻 OS ☁️ Computer Network 🌩 Network Programming 💾 Database 📏 Design Pattern ⚙️ Link Loading Library 📚 Books 🔱 C/C++ development direction 💯 Review of Brush Questions Website 📝 Interview Questions Experience 📆 Recruitment time post 👍 Recommend 👬 Contributor 🍭 Support Sponsor 📜 License ➕ C/C++constFunction Modify the variable, indicating that the variable cannot be changed; Modified pointers, divided into pointers to const (pointer to const) and pointers that are constants themselves (const pointer, const pointer); Modified references, references to constants (reference to const), are used for formal parameter types, which avoids copying and function modification of values; Decorate a member function, stating that member variables cannot be modified within the member function. const Pointers and references Pointer Pointer to const A pointer to a constant itself (const pointer) Quote Reference to const There is no const reference because the reference itself is a const pointer (Think of it for convenience) The value modified by const (after const) cannot be changed, such as p2, p3 in the usage example below useconst use 123456789101112131415161718192021222324252627282930313233343536373839404142// classclass A{private: const int a; // constant object member, can only be assigned in the initialization listpublic: // Constructor A() : a(0) { }; A(int x) : a(x) { }; // initialize list // const can be used to distinguish between overloaded functions int getValue(); // ordinary member function int getValue() const; // constant member function, must not modify the value of any data member in the class};void function(){ // object A b; // ordinary object, can call all member functions, update constant member variables const A a; // constant object, can only call constant member functions const A *p = &amp;a; // pointer variable, point to a constant object const A &amp;q = a; // reference to constant object // pointer char greeting[] = &quot;Hello&quot;; char* p1 = greeting; // pointer variable, pointing to a character array variable const char* p2 = greeting; // pointer variable, pointing to a character array constant (char followed by const, indicating that the character pointed to (char) cannot be changed) char* const p3 = greeting; // itself is a constant pointer to a character array variable (const followed by p3, indicating that the p3 pointer itself cannot be changed) const char* const p4 = greeting; // a pointer to a constant itself, pointing to a character array constant}// functionvoid function1(const int Var); // the passed parameters are immutable within the functionvoid function2(const char* Var); // The content pointed to by the parameter pointer is constantvoid function3(char* const Var); // parameter pointer is constantvoid function4(const int&amp; Var); // the reference parameter is constant inside the function// function return valueconst int function5(); // returns a constantconst int* function6(); // returns a pointer variable to a constant, use: const int * p = function6 ();int* const function7(); // returns a constant pointer to a variable, use: int * const p = function7 (); staticFunction Modify ordinary variables, modify the storage area and life cycle of the variables, make the variables stored in the static area, allocate space before the main function runs, if there is an initial value, initialize it with the initial value, if there is no initial value, the system uses the default Value to initialize it. Modify ordinary functions to indicate the scope of the function, which can only be used in the file where the function is defined. When developing a project with multiple people, in order to prevent duplicate names from functions in other people’s namespaces, you can position functions as static. Decorate member variables. Decorate member variables so that all objects hold only one of the variable, and you can access the member without generating an object. Decorate member functions. Decorate member functions so that they can be accessed without generating objects, but non-static members cannot be accessed within static functions. this pointer this pointer is a special pointer hidden in every non-static member function. It points to the object that called the member function. When calling a member function on an object, the compiler first assigns the address of the object to the this pointer, and then calls the member function. Each time the member function accesses a data member, the this pointer is implicitly used. When a member function is called, it is automatically passed an implicit parameter, which is a pointer to the object where the member function is located. The this pointer is implicitly declared as: ClassName * const this, which means that the this pointer cannot be assigned; in the const member function of the ClassName class, the type of the this pointer For: const ClassName * const, this means that the object pointed to by the this pointer cannot be modified (that is, the data members of such objects cannot be assigned); this is not a regular variable, but an rvalue, so you cannot get the address of this (you can’t &amp; this). It is often necessary to explicitly reference the this pointer in the following scenarios: To implement a chained reference to an object; To avoid performing assignments on the same object; When implementing some data structures, such as list. inline functionFeatures Equivalent to writing the contents of the inline function at the call of the inline function; It is equivalent to directly execute the function body without executing the steps of entering the function; Equivalent to a macro, but with more type checking than a macro, it really has function characteristics; The compiler generally does not inline inline functions that include complex operations such as loops, recursion, and switch; Functions defined in class declarations, other than virtual functions, are automatically implicitly treated as inline functions. useinline use 12345678910111213141516171819// Statement 1 (plus inline, recommended)inline int functionName(int first, int second,...);// statement 2 (without inline)int functionName(int first, int second,...);// definitioninline int functionName(int first, int second,...) {/****/};// inside class definition, implicitly inlineclass A { int doA() { return 0; } // implicit inlining}// definition outside the class, need to be explicitly inlinedclass A { int doA();}inline int A::doA() { return 0; } // requires explicit inlining Compiler processing steps for inline functions Copy the inline function body to the inline function call point; Allocate memory space for local variables in the used inline function; Map the input parameters and return values of the inline function to the local variable space of the calling method; If the inline function has multiple return points, turn it into a branch at the end of the inline function code block (using GOTO). Advantages and disadvantagesAdvantages Inline functions, like macro functions, perform code expansion at the callee’s place, eliminating the need to push parameters on the stack, open and recover stack frames, and return results, etc., thereby improving program execution speed. Compared to macro functions, inline functions do security checks or automatic type conversions (as with normal functions) when code is expanded, while macro definitions do not. Declaring a member function that is also defined in a class automatically converts it into an inline function, so inline functions can access class member variables, while macro definitions cannot. Inline functions are debuggable at runtime, while macro definitions are not. Disadvantages Code bloat. Inlining is at the expense of code bloat (copy), eliminating the overhead of function calls. If the time to execute the code in the function body is greater than the cost of the function call, then the efficiency gain will be small. On the other hand, copying the code for each inline function call will increase the total code size of the program and consume more memory space. The inline function cannot be upgraded with the function library upgrade. Changes to the inline function require recompilation, unlike non-inline, which can be linked directly. Whether it is inline or not is beyond the programmer’s control. Inline functions are just suggestions to the compiler. The decision whether to inline functions is up to the compiler. Can a virtual function be an inline function? Are “inline virtual” member functions ever actually “inlined”? A virtual function can be an inline function. Inline can modify a virtual function, but it cannot be inlined when the virtual function exhibits polymorphism. Inlining is recommended by the compiler, and the polymorphism of virtual functions is at runtime. The compiler cannot know which code is called at runtime, so virtual functions cannot be inlined at runtime (runtime). . inline virtual The only time it can be inlined is: the compiler knows which class the object is called (such as Base::who() ), only if the compiler has an actual object instead of a pointer or reference to the object Will happen. Virtual function inline use 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using namespace std;class Base{public: inline virtual void who() { cout &lt;&lt; &quot;I am Base\\n&quot;; } virtual ~Base() {}};class Derived : public Base{public: inline void who() // Implicit inlining when not writing inline { cout &lt;&lt; &quot;I am Derived\\n&quot;; }};int main(){ // The virtual function who () here is called through the concrete object (b) of the class (Base), which can be determined during compilation, so it can be inlined, but whether it is inlined depends on the compilation Device. Base b; b.who(); // The virtual function here is called through a pointer, which is polymorphic and needs to be determined during runtime, so it cannot be inlined. Base *ptr = new Derived(); ptr-&gt;who(); // Because Base has a virtual destructor (virtual ~ Base () {}), when deleting, the Derived destructor is called first, and then the Base destructor is called to prevent memory leaks. delete ptr; ptr = nullptr; system(&quot;pause&quot;); return 0;} volatile1volatile int i = 10; The volatile keyword is a type modifier, and the type variable declared with it indicates that it can be changed by some factors unknown to the compiler (operating system, hardware, other threads, etc.). So using volatile tells the compiler that such objects should not be optimized. Variables declared by the volatile keyword must be fetched from memory each time they are accessed (variables that are not modified by volatile may be fetched from CPU registers due to compiler optimizations) const can be volatile (such as a read-only status register) Pointer can be volatile assert()Assertions are macros, not functions. The prototype of the assert macro is defined in &lt;assert.h&gt; (C), &lt;cassert&gt; (C ++), and its role is to terminate program execution if its condition returns an error. You can turn off assert by defining NDEBUG, but it needs to be at the beginning of the source code, before include &lt;assert.h&gt; . assert () uses 1234#define NDEBUG // Add this line, assert is not available#include &lt;assert.h&gt;assert( p != NULL ); // assert is not available sizeof() sizeof For arrays - get the size of the entire array. sizeof For pointers - get the size of the space occupied by the pointer itself. #pragma pack(n)Set structure, union, and class member variables to be n-byte aligned #pragma pack (n) use 1234567891011#pragma pack(push) // save alignment state#pragma pack(4) // Set to 4 byte alignmentstruct test{ char m1; double m4; int m3;};#pragma pack(pop) // Restore alignment Bit field1Bit mode: 2; // mode is 2 digits A class can define its (non-static) data members as bit-fields, which contain a certain number of binary bits in a bit-field. When a program needs to transfer binary data to other programs or hardware devices, the bit field is usually used. The layout of the bit field in memory is machine-dependent The type of the bit field must be an integer or enumerated type. The behavior of the bit field in a signed type will depend on the implementation. The fetch operator (&amp;) cannot be applied to the bit field, and no pointer can point to the bit field of the class extern “C” Extern-qualified functions or variables are of type extern Variables and functions decorated with extern&quot; C &quot; are compiled and linked in C The function of extern&quot; C &quot; is to let the C ++ compiler treat the code declared by extern&quot; C &quot; as C language code, which can avoid the problem that the code cannot be linked with the symbols in the C language library due to symbol modification. . extern “C” demo 123456789#ifdef __cplusplusextern &quot;C&quot; {#endifvoid *memset(void *, int, size_t);#ifdef __cplusplus}#endif struct with typedef structIn C1234// ctypedef struct Student { int age; } S; Equivalent to 123456// cstruct Student { int age; };typedef struct Student S; At this time S is equivalent to struct Student, but the two identifier namespaces are different. You can also define void Student(){} that does not conflict with struct Student . In C++Because the compiler’s rules for positioning symbols (search rules) have changed, it is different from the C language. First, if struct Student {...}; is defined in the class identifier space, when Student me; is used, the compiler will search the global identifier table. If Student is not found, it will be in the class identifier. search for. That means it can use Student or struct Student, as follows: 123456// cppstruct Student { int age; };void f( Student me ); // correct, the &quot;struct&quot; keyword can be omitted If a function with the same name as Student is defined, Student only represents the function, not the structure, as follows: 12345678910111213typedef struct Student { int age; } S;void Student() {} //Correct, &quot;Student&quot; only represents this function after definition//void S() {} // Error, symbol &quot;S&quot; has been defined as an alias for &quot;struct Student&quot;int main() { Student(); struct Student me; // Or &quot;S me&quot;; return 0;} struct and class in C ++In general, struct is more suitable as an implementation of a data structure, and class is more suitable as an implementation of an object. The difference The most essential difference is the default access control Default inherited access rights. struct is public and class is private. struct as the data structure implementation body, its default data access control is public, and class as the object implementation body, its default member variable access control is private. union unionUnion is a special class that saves space. A union can have multiple data members, but only one data member can have a value at any time. When a member is assigned, other members become undefined. Union has the following characteristics: The default access control character is public May contain constructors and destructors Cannot contain members of reference type Cannot inherit from other classes and cannot be used as a base class Cannot contain virtual functions Anonymous union can directly access union members in the scope where it is defined Anonymous union cannot contain protected members or private members Global anonymous union must be static union demo 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;union UnionTest { UnionTest() : i(10) {}; int i; double d;};static union { int i; double d;};int main() { UnionTest u; union { int i; double d; }; std::cout &lt;&lt; u.i &lt;&lt; std::endl; // Output UnionTest union 10 ::i = 20; std::cout &lt;&lt; ::i &lt;&lt; std::endl; // Output global static anonymous union 20 i = 30; std::cout &lt;&lt; i &lt;&lt; std::endl; // Output of locally anonymous union of 30 return 0;} C implements C ++ classesC implements object-oriented features of C ++ (encapsulation, inheritance, polymorphism) Encapsulation: Use function pointers to encapsulate properties and methods into structures Inheritance: structure nesting Polymorphism: function pointers of parent and child methods are different Can you write object-oriented code in C? [closed] explicit (keyword) explicit constructor modification prevents implicit conversion and copy initialization explicit conversions can prevent implicit conversions, except conversion by context explicit demo 123456789101112131415161718192021222324252627282930313233343536373839404142struct A{ A(int) { } operator bool() const { return true; }};struct B{ explicit B(int) {} explicit operator bool() const { return true; }};void doA(A a) {}void doB(B b) {}int main(){ A a1(1); // OK：direct initialization A a2 = 1; // OK：copy initialization A a3{ 1 }; // OK：direct list initialization A a4 = { 1 }; // OK：copy list initialization A a5 = (A)1; // OK：Allow explicit conversion of static_cast doA(1); // OK：Allow implicit conversion from int to A if (a1); // OK: implicit conversion from A to bool using conversion function A ::operator bool() bool a6（a1）; // OK: implicit conversion from A to bool using conversion function A::operator bool() bool a7 = a1; // OK: implicit conversion from A to bool using conversion function A::operator bool() bool a8 = static_cast&lt;bool&gt;(a1); // OK: static_cast for direct initialization B b1(1); // OK：direct initialization B b2 = 1; // Error: Object modified by explicit constructor cannot be initialized by copying B b3{ 1 }; // OK：direct list initialization B b4 = { 1 }; // Error: Object modified by explicit constructor cannot copy list initialization B b5 = (B)1; // OK: Allow explicit conversion of static_cast doB(1); // Error: Objects whose constructor is explicitly modified cannot be implicitly converted from int to B if (b1); // OK: objects modified by explicit conversion function B::operator bool() can be converted from B to bool by context bool b6(b1); // OK: Explicitly modified conversion function B::operator The object of bool() can be converted from B to bool by context bool b7 = b1; // Error: Objects modified by explicit conversion function B :: operator bool () cannot be implicitly converted bool b8 = static_cast&lt;bool&gt;(b1); // OK: static_cast performs direct initialization return 0;} friend - friend class and friend function Access to private members Destruction of encapsulation Friendship is not transitive One-way friendship There are no restrictions on the form and number of friend declarations usingusing statementA using declaration introduces only one member of a namespace at a time. It allows us to know exactly which name is referenced in the program. Such as: 1using namespace_name :: name; Using declaration of constructorIn C ++ 11, a derived class can reuse the constructor defined by its direct base class. 12345class Derived : Base {public: using Base::Base; /* ... */}; As above using statement, for each constructor of the base class, the compiler generates a derived class constructor corresponding to it (the parameter list is exactly the same). Generates the following type constructor: 1Derived (parms): Base (args) {} using instructionsThe using directive makes all names in a particular namespace visible, so we don’t need to add any prefix qualifiers to them. Such as: 1using namespace_name name; Minimize using directives to pollute namespaces Generally speaking, it is safer to use the using command than the using compile command, because it** imports only the specified name**. If the name conflicts with a local name, the compiler will** issue instructions**. The using compile command imports all names, including names that may not be needed. If there is a conflict with a local name, the local name will override the namespace version, and the compiler will not issue a warning. In addition, the openness of the namespace means that the names of the namespace may be scattered in multiple places, which makes it difficult to know exactly which names have been added. using demo Minimize using directives 1using namespace std; You should use using declarations more often 123int x;std::cin &gt;&gt; x ;std::cout &lt;&lt; x &lt;&lt; std::endl; or 123456using std::cin;using std::cout;using std::endl;int x;cin &gt;&gt; x;cout &lt;&lt; x &lt;&lt; endl; :: scope resolution operatorclassification Global scope (:: name): used before type names (classes, class members, member functions, variables, etc.) to indicate that the scope is a global namespace Class scope character (class :: name): used to indicate that the scope of the specified type is specific to a class Namespace scope (namespace :: name): used to indicate that the scope of the specified type is specific to a namespace :: demo 1234567891011121314151617181920212223int count = 11; // Global (: :) countclass A {public: static int count; // Count (A::count) of class A};int A::count = 21;void fun(){ int count = 31; // Initialize the local count to 31 count = 32; // Set the local count to 32}int main() { ::count = 12; // Test 1: Set the global count to 12 A::count = 22; // Test 2: Set the count of class A to 22 fun(); // Test 3 return 0;} enum - enum typeScoped Enumeration Type1enum class open_modes { input, output, append }; Unscoped enumeration type12enum color { red, yellow, green };enum { floatPrec = 6, doublePrec = 10 }; decltypedecltype keyword is used to check the declared type or expression type and value classification of an entity. grammar: 1decltype ( expression ) decltype demo 1234567891011121314// Tail return allows us to declare the return type after the parameter listtemplate &lt;typename It&gt;auto fcn(It beg, It end) -&gt; decltype(*beg){ / process the sequence return *beg; // return a reference to an element in the sequence}// In order to use template parameter members, you must use typenametemplate &lt;typename It&gt;auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type{ // process the sequence return * beg; // return a copy of an element in the sequence} referencelvalue referenceRegular reference, which generally represents the identity of the object. rvalue referenceAn rvalue reference is a reference that must be bound to an rvalue (a temporary object, an object to be destroyed) and generally represents the value of the object. An rvalue reference implements Move Sementics and Perfect Forwarding. Its main purpose is twofold: Eliminate unnecessary copying of objects when two objects interact, saving computing storage resources and improving efficiency. Ability to define generic functions more concisely. Reference Collapse X &amp; &amp;, X &amp; &amp;&amp;, X &amp;&amp; &amp; can be folded into X &amp; X &amp;&amp; &amp;&amp; can be folded into X &amp;&amp; Macro A macro definition can implement a function similar to a function, but it is not a function after all, and the “parameters” in the brackets in the macro definition are not real parameters. The “parameters” are replaced one-to-one when the macro is expanded . Member initialization listbenefit More efficient: There is no need to call the default constructor once. In some cases it is necessary to use the initialization list: Constant members, because constants can only be initialized and cannot be assigned, so they must be placed in the initialization list Reference types. References must be initialized at the time of definition and cannot be reassigned, so they must also be written in the initialization list. There is no class type for the default constructor, because the initialization list can be used to initialize without having to call the default constructor. initializer_list list initializationInitialize an object with a curly brace initializer list, where the corresponding constructor accepts a std :: initializer_list parameter. initializer_list uses 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt; template &lt;class T&gt;struct S { std::vector&lt;T&gt; v; S(std::initializer_list&lt;T&gt; l) : v(l) { std::cout &lt;&lt; &quot;constructed with a &quot; &lt;&lt; l.size() &lt;&lt; &quot;-element list\\n&quot;; } void append(std::initializer_list&lt;T&gt; l) { v.insert(v.end(), l.begin(), l.end()); } std::pair&lt;const T*, std::size_t&gt; c_arr() const { return {&amp;v[0], v.size()}; // Copy the list initialization in the return statement // this does not use std :: initializer_list }}; template &lt;typename T&gt;void templated_fn(T) {} int main(){ S&lt;int&gt; s = {1, 2, 3, 4, 5}; // copy initialization s.append({6, 7, 8}); // list initialization in function call std::cout &lt;&lt; &quot;The vector size is now &quot; &lt;&lt; s.c_arr().second &lt;&lt; &quot; ints:\\n&quot;; for (auto n : s.v) std::cout &lt;&lt; n &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;Range-for over brace-init-list: \\n&quot;; for (int x : {-1, -2, -3}) // auto rules make this band for work std::cout &lt;&lt; x &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; auto al = {10, 11, 12}; // special rules for auto std::cout &lt;&lt; &quot;The list bound to auto has size() = &quot; &lt;&lt; al.size() &lt;&lt; '\\n'; // templated_fn({1, 2, 3}); // Compile error! &quot;{1, 2, 3}&quot; is not an expression, // it has no type, so T cannot infer templated_fn&lt;std::initializer_list&lt;int&gt;&gt;({1, 2, 3}); // OK templated_fn&lt;std::vector&lt;int&gt;&gt;({1, 2, 3}); // also OK} Object-orientedObject-oriented programming (OOP) is a model of program programming with object concepts, and it is also an abstract approach to program development. Three Object-Oriented Features-Encapsulation, Inheritance, and Polymorphism EncapsulationEncapsulate objective things into abstract classes, and classes can only use their own data and methods for trusted classes or objects to operate, and hide untrusted information. Keywords: public, protected, private. Do not write defaults to private. public members: can be accessed by any entity protected members: only allowed to be accessed by subclasses and member functions of this class private members: only accessible by member functions, friend classes, or friend functions of this class Inheritance Base class (parent class) ——&gt; derived class (subclass) Polymorphism Polymorphism, that is, multiple states (morphology). In simple terms, we can define polymorphism as the ability of a message to be displayed in multiple forms. Polymorphism is based on encapsulation and inheritance. C polymorphism classification and implementation: Ad-hoc Polymorphism (compile-time): function overload, operator overload Subtype Polymorphism (runtime): virtual function Parametric Polymorphism (compile-time): class template, function template Coercion Polymorphism (compilation / runtime): basic type conversion, custom type conversion The Four Polymorphisms in C++ Static polymorphism (compile time / early binding)Function overloading 123456class A{public: void do(int a); void do(int a, int b);}; Dynamic polymorphism (runtime / late binding) Virtual functions: decorate member functions with virtual to make them virtual note: Ordinary functions (non-class member functions) cannot be virtual functions Static functions (static) cannot be virtual functions The constructor cannot be a virtual function (because when the constructor is called, the virtual table pointer is not in the object’s memory space, the virtual table pointer must be formed after the constructor is called) An inline function cannot be a virtual function when it shows polymorphism. For an explanation, see: Can a virtual function be an inline function? Dynamic polymorphic demo 123456789101112131415161718192021222324252627282930313233class Shape // shape class{public: virtual double calcArea() { ... } virtual ~Shape();};class Circle : public Shape // circle class{public: virtual double calcArea(); ...};class Rect : public Shape // rectangle class{public: virtual double calcArea(); ...};int main(){ Shape * shape1 = new Circle(4.0); Shape * shape2 = new Rect(5.0, 6.0); shape1-&gt;calcArea(); // call the method in the circular class shape2-&gt;calcArea(); // call the method in the rectangle class delete shape1; shape1 = nullptr; delete shape2; shape2 = nullptr; return 0;} Virtual destructorThe virtual destructor is to resolve the pointer of the base class to the derived class object, and delete the derived class object with the pointer of the base class. Virtual destructor demo 123456789101112131415161718192021class Shape{public: Shape(); // Constructor cannot be virtual virtual double calcArea(); virtual ~Shape(); // virtual destructor};class Circle : public Shape // circle class{public: virtual double calcArea(); ...};int main(){ Shape * shape1 = new Circle(4.0); shape1-&gt;calcArea(); delete shape1; // Because Shape has a virtual destructor, when delete deletes the memory, it first calls the subclass destructor and then the base class destructor to prevent memory leaks. shape1 = NULL; return 0；} Pure virtual functionsA pure virtual function is a special kind of virtual function. You cannot give a meaningful implementation to a virtual function in a base class. Instead, you declare it as a pure virtual function. Its implementation is left to the derived classes of the base class. 1virtual int A() = 0; Virtual functions, pure virtual functions If a virtual function is declared in the class, this function is implemented, even if it is empty, its role is to allow this function to be overridden in its subclasses, so that the compiler can use Late binding to achieve polymorphism. A pure virtual function is just an interface. It is a function declaration. It must be left in a subclass to implement it. Virtual functions can not be overridden in subclasses; but pure virtual functions must be implemented in subclasses to instantiate subclasses. The virtual function class is used for “implementation inheritance”. Inheriting the interface also inherits the implementation of the parent class. Pure virtual functions focus on the uniformity of the interface, and the implementation is done by subclasses. A class with a pure virtual function is called an abstract class. This class cannot directly generate objects. It can only be used after being inherited and rewriting its virtual function. After an abstract class is inherited, subclasses can continue to be abstract or ordinary classes. Virtual base class is the base class in virtual inheritance, see below for details. CSDN . C++ And connection of virtual functions and pure virtual functions Virtual function pointer, virtual function table Virtual function pointer: In an object containing a virtual function class, it points to a virtual function table, which is determined at runtime. Virtual function table: in the program read-only data section (.rodata section, see: object file storage structure），Stores virtual function pointers. If the derived class implements a virtual function of the base class, the virtual function pointer of the original base class is overwritten in the virtual table, and is created according to the class declaration at compile time. C++ Function (table) implementation mechanism and simulation implementation in C language Virtual inheritanceVirtual inheritance is used to solve the problem of diamond inheritance under multiple inheritance conditions (wasting storage space and ambiguity). The underlying implementation principle is related to the compiler. It is generally implemented by ** virtual base class pointer ** and ** virtual base class table **. Each virtual inherited subclass has a virtual base class pointer (occupies the storage space of a pointer) , 4 bytes) and virtual base class table (does not occupy storage space of class objects) (It should be emphasized that the virtual base class will still have a copy in the subclass, but there is only one copy at most, not not in the subclass. Inside); when the subclass of virtual inheritance is inherited as the parent class, the pointer of the virtual base class will also be inherited. In fact, vbptr refers to a virtual base table pointer. This pointer points to a virtual base table. The virtual table records the offset address of the virtual base class and this class. Offset address, so that the virtual base class members are found, and virtual inheritance does not need to maintain two identical copies of the public base class (virtual base class) like ordinary multiple inheritance, saving storage space. Virtual inheritance, virtual functions Similarities: Both use virtual pointers (both occupy class storage space) and virtual tables (both do not occupy class storage space) the difference: Virtual inheritance The virtual base class still exists in the inherited class and only takes up storage space The virtual base class table stores the offset of the virtual base class relative to the direct inherited class Virtual function Virtual functions do not take up storage space The virtual function table stores the virtual function address Template classes, member templates, virtual functions Virtual functions can be used in template classes The member template of a class (whether it is a normal class or a class template) (it is a member function of the template) cannot be a virtual function Abstract class, interface class, aggregate class Abstract class: a class containing pure virtual functions Interface class: Abstract class containing only pure virtual functions Aggregation classes: Users can directly access their members and have a special form of initialization syntax. Meet the following characteristics: All members are public No constructor is defined No in-class initialization No base class, no virtual function Memory allocation and managementmalloc, calloc, realloc, alloca malloc: apply for a specified number of bytes of memory. The initial value in the requested memory is uncertain. calloc: For an object of a specified length, allocate memory that can hold the specified number of objects. Each bit of the requested memory is initialized to 0. realloc: change the previously allocated memory length (increase or decrease). When increasing the length, it may be necessary to move the contents of the previously allocated area to another sufficiently large area, while the initial value in the newly added area is uncertain. alloca: apply for memory on the stack. When the program pops out of the stack, it will automatically release memory. However, it should be noted that alloca is not portable and difficult to implement on machines without traditional stacks. alloca should not be used in programs that must be widely ported. C99 supports variable-length arrays (VLAs) and can be used instead of alloca. malloc, freeUsed to allocate and release memory malloc, free use Apply for memory and confirm whether the application is successful 12char *str = (char*) malloc(100);assert(str != nullptr); Pointer is empty after freeing memory 12free(p); p = nullptr; new、delete new / new []: Do two things, first call malloc at the bottom to allocate memory, and then call the constructor (create the object). delete / delete []: also complete two things, first call the destructor (clean up resources), and then call free to free up space at the bottom. new automatically calculates the number of bytes required when applying for memory, and malloc requires us to enter the number of bytes of the requested memory space ourselves. new, delete demo Apply for memory and confirm whether the application is successful 123456int main(){ T* t = new T(); // memory allocation first, then constructor delete t; // destructor first, then release memory return 0;} Positioning newPositioning new (placement new) allows us to pass additional address parameters to new to create objects in a pre-specified memory area. 1234new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] { braced initializer list } place_address is a pointer initializers provides a (possibly empty) comma-separated list of initial values delete this - Is it legal? Is it legal (and moral) for a member function to say delete this? Legal, but: It must be guaranteed that this object is allocated via new (not new[], not placement new, not on the stack, not global, not a member of other objects) You must ensure that the member function that calls delete this is the last member function that calls this You must ensure that the member function does not call this after delete this Make sure no one uses it after delete this How to define a class that can only generate objects on the heap (on the stack)? How to define a class that can only generate objects on the heap (on the stack)? Only on the heapMethod: Make the destructor private Reason: C ++ is a static binding language. The compiler manages the life cycle of objects on the stack. When the compiler allocates stack space for class objects, it first checks the accessibility of the class’s destructor. If the destructor is not accessible, the object cannot be created on the stack. Only on the stackMethod: overload new and delete as private Reason: The object is generated on the heap using the new keyword operation. The process is divided into two stages: the first stage uses new to find available memory on the heap and allocates it to the object; the second stage calls the constructor to generate the object. By setting the new operation to private, the first phase cannot be completed, and objects cannot be generated on the heap. Smart pointerIn the C ++ Standard Library (STL)header file：#include &lt;memory&gt; C++ 981std::auto_ptr&lt;std::string&gt; ps (new std::string(str))； C++ 11 shared_ptr unique_ptr weak_ptr auto_ptr (Deprecated by C ++ 11) Class shared_ptr implements the concept of shared ownership. Multiple smart pointers point to the same object, and that object and its associated resources are released when the “last reference is destroyed”. In order to perform the above work in more complex scenarios, the standard library provides auxiliary classes such as weak_ptr, bad_weak_ptr, and enable_shared_from_this. Class unique_ptr implements the concept of exclusive ownership or strict ownership, ensuring that only one smart pointer can point to the object at a time. You can transfer ownership. It is especially useful for avoiding resource leaks, such as forgetting to delete after new. shared_ptrMultiple smart pointers can share the same object, and the last one of the object has the responsibility to destroy the object and clean up all resources related to the object. Support custom deleter, which can prevent Cross-DLL problems (object is created by new in dynamic link library (DLL), but deleted by another DLL), and the mutex is automatically released weak_ptrweak_ptr allows you to share but does not own an object. Once the last smart pointer that owns the object loses ownership, any weak_ptr will automatically become empty. Therefore, in addition to the default and copy constructors, weak_ptr only provides a “accept a shared_ptr” constructor. The problem of cycles of references (two objects that have not been used actually refer to each other, making them appear to be in the “used” state) unique_ptrunique_ptr is a type that has only been available since C ++ 11, and is a smart pointer that can help avoid resource leaks during exceptions. Using exclusive ownership means that you can ensure that an object and its corresponding resource are owned by only one pointer at a time. Once you own the destroyed or programmed empty, or start owning another object, the previously owned object will be destroyed and any corresponding resources will be released. unique_ptr is used instead of auto_ptr auto_ptrDeprecated by c ++ 11 due to lack of language features such as std::move semantics “for construction and assignment”, and other flaws. auto_ptr compared to unique_ptr auto_ptr can be assigned a copy, and ownership is transferred after copying; unqiue_ptr has no copy assignment semantics, but implements move semantics; auto_ptr objects cannot manage arrays (destructive call delete), unique_ptr can manage arrays (destructive calldelete []); Casting Operator MSDN. Casting Operator static_cast For non-polymorphic conversions Do not perform runtime type checking (conversion security is not as good as dynamic_cast) Usually used to convert numeric data types (such as float-&gt; int) You can move the pointer throughout the class hierarchy. It is safe (upward conversion) for a child class to be converted to a parent class, and it is not safe to convert a parent class to a child class (because a child class may have fields or methods that are not in the parent class) Upcast is an implicit conversion. dynamic_cast For polymorphic type conversions Perform line runtime type checking Only applicable to pointers or references Conversion of ambiguous pointers will fail (return nullptr), but no exception will be thrown You can move the pointer throughout the class hierarchy, including up conversion, down conversion const_cast Used to remove const, volatile, and __unaligned features (such as converting const int to int) reinterpret_cast Simple reinterpretation for bits Misuse of the reinterpret_cast operator can be very risky. Unless the required conversion itself is low-level, you should use one of the other cast operators. Allows conversion of any pointer to any other pointer type (such as char * to int * or One_class * to Unrelated_class *, but it is not itself safe) Also allows conversion of any integer type to any pointer type and reverse conversion. The reinterpret_cast operator cannot lose const, volatile, or __unaligned attributes. A practical use of reinterpret_cast is in a hash function, which is to map values to indexes by making two different values hardly end with the same index. bad_cast The dynamic_cast operator throws a bad_cast exception because the cast to a reference type fails. bad_cast demo 123456try { Circle&amp; ref_circle = dynamic_cast&lt;Circle&amp;&gt;(ref_shape); } catch (bad_cast b) { cout &lt;&lt; &quot;Caught: &quot; &lt;&lt; b.what(); } Runtime Type Information (RTTI)dynamic_cast For polymorphic type conversions typeid The typeid operator allows determining the type of an object at runtime type \\ _id returns a reference to a type \\ _info object If you want to get the data type of the derived class through the pointer of the base class, the base class must have a virtual function Can only get the actual type of the object type_info The type_info class describes the type information generated by the compiler in the program. Objects of this class can effectively store pointers to the names of types. The type_info class can also store encoded values suitable for comparing whether two types are equal or comparing their permutation order. The encoding rules and permutation order for the types are unspecified and may vary from program to program. Header file: typeinfo typeid, type_info demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;using namespace std;class Flyable // can fly{public: virtual void takeoff() = 0; // take off virtual void land() = 0; // land};class Bird : public Flyable // bird{public: void foraging() {...} // foraging virtual void takeoff() {...} virtual void land() {...} virtual ~Bird(){}};class Plane : public Flyable // airplane{public: void carry() {...} // carry virtual void takeoff() {...} virtual void land() {...}};class type_info{public: const char* name() const; bool operator == (const type_info &amp; rhs) const; bool operator != (const type_info &amp; rhs) const; int before(const type_info &amp; rhs) const; virtual ~type_info();private: ...};void doSomething(Flyable *obj) // do something{ obj-&gt;takeoff(); cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl; // output the type of the incoming object（&quot;class Bird&quot; or &quot;class Plane&quot;） if(typeid(*obj) == typeid(Bird)) // determine object type { Bird *bird = dynamic_cast&lt;Bird *&gt;(obj); // object conversion bird-&gt;foraging(); } obj-&gt;land();}int main(){ Bird *b = new Bird(); doSomething(b); delete b; b = nullptr; return 0;} ⭐️ EffectiveEffective C++ Treat C ++ as a language federation (C, Object-Oriented C ++, Template C ++, STL) It is better to replace the preprocessor with a compiler (try to replace # define with const, enum, inline) Use const whenever possible Make sure that the object has been initialized before being used (the copy constructor is more efficient than the default copy assignment after construction) Understand what functions C ++ silently writes and calls (the compiler secretly creates a default constructor, copy constructor, copy assignment operator, destructor for class) If you don’t want to use the automatically generated function of the compiler, you should explicitly reject it (declare member functions that you don’t want to use as private and do not implement them) Declare a virtual destructor for the polymorphic base class (if the class has any virtual functions, it should have a virtual destructor) Don’t let the exception escape the destructor (the destructor should swallow and not propagate the exception, or end the program, instead of spitting out the exception; if you want to handle the exception, you should handle it in a non-destructed ordinary function) Never call virtual functions during construction and destruction (because such calls never descend to the derived class) Let operator = return a reference to * this (for chained assignment) Handle “self-assignment” in operator = When assigning an object, be sure to copy “all member variables within the object” and “all base class components” (call the base class copy constructor) Manage resources by objects (resources are obtained in the constructor and released in the destructor. It is recommended to use smart pointers. The resource acquisition time is the initialization time (Resource Acquisition Is Initialization (RAII)). Be careful with copying behavior in resource management classes (the general RAII class copying behavior is: inhibit copying, reference counting, deep copying, transfer of bottom resource ownership (similar to auto_ptr)) Provide access to raw resources in the resource management class (access to raw resources may be explicitly or implicitly converted, in general, display conversion is safer, and implicit conversion is more convenient for customers) Use the same form when using new and delete in pairs ([] in new then delete [], new without [] and delete) Store the newed object in (into) a smart pointer in a separate statement (if you do not do this, it may cause undetectable resource leaks due to compiler optimizations) Make interfaces easy to use correctly and not easy to be misused (Promote normal use: Consistency of interfaces, compatible behavior of built-in types; Prevent misuse: Create new types, Restrict operation on types, Constrain object values Eliminate the client’s resource management responsibilities) Designing a class is like designing a type, and you need to consider object creation, destruction, initialization, assignment, value passing, legal values, inheritance relationships, conversion, generalization, and so on. Prefer pass-by-reference-to-const instead of pass-by-value (the former is usually more efficient and avoids slicing problems, but not applicable to built-in types, STL iterators, function objects) When an object must be returned, do not deliberately return its reference (never return pointer or reference to a local stack object, or return reference to a heap-allocated object, or return pointer or reference to a local static object, which may be required at the same time. Multiple such objects.) Declare member variables as private (for encapsulation, consistency, precise control over reads and writes, etc.) Rather replace the member function with non-member and non-friend (which can increase packaging flexibility, packaging flexibility, and functional extensibility) If all parameters (including the metaphoric parameter pointed to by this pointer) require type conversion, please use a non-member function for this Consider writing a swap function that does not throw exceptions Delay the appearance of variable definitions as much as possible (to increase program clarity and improve program efficiency) Do as few transformations as possible (old: (T) expression,T (expression); new:const_cast &lt;T&gt; (expression),dynamic_cast &lt;T&gt; (expression),reinterpret_cast &lt;T &gt; (expression),static_cast &lt;T&gt; (expression);; try to avoid transformation, pay attention to efficiency and avoid dynamic_casts, try to design so that no transformation is needed, the transformation can be encapsulated into a function, rather a new type of transformation is preferred) Avoid using handles (including references, pointers, iterators) to point inside the object (to increase encapsulation, make const member functions behave more like const, and reduce “dangling handles” (such as dangling pointers, etc.) possibility) It is worthwhile to work for “exception safety” (Exception-safe functions) will not leak resources or allow any data structure to break even if an exception occurs. There are three possible guarantees: basic, strong Type, do not throw abnormal type) Thorough understanding of inlining inside and outside (inlining is a compile-time behavior in most C ++ programs; whether an inline function is really inline depends on the compiler; most compilers refuse to be too complex (such as with loops or recursion) ) Function inlining, and all calls to virtual functions (unless they are the most bland) will also cause inlining to fail; the code expansion caused by inline may cause a loss of efficiency; inline functions cannot be upgraded with the upgrade of the library) Minimize the compilation dependencies between files (if you can use object references or object pointers to complete the task, do not use objects; if possible, try to replace class definitions with class declarations; provide differences between declarative and definitions Header file) Make sure your public inheritance moulds out an is-a (is a) relationship (applicable to everything in base classes must apply to derived classes, because every derived class object is also a base class object ) Avoid obscuring inherited names (you can use using declarative or forwarding functions to make the obscure names goodbye) Distinguish between interface inheritance and implementation inheritance (under public inheritance, derived classes always inherit the interface of the base class; pure virtual functions only specify interface inheritance; non-pure virtual virtual functions specify interface inheritance and default implementation inheritance; non -virtual function specifies interface inheritance and mandatory implementation inheritance) Consider alternatives to virtual functions (such as the non-virtual interface (NVI) approach of the Template Method design pattern, replacing virtual functions with “function pointer member variables” and replacing virtual functions with tr1 :: function member variables, Replace the virtual function in the inheritance system with another virtual function in the inheritance system) Never redefine inherited non-virtual functions Never redefine inherited default parameter values, because the default parameter value is statically bound (statically bound), but the virtual function is dynamically bound (dynamically bound) Through compound molding has-a (one) or “implemented according to something” (in the application domain, compound means has-a (there is one); in the implementation domain, compound means (Is-implemented-in-terms-of) Use private inheritance wisely and prudently (private inheritance means is-implemented-in-terms-of (implemented according to something)), use composite whenever possible, when the derived class needs to access the members of the protected base class, or needs to re- Use private inheritance when defining inherited virtual functions, or when empty base optimization is required) Use multiple inheritance wisely and prudently (multiple inheritance is more complex than single inheritance, may lead to new ambiguities, and the need for virtual inheritance, but it does have a legitimate purpose, such as “public inheritance of an interface class” and “private inheritance A class that assists implementation “; virtual inheritance can solve the ambiguity of diamond inheritance under multiple inheritance, but it will increase the size, speed, complexity of initialization and assignment, etc.) Understand implicit interfaces and compile-time polymorphism (both classes and templates support interfaces and polymorphism); class interfaces are explicit with signatures as the center, and polymorphism is through virtual Functions occur at runtime; the interface of a template is implicit based on valid expressions, and polymorphism occurs through comprehension of templates and function overloading resolution at compile time) Understand the double meaning of typename (declared that the template type parameter is that the meaning of the prefix keywords class and typename are exactly the same; use the keyword typename to identify the nested dependent type name, but not in the base class lists or members Use it as a base class modifier in the member initialization list) Learn to deal with the names in templated base classes (you can refer to the member names in base class templates via this-&gt; in derived class templates, or by a clearly written “base class qualification modifier” ) Extract parameter-independent code from templates (code bloat caused by non-type template parameters can often be eliminated by replacing template parameters with function parameters or class member variables; because of type parameters The resulting code bloat can often be achieved by having implementation types with identical binary representations share implementation codes) Use member function templates to accept all compatible types (please use member function templates to generate functions that “accept all compatible types”; declare member templates for “generalized copy construction” or “generalized assignment operation” Also need to declare the normal copy constructor and copy assignment operator) When you need type conversion, please define non-member functions for the template (when we write a class template, and the “relevant to this template” function provided by it supports “implicit type conversion of all parameters”, please those functions Defined as “friend function inside class template”) Please use traits classes to represent type information (traits classes use templates and “templates specialization” to make “type-related information” available at compile time, and use overloading (overloading) to implement if … else on types at compile time test) Recognize template metaprogramming (TMP, template metaprogramming) More Effective c++ Carefully distinguish between pointers and references (when you know that you need to point to something and never change to point to other things, or when you implement an operator whose syntax requirements cannot be met by pointers, you should choose references; At any other time, use pointers) It is best to use C ++ cast operators (static_cast, const_cast, dynamic_cast, reinterpret_cast) Never polymorphically treat arrays (polymorphism and pointer arithmetic cannot be mixed; array objects almost always involve pointer arithmetic, so arrays and polymorphism should not be mixed) Don’t provide default constructor if necessary (to avoid fields in the object being initialized meaninglessly) Be alert to custom “type conversion functions” (single argument constructors can be avoided by simple methods (explicit keywords) or proxy classes); implicit type conversion operators can be changed to explicit Member function to avoid unexpected behavior) Distinguish the prefix and postfix forms of the increment / decrement operator (pre-accumulate and take out and return a reference; post-preparation take and accumulate and return a const object; when processing user-defined types Should use pre-increment as much as possible; post-implementation should be based on its pre-brother) Never overload the &amp;&amp;, ||, and , operators (&amp;&amp; and || overloading will replace “sudden-semantic semantics” with “function call semantics”; The overload of does not guarantee that the left expression must be evaluated earlier than the right expression) Understand the different meanings of new and delete ( new operator, operator new, placement new, operator new[] ; delete operator, operator delete, destructor, operator delete[] ) Use destructors to avoid leaking resources (freeing resources when destructors can avoid resource leaks during exceptions) Prevent resource leaks in constructors (because C ++ will only destruct objects that have already been constructed, the constructor can use try … catch or auto_ptr (and similar classes) to handle resource leaks when exceptions occur) Prohibit exceptions from flowing out of destructors (reason: first, avoid the terminate function being called in the stack-unwinding mechanism of exception propagation; second, help ensure that destructors complete everything they should do) Understand the difference between “throwing an exception” and “passing a parameter” or “calling a virtual function” (first, exception objects are always copied (except by pointer), if you catch even by value It is copied twice, but the object passed to the function parameter does not necessarily have to be copied. Second, the object that is “thrown as exceptions” has fewer allowed type conversion actions than the object “passed to the function”; Third, the catch clause is checked by the compiler for its “order in which it appears in the source code”. The first match succeeds and is executed, and a virtual function is called. Function “ Capture exceptions by by reference (to avoid the problem of object deletion and cutting of exception objects, retain the ability to catch standard exceptions, and restrict the number of times an exception object needs to be copied) Use exception specifications wisely (exception specifications provide an excellent description of what kind of exceptions a function expects to throw; there are also some disadvantages, including that the compiler only checks them locally and is easy to inadvertently violate them. Prevent higher-level exception handlers from handling unexpected exceptions) Understand the cost of exception handling (roughly estimated, if try block is used, the overall code will expand by about 5% -10%, and the execution speed will also decrease by this number; therefore, please limit your use of try block and exception specifications Must-use locations, and throw exceptions only in case of real exceptions) Keep in mind the 80-20 rule (the overall performance of software is almost always determined by a small part of its constituent elements (codes), and the code that consumes resources can be identified using a program profiler) Consider using lazy evaluation (can be applied to: Reference Counting to avoid unnecessary object copying, distinguish read and write actions of operator [] to do different things, Lazy Fetching (easy (Remove) to avoid unnecessary database reads, and Lazy Expression Evaluation (to avoid unnecessary numerical calculations) Amortize the expected computational cost (when you must support certain operations whose structure is almost always required, or when the results are often required multiple times, over-eager evaluation can improve program efficiency ) Google C ++ Style Guide English: Google C ++ Style Guide Chinese: C ++ Style Guide Other Bjarne Stroustrup FAQ C ++ style and trick FAQ for Bjarne Stroustrup 📦 STLSTL indexSTL Method Meaning Index STL container Container Underlying data structure Time complexity Unordered Can not be repeated Other array array random read and change O(1) unordered repeatable support random access vector Array Random read, tail insertion, tail deletion O(1) head insertion, head Delete O(n) Unordered Repeatable Support random access deque Dual-end queue End-to-end insertion, end-to-end deletion O(1) Unordered Repeatable One central control + Multiple buffers, support rapid addition and deletion at the beginning and end, support random access forward_list One-way linked list Insert and delete O(1) Unordered Repeatable Random access is not supported list Doubly linked list Insert / delete O(1) Unordered Repeatable Does not support random access stack deque / list top insert, top delete O(1) unordered repeatable deque or list closed head The end is open. The reason why the vector is not used should be that the capacity is limited, and the expansion takes time. queue deque / list tail insertion, head deletion O(1) unordered repeatable deque or list closure The head end is open. The reason why the vector is not used should be that the capacity is limited, and the expansion takes time. priority_queue vector + max-heap Insert, delete O(log2n) Ordered Repeatable vector container + heap processing rules set Red and Black Tree Insert, delete, find O(log2n) Ordered Not repeatable multiset Red and Black Tree Insert, delete, find O(log2n) Ordered Repeatable map Red and Black Tree Insert, delete, find O(log2n) Ordered Not repeatable multimap Red and Black Tree Insert, delete, find O(log2n) Ordered Repeatable unordered_set Hash Table Insert, Delete, Find O(1) Worst O(n) Unordered Not Repeatable unordered_multiset Hash Table Insert, Delete, Find O(1) Worst O(n) Unordered Repeatable unordered_map Hash Table Insert, Delete, Find O(1) Worst O(n) Unordered Not Repeatable unordered_multimap Hash Table Insert, Delete, Find O(1) Worst O(n) Unordered Repeatable STL Algorithm Algorithm Low-level algorithm Time complexity Can not be repeated find Sequence search O(n) Repeatable sort Introspection sorting O(n*log2n) Repeatable 〽️ Data StructureSequence structureSequential stack（Sequence Stack）SqStack.cpp Sequential stack data structures and pictures 123456typedef struct { ElemType *elem; int top; int size; int increment;} SqStack; queue（Sequence Queue）Queue data structure 123456typedef struct { ElemType * elem; int front; int rear; int maxSize;}SqQueue; Acyclic queueAcyclic queue picture SqQueue.rear++ Circular queueCircular queue picture SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize Sequence table（Sequence List）SqList.cpp Sequence table data structure and pictures 123456typedef struct { ElemType *elem; int length; int size; int increment;} SqList; Chain structureLinkList.cpp LinkList_with_head.cpp Chained data structure 1234typedef struct LNode { ElemType data; struct LNode *next;} LNode, *LinkList; Chain queue（Link Queue）Chain queue picture Chained representation of a linear listSingly-Linked list（Link List）Singly-linked list picture Doubly linked list（Du-Link-List）Doubly-linked list picture Circular linked list（Cir-Link-List）Circular-linked list picture Hash tableHashTable.cpp ConceptHash function：H(key): K -&gt; D , key ∈ K Construction method Direct Addressing Divided remainder method Digital analysis method Folding method The square method Collision resolution method Chain address method: single linked list linked with the same key Open Addressing Linear detection method: same key-&gt; put to the next position of key，Hi = (H(key) + i) % m Secondary detection method: same key-&gt; put to Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2） Random detection：H = (H(key) + Pseudo-random number) % m Hash table data structure for linear probingHash table data structure and pictures for linear detection 123456789101112typedef char KeyType;typedef struct { KeyType key;}RcdType;typedef struct { RcdType *rcd; int size; int count; bool *tag;}HashTable; RecursionConceptFunction calls itself directly or indirectly Recursion and Divide Divide and Conquer Breakdown of the problem Problem size decomposition Half search (recursive) Merge sort (recursive) Quick sort (recursive) Recursion and Iteration Iteration: use the old value of the variable repeatedly to push out the new value Search in half (iterative) Merge sort (iterative) Generalized tableHead and tail linked list storage representationHead and tail linked list storage representations and pictures for generalized tables 12345678910111213141516// Head-to-tail linked list storage representation of generalized listtypedef enum {ATOM, LIST} ElemTag;// ATOM == 0: atom, LIST == 1: child tabletypedef struct GLNode { ElemTag tag; // public part, used to distinguish atomic nodes from table nodes union { // joint part of atomic node and table node AtomType atom; // atom is the range of atom nodes, AtomType is defined by the user struct { struct GLNode *hp, *tp; } ptr; /// ptr is the pointer field of the table node, prt.hp and ptr.tp point to the table header and table tail respectively } a;} *GList, GLNode; Extended linear linked list storage representationExtended linear linked list storage representations and pictures 1234567891011121314// Extended linear linked list storage representation of generalized tablestypedef enum {ATOM, LIST} ElemTag;// ATOM == 0: atom, LIST == 1: child tabletypedef struct GLNode1 { ElemTag tag; // public part, used to distinguish atomic nodes from table nodes union { // joint part of atomic node and table node AtomType atom; // range of atom nodes struct GLNode1 *hp; // table pointer pointer } a; struct GLNode1 *tp; // Equivalent to next of a linear linked list, pointing to the next } *GList1, GLNode1; Binary treeBinaryTree.cpp properties Up to 2(i-1) nodes at the i-th level of a non-empty binary tree (i&gt; = 1) Binary tree with depth k up to 2k-1 node (k &gt;= 1) The number of nodes with degree 0 is n0, and the number of nodes with degree 2 is n2, then n0 = n2 + 1 Full binary tree depth with n nodes k = ⌊ log 2 &lt;/ sub&gt; (n) ⌋ + 1 For the node numbered i (1 &lt;= i &lt;= n) in a complete binary tree with n nodes If i = 1, it is the root, otherwise the parents are ⌊ i / 2 ⌋ If 2i &gt; n, node i has no left child, otherwise the child number is 2i If 2i + 1&gt; n, the i node has no right child, otherwise the child number is 2i + 1 Storage structureBinary tree data structure 12345typedef struct BiTNode{ TElemType data; struct BiTNode *lchild, *rchild;}BiTNode, *BiTree; Sequential storageBinary tree sequential storage pictures Chained storageBinary tree chain store pictures Traversal Sequence traversal In-order traversal Subsequent traversals Hierarchical traversal Categories Full Binary Tree Complete binary tree (heap) Big top heap: root&gt; = left &amp;&amp; root&gt; = right Small top heap: root &lt;= left &amp;&amp; root &lt;= right Binary search tree (binary sort tree): left &lt;root &lt;right Balanced binary tree (AVL tree): | Left subtree tree height-Right subtree tree height | &lt;= 1 Least Imbalanced Tree: Balanced Binary Tree Inserting New Nodes Causes Imbalanced Subtree: Adjustment: LL type: left-handed child of the root RR type: right child of the root LR type: Left-handed child of the root, left-handed RL type: Left child of right child, turn right first, then left Other trees and forestsThe storage structure of the tree Parental notation Parental notation Child brother notation And checkA set of disjoint subsets S = {S1, S2, …, Sn} Balanced Binary Tree (AVL Tree)nature | Left Subtree Tree Height-Right Subtree Tree Height | &lt;= 1 A balanced binary tree must be a binary search tree, otherwise it is not necessarily The formula of the nodes of the minimum binary balanced tree: F(n) = F(n-1) + F(n-2) + 1 (1 is the root node, F (n-1) is the left subtree Number of nodes, F (n-2) is the number of nodes in the right subtree) Balanced binary tree pictures Minimal Imbalance TreeBalanced binary tree inserting new nodes causes unbalanced subtrees Adjustment: LL type: left child of the root RR type: right child of the root LR type: Left-handed child of the root, left-handed, then right-handed RL type: Left child of right child, right-handed first, then left-handed Red black treeRedBlackTree.cpp What are the characteristics of red-black trees? The nodes are red or black. The root is black. All leaves are black (the leaves are NIL nodes). Each red node must have two black child nodes. (There cannot be two consecutive red nodes on all paths from each leaf to the root.) (The parent node of the new node must be the same) All simple paths from any node to each of its leaves contain the same number of black nodes. (New nodes must be red) AdjustmentDiscolorationLeftRight turn Application Associative arrays: such as map, set in STL What is the difference between red and black trees, B trees, and B + trees? The depth of the red-black tree is larger, while the depth of the B-tree and B + -tree is relatively smaller B + trees store data in leaf nodes, and connect them together in the form of linked lists. B-tree, B + -treeB-tree, B+-tree pictures Features Generalized binary search tree “Puffy”, internal (non-leaf) nodes can have a variable number of child nodes (the number range is predefined) Application Most file systems and database systems use B-trees and B + trees as index structures the difference Only leaf nodes in the B + tree will have pointers to records (ROWID), while all nodes in the B-tree will have, and the index items appearing in the internal nodes will no longer appear in the leaf nodes. All leaf nodes in the B + tree are connected by pointers, while the B tree does not. Advantages of B-treeThe data at the internal nodes can be obtained directly without having to locate according to the leaf nodes. Advantages of B + trees Non-leaf nodes do not carry ROWID. In this way, more index entries can be accommodated in a block. One is to reduce the height of the tree. The second is that an internal node can locate more leaf nodes. The leaf nodes are connected by pointers. The range scan will be very simple. For the B-tree, the leaf nodes and internal nodes need to be moved back and forth continuously. The difference between B-tree and B + -tree comes from：differences-between-b-trees-and-b-trees、Difference between B-tree and B + tree OctreeOctree picture An octree is a tree-like data structure used to describe three-dimensional space (dividing space). Each node of the octree represents a volume element of a cube, and each node has eight child nodes. The volume elements represented by the eight child nodes are added together to equal the volume of the parent node. The general center point is used as the bifurcation center of the node. Purpose 3D computer graphics Nearest Search ⚡️ AlgorithmSort Sorting Algorithm Average Time Complexity Worst Time Complexity Spatial Complexity Data Object Stability Bubble Sort O(n2) O(n2) O(1) Stable Selection Sort O(n2) O(n2) O(1) The array is unstable and the linked list is stable Insert Sort O(n2) O(n2) O(1) Stable Quick Sort O(n*log2n) O(n2) O(log2n) Unstable Heap Sort O(n*log2n) O(n*log2n) O(1) Unstable Merge Sort O(n*log2n) O(n*log2n) O(n) Stable Shell Sort O(n*log2n) O(n2) O(1) Unstable Count Sort O(n+m) O(n+m) O(n+m) Stable Bucket Sort O(n) O(n) O(m) Stable Radix Sort O(k*n) O(n2) Stable Are arranged in ascending order k: represents the number of “digits” in the value n: represents the size of the data m: represents the maximum value minus the minimum value of the data From: wikipedia. Sorting Algorithm Find Find Algorithm Average Time Complexity Spatial Complexity Find Conditions SequentialSearch O(n) O(1) sorted or unsorted Binary search (half search) O(log2n) O(1) sorted Insertion Search O(log2(log2n)) O(1) sorted Fibonacci Search O(log2n) O(1) soted Hash Table O(1) O(n) sorted or unsorted Binary Search Tree (BST Search) O(log2n) Red Black Tree O(log2n) 2-3 Tree O(log2n - log3n) B Tree/B+ Tree O(log2n) Graph search algorithm Graph Search Algorithm Data Structure Traversal Time Complexity Spatial Complexity BFS - Breadth First Search adjacency matrix adjacency list O(|v|2)O(|v|+|E|) O(|v|2)O(|v|+|E|) DFS - Depth-First Search adjacency matrix adjacent linked list O(|v|2)O(|v|+|E|) O(|v|2)O(|v|+|E|) Other algorithms Algorithms Ideas Applications Divide and Conquer Divide a complex problem into two or more The same or similar sub-problems, until the last sub-problem can be simply and directly solved, the solution of the original problem is the combination of the solutions of the sub-problems loop schedule problem, sorting algorithms (quick sort, merge sort) Dynamic Programming By decomposing the original problem into relative Simple sub-question way to solve complex problems, suitable for problems with overlapping sub-problems and optimal sub-structure properties [knapsack problem] KnapsackProblem), Fibonacci sequence Greedy method A kind of choice is taken in the current state in each step The best or optimal (that is, the most advantageous) choice, so that the result is the best or optimal algorithm Travel Salesman Problem (Shortest Path Problem), Minimum Spanning Tree, Huffman Coding ❓ ProblemsSingle Problem Chessboard Coverage Problem (Checkerboard coverage problem) Knapsack Problem Neumann Neighbor Problem Round Robin Problem Tubing Problem Leetcode Problems Github . haoel/leetcode Github . pezy/LeetCode Sword Finger Offer Github . zhedahht/CodingInterviewChinese2 Github . gatieme/CodingInterviews Cracking the Coding Interview (Programmer Interview Gold) Github . careercup/ctci Niu Ke. Programmer interview golden code Niu Ke Niu Ke . Online programming topics 💻 Operating systemProcesses and threadsFor threaded systems: Processes are independent units of resource allocation Thread is an independent unit of resource scheduling For non-threaded systems: Process is an independent unit of resource scheduling and allocation Communication between processes and advantages and disadvantages Pipeline (PIPE) Famous Pipeline: A half-duplex communication method that allows communication between unrelated processes Advantages: can achieve inter-process communication in any relationship Disadvantages: Long-term storage in the system, improper use is prone to errors Limited buffer Unnamed pipe: a half-duplex communication method that can only be used between processes with parental relationships (parent-child processes) Advantages: simple and convenient Disadvantages: Limited to one-way communication Can only be created between its processes and their related processes Limited buffer Semaphore: a counter that can be used to control access to shared resources by multiple threads Advantages: can synchronize processes Disadvantage: limited semaphore Signal (Signal): a more complex communication method used to notify the receiving process that an event has occurred Message Queue: a linked list of messages, stored in the kernel and identified by the message queue identifier Advantages: can achieve communication between any process, and achieve synchronization between message sending and receiving through system call functions, no need to consider synchronization issues, convenient Disadvantages: Copying information requires additional CPU time, which is not suitable for situations with large amounts of information or frequent operations Shared Memory: Maps a piece of memory that can be accessed by other processes. This shared memory is created by one process, but can be accessed by multiple processes. Advantages: no need to copy, fast, large amount of information Disadvantages: Communication is achieved by directly attaching the shared space buffer to the virtual address space of the process, so the synchronization of read and write operations between processes Use the memory buffer to directly exchange information. The entity of memory exists in the computer and can only be shared with many processes in a computer system, which is not convenient for network communication. Socket (Socket): can be used for process communication between different computers Advantages: The transmission data is byte level, the transmission data can be customized, the data volume is small and the efficiency is high Short data transmission time and high performance Suitable for real-time information exchange between client and server Can be encrypted, strong data security Disadvantages: The transmitted data needs to be parsed and converted into application-level data. Communication between threads Locking mechanism: including mutex, reader-writer lock, spin lock, and condition Mutex (mutex): Provides an exclusive way to prevent data structures from being modified concurrently. Reader-writer lock: Allow multiple threads to read shared data at the same time, and are mutually exclusive for write operations. Spin locks are similar to mutex locks in order to protect shared resources. The mutex is when the resource is occupied and the applicant goes to sleep; the spin lock circularly detects whether the holder has released the lock. Condition variable (condition): you can atomically block the process until a certain condition is true. Testing of conditions is performed under the protection of a mutex. Condition variables are always used with a mutex. Semaphore mechanism Unknown thread semaphore Named thread semaphore Signal mechanism (Signal): similar to signal processing between processes Barrier: A barrier allows each thread to wait until all cooperating threads reach a certain point, and then continue execution from that point. The purpose of communication between threads is mainly for thread synchronization, so threads have no communication mechanism for data exchange like in process communication. The communication methods between processes and their advantages and disadvantages come from: Process thread interview question summary Private and shared resources between processes Private: address space, heap, global variables, stack, registers Share: code snippet, public data, process directory, process ID Private and shared resources between threads Private: thread stack, register, program counter Shared: heap, address space, global variables, static variables Comparison, advantages and disadvantages of multi-process and multi-threadCompared Contrast Dimensions Multi-Process Multi-Threaded Summary Data sharing and synchronization Complex data sharing requires IPC; data is separate and easy to synchronize Because process data is shared, data sharing is simple, but it is also because of this reason that synchronization is complicated Each advantage Memory, CPU Occupies more memory, complex switching, low CPU utilization Less memory, simple switching, high CPU utilization Threads dominate Create destroy, switch create destroy, switch complex, slow speed create destroy, switch simple, fast speed thread dominant Programming, debugging simple programming, simple debugging complex programming, complex debugging process dominates Reliability Processes will not affect each other Hanging a thread will cause the entire process to hang Process dominance Distributed Applicable to multi-core, multi-machine distributed; if one machine is not enough, it is relatively simple to expand to multiple machines adapted to multi-core distributed process dominant Pros and cons Pros and cons multi-process multi-threaded Advantages Simple programming and debugging, high reliability Fast creation, destruction, switching, small memory and resource occupation Disadvantages Creating, destroying, slow switching, large memory and resource occupation Complex programming and debugging, poor reliability Select Need to frequently create and destroy priority threads Priority threads that require a lot of calculations Strongly related processing threads, weakly related processing processes May be extended to multi-machine distributed processes, multi-core distributed threads When all meet the needs, use the method you are most familiar with The comparison, advantages and disadvantages of multi-process and multi-thread come from: multi-thread or multi-process selection and difference Linux kernel synchronizationthe reasonIn modern operating systems, there may be multiple kernel execution streams executing at the same time, so the kernel actually needs some synchronization mechanism to synchronize the access of the execution units to shared data like multi-process and multi-thread programming. Especially on multiprocessor systems, some synchronization mechanisms are needed to synchronize the access of the execution units on different processors to shared data. Synchronously Atomic operations Semaphore Read and write semaphore (rw_semaphore) Spinlock Big Kernel Lock (BKL, Big Kernel Lock) Read-write lock (rwlock) Brlock-Big Reader Lock Read-Copy Update (RCU, Read-Copy Update) Sequence lock (seqlock) From: Linux kernel synchronization mechanism, Part 1, Linux kernel synchronization mechanism, Part 2 DeadlockReasons Insufficient system resources Improper allocation of resources The progress order of the process operation is not suitable Generate conditions Mutex Request and hold Not deprived Loop Prevention Breaking mutually exclusive conditions: transforming exclusive resources into virtual resources, most of which cannot be transformed. Break the non-preemption condition: when a process occupies an exclusive resource and then applies for an exclusive resource that cannot be met, it will withdraw from the original resource. Break possession and apply conditions: Adopt a resource pre-allocation strategy, that is, apply for all resources before the process runs, run if it meets, or wait, so that it will not be occupied and applied. Break the loop waiting condition: implement the orderly allocation of resources, implement classification numbers for all devices, and all processes can only apply for resources in the form of increasing numbers. Ordered resource allocation method Banker Algorithm File system Windows: FCB table + FAT + bitmap Unix: inode + mixed index + group link Host byte order and network byte orderHost Endianness (CPU Endianness)ConceptThe host byte order is also called the CPU byte order. It is not determined by the operating system, but by the CPU instruction set architecture. There are two types of host byte order: Big Endian: The high-order byte is stored in the low-order address, and the low-order byte is stored in the high-order address Little Endian: The high-order byte is stored in the high-order address, and the low-order byte is stored in the low-order address. Storage methodThe 32-bit integer 0x12345678 is stored from the address starting at 0x00, then: Memory address 0x00 0x01 0x02 0x03 Big Endian 12 34 56 78 Little Endian 78 56 34 12 Big-endian little-endian pictures Judging big-endian little-endianJudge big-endian little-endian You can determine whether your CPU byte order is big-endian or little-endian: 1234567891011121314#include &lt;iostream&gt;using namespace std;int main(){ int i = 0x12345678; if (*((char*)&amp;i) == 0x12) cout &lt;&lt; &quot;Big endian&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Little endian&quot; &lt;&lt; endl; return 0;} Byte order of each architecture processor x86 (Intel, AMD), MOS Technology 6502, Z80, VAX, PDP-11 and other processors are little-endian; Motorola 6800, Motorola 68000, PowerPC 970, System/370, SPARC (except V9) processors are big-endian; The endianness of ARM (default little-endian), PowerPC (except PowerPC 970), DEC Alpha, SPARC V9, MIPS, PA-RISC, and IA64 are configurable. Network byte orderNetwork byte order is a data representation format specified in TCP/IP. It has nothing to do with the specific CPU type, operating system, etc., so that it can ensure that the data can be correctly interpreted when transmitted between different hosts. The network byte order uses: Big Endian arrangement. Page replacement algorithmDuring the address mapping process, if a page to be accessed is found not to be in memory, a page fault interrupt is generated. When a page fault occurs, if there is no free page in the operating system memory, the operating system must select a page in memory to move it out of memory in order to make room for the page that is about to be paged in. The rules used to select which pages to eliminate are called page replacement algorithms. Categories Global replacement: replacement in the entire memory space Partial replacement: Replace in this process AlgorithmGlobal: Working set algorithm Page rate replacement algorithm Partially: Optimal Replacement Algorithm (OPT) First in, first out replacement algorithm (FIFO) Least Recently Used (LRU) Algorithm Clock replacement algorithm ☁️ Computer Network Some of the knowledge in this section comes from Computer Networking (7th Edition) Computer network architecture: Roles and protocols of each layer Layered role protocol Physical layer Transmission of bits through the medium, determination of mechanical and electrical specifications (bits) RJ45, CLOCK, IEEE802.3 (repeaters, hubs) Data link layer Assemble bits into frames and point-to-point delivery (Frame) PPP, FR, HDLC, VLAN, MAC (bridge, switch) Network layer Responsible for the transmission of data packets from source to sink and Internet interconnection (packets) IP, ICMP, ARP, RARP, OSPF, IPX, RIP, IGRP (router) Transport layer Provide end-to-end reliable message delivery and error recovery (Segment) TCP, UDP, SPX Session layer Establishing, managing, and terminating sessions (session protocol data unit SPDU) NFS, SQL, NETBIOS, RPC Presentation Layer Translate, Encrypt, and Compress Data (Representation Protocol Data Unit PPDU) JPEG, MPEG, ASII Application layer A means to allow access to the OSI environment (Application Protocol Data Unit APDU) FTP, DNS, Telnet, SMTP, HTTP, WWW, NFS Physical layer Unit of transmitted data: bit Data transmission system: source system (source point, sender)-&gt; transmission system-&gt; destination system (receiver, destination) aisle: Unidirectional channel (simplex channel): only one direction communication, no reverse direction interaction, such as broadcasting Two-way alternate communication (half-duplex communication): both parties of the communication can send messages, but cannot send or receive at the same time Two-way simultaneous communication (full-duplex communication): both parties of the communication can send and receive information at the same time Channel multiplexing technology: Frequency division multiplexing (FDM, Frequency Division Multiplexing): different users in different frequency bands, users use different bandwidth resources at the same time Time Division Multiplexing (TDM): different users in different time slices in the same time period, all users occupy the same bandwidth at different times Wavelength Division Multiplexing (WDM): Frequency division multiplexing of light Code Division Multiplexing (CDM): Different users use different codes and can use the same frequency band for communication at the same time data link layerMain channel: Point-to-point channel Broadcast channel Point-to-point channel Data unit: frame Three basic questions: Encapsulation: Encapsulate IP datagrams at the network layer into frames, SOH-data part-EOT Transparent transmission: No matter what characters in the data part, it can be transmitted; it can be solved by byte padding method (escaping characters before conflicting characters) Error detection: reduce bit error rate (BER), widely use cyclic redundancy check (CRC, Cyclic Redundancy Check) Point-to-Point Protocol: Point-to-Point Protocol: The protocol used by the user computer to communicate with the ISP Broadcast ChannelBroadcast communication: Hardware address (physical address, MAC address) Unicast frame (one-to-one): The MAC address of the received frame is the same as the hardware address of this station Broadcast frame (one pair): frame sent to all stations on the local area network Multicast frame (one-to-many): frame sent to some sites on the local area network Network layer IP (Internet Protocol, Internet Protocol) is a protocol designed for computer networks to communicate with each other. ARP (Address Resolution Protocol, Address Resolution Protocol) ICMP (Internet Control Message Protocol, Internet Control Message Protocol) IGMP (Internet Group Management Protocol, Internet Group Management Protocol) IP Internet ProtocolIP address classification: IP address ::= (&lt;network number&gt;, &lt;host number&gt;) IP address category network number network range host number IP address range Class A 8bit, the first bit is fixed at 0 0 —— 127 24bit 1.0.0.0 —— 127.255.255.255 Class B 16bit, the first two bits are fixed at 10 128.0 —— 191.255 16bit 128.0.0.0 —— 191.255.255.255 Class C 24bit, the first three bits are fixed at 110 192.0.0 —— 223.255.255 8bit 192.0.0.0 —— 223.255.255.255 Class D The first four bits are fixed at 1110, followed by the multicast address Class E The first five digits are fixed at 11110, the latter are reserved for future use IP datagram format: ICMP Internet Control Message ProtocolICMP message format: application: PING (Packet InterNet Groper) to test connectivity between two hosts TTL (Time To Live, time to live) This field specifies the maximum number of network segments that IP packets are allowed to pass before being dropped by the router. Interior Gateway Protocol RIP (Routing Information Protocol, Routing Information Protocol) OSPF (Open Sortest Path First) External gateway protocol BGP (Border Gateway Protocol, Border Gateway Protocol) IP multicast IGMP (Internet Group Management Protocol, Internet Group Management Protocol) Multicast routing protocol VPN and NAT VPN (Virtual Private Network) NAT (Network Address Translation, Network Address Translation) What does the routing table contain? Network ID (Network ID): It is the network ID of the destination address. Subnet mask: used to determine the network to which the IP belongs Next hop address / interface: It is the address of the next stop of the data on the journey sent to the destination address. Where interface points to the next hop (that is, the next route). The route in an autonomous system (AS) should contain all subnets in the area, and the default gateway (Network id: 0.0.0.0, Netmask: 0.0.0.0) points to the exit of the autonomous system. Depending on the application and implementation, the routing table may contain the following additional information: Cost: It is the cost required to pass the path during data transmission. Quality of service for routing List of inbound / outbound connections to be filtered in the route Transport layerprotocol: TCP (Transmission Control Protocol) UDP (User Datagram Protocol, User Datagram Protocol) port: Applications FTP TELNET SMTP DNS TFTP HTTP HTTPS SNMP Port number 21 23 25 53 69 80 443 161 TCP TCP (Transmission Control Protocol, Transmission Control Protocol) is a connection-oriented, reliable, byte stream-based transport layer communication protocol, and its transmission unit is a message segment. Feature: Connection oriented Only point-to-point (one-to-one) communication Reliable interaction Full-duplex communication Byte stream oriented How TCP guarantees reliable transmission: Confirmation and timeout retransmission Reasonable fragmentation and ordering of data flow control Congestion control Data validation TCP message structure TCP header TCP: Status Control Code (Code, Control Flag), which takes 6 bits and has the following meaning: URG: Urgent. When URG = 1 , it indicates that the urgent pointer field is valid, which means that the packet is an urgent packet. It tells the system that there is urgent data in this segment and it should be transmitted as soon as possible (equivalent to high-priority data), and the Urgent Pointer field in the above figure will also be enabled. ACK: Acknowledge. The acknowledgment number field is valid only when ACK = 1, which means this packet is an acknowledgment packet. When ACK = 0, the confirmation number is invalid. PSH: (Push function) If it is 1, the representative requires the other party to immediately transmit other corresponding packets in the buffer, without waiting for the buffer to be full before sending. RST: Reset bit (Reset). When RST = 1, it indicates that a serious error occurred in the TCP connection (such as due to a host crash or other reasons). You must release the connection and then re-establish the transport connection. SYN: Synchronous. When SYN is set to 1, it indicates that this is a connection request or connection acceptance message. Usually, the packet with the SYN flag indicates that “active” wants to connect to the other party. FIN: Final bit, used to release a connection. When FIN = 1, it means that the data of the sending end of this segment has been sent, and it is required to release the transport connection. UDP UDP (User Datagram Protocol, User Datagram Protocol) is a connectionless transport layer protocol in the OSI (Open System Interconnection) reference model, which provides a simple and unreliable information transfer service oriented to transactions, and its transmission unit Is a user datagram. feature: no connection Best efforts to deliver Message-oriented No congestion control Supports one-to-one, one-to-many, many-to-one, and many-to-many interactive communication Small overhead UDP message structure UDP 首部 TCP/UDP Pictures from https://github.com/JerryC8080/understand-tcp-udp Difference between TCP and UDP TCP connection-oriented, UDP is connectionless; TCP provides reliable service, that is, the data transmitted through the TCP connection is error-free, not lost, not duplicated, and arrives in order; UDP does its best to deliver, that is, it does not guarantee reliable delivery TCP logical communication channel is a full-duplex reliable channel; UDP is an unreliable channel Each TCP connection can only be point-to-point; UDP supports one-to-one, one-to-many, many-to-one and many-to-many interactive communication TCP is oriented to byte streams (probably sticky packets may occur). In fact, TCP treats data as a series of unstructured byte streams; UDP is message-oriented (no sticky packets will occur) UDP has no congestion control, so congestion on the network will not reduce the sending rate of the source host (useful for real-time applications, such as IP phones, real-time video conferencing, etc.) TCP header overhead is 20 bytes; UDP header overhead is small, only 8 bytes TCP Sticky Packetthe reasonTCP is a byte stream-based transmission service (UDP is message-based). “Stream” means that the data transmitted by TCP has no boundaries. So there may be situations where two data packets stick together. Solve Send fixed-length packets. If the size of each message is the same, the receiving peer only needs to accumulate the received data until the data is equal to a fixed-length value and treats it as a message. Baotou plus package body length. The header is 4 bytes of fixed length, which indicates the length of the packet body. The receiving peer first receives the header length and receives the packet body according to the header length. Set boundaries between packets, such as adding special symbols \\r\\n mark. The FTP protocol does just that. The problem is that if the data body also contains \\r\\n , it will be misjudged as the message boundary. Use more complex application layer protocols. TCP Flow ControlConceptFlow control is to make the sending rate of the sender not too fast, but to allow the receiver to receive it. MethodsVariable window for flow control TCP congestion controlConceptCongestion control is to prevent excessive data from being injected into the network, so that the routers or links in the network will not be overloaded. Methods Slow start Congestion avoidance Fast retransmit Fast recovery TCP Congestion control graph TCP Transmission connection management 因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：https://raw.githubusercontent.com/huihut/interview/master/images/TCP-transport-connection-management.png TCP 三次握手建立连接 【Explain the whole process of TCP connection establishment】 The client sends a SYN to the server, indicating that the client requests to establish a connection; The server receives the SYN sent by the client and replies with SYN + ACK to the client (agreeing to establish a connection); After receiving the SYN + ACK from the server, the client responds with an ACK to the server (indicating that the client received the consent message sent by the server); The server receives the ACK from the client, the connection is established, and data transmission is possible. Why does TCP have to shake hands three times?【Answer One】 Because the channel is unreliable, and TCP wants to establish a reliable transmission on the unreliable channel, then three communications is the theoretical minimum. (And UDP does not need to establish a reliable transmission, so UDP does not require a three-way handshake.) Google Groups. Why is TCP a three-way handshake to establish a connection? {Technology} {Network Communication} [Answer II] Because both parties need to confirm that the other party has received the serial number sent by themselves, the confirmation process requires at least three communications. Know. Why is TCP a three-way handshake instead of two or four? [Answer three] In order to prevent the invalid connection request segment from being sent to the server suddenly, an error is generated. “Computer Network (7th Edition) -Xie Xiren” TCP 四次挥手释放连接 【TCP Four waves to release the connection】 The client sends FIN to the server, indicating that the client does not need to send data to the server (request to release the connection from the client to the server); The server receives the FIN sent by the client and replies ACK to the client (agreeing to release the connection from the client to the server); The client receives the ACK from the server, and the connection from the client to the server has been released (but the connection from the server to the client has not been released, and the client can still receive data); The server continues to send the unfinished data to the client; The server sends FIN + ACK to the client, indicating that the server has sent the data (request to release the connection from the server to the client, even if no reply is received from the client, it will be automatically released after a certain period of time); The client receives the FIN + ACK from the server and replies to the client with an ACK (agreeing to release the connection from the server to the client); After receiving the ACK from the client, the server releases the connection from the server to the client. Why does TCP have to wave four times?[Question 1] Why does TCP wave four times? / Why does TCP need three times to establish a connection and four times to release a connection? [Answer One] Because TCP is in full-duplex mode, after the client requests to close the connection, the connection from the client to the server is closed (one or two waves), and the server continues to transmit the data that has not been previously transmitted to the client (data transmission) , The connection from the server to the client is closed (waving three or four times). Therefore, when TCP releases the connection, the server’s ACK and FIN are sent separately (with data transmission in between), and when the TCP establishes the connection, the server’s ACK and SYN are sent together (second handshake), so TCP needs to establish the connection three times. It takes four times to release the connection. [Question 2] Why can ACK and SYN be sent together when TCP is connected, and ACK and FIN are sent separately when released? (ACK and FIN refer to the second and third wave) [Answer 2:] When the client requests the release, the server may still have data to transmit to the client, so the server must respond to the client FIN request (the server sends an ACK), and then the data is transmitted. After the transmission is completed, the server then Make a FIN request (the server sends FIN); there is no intermediate data transmission when connecting, so ACK and SYN can be sent together when connecting. [Question three] Why does the client need TIME-WAIT to wait for 2MSL at the end? 【Answer three】 In order to ensure that the last ACK message sent by the client can reach the server. If it fails to arrive, the server will retransmit the FIN + ACK segment overtime, and the client will retransmit the ACK and re-time. Prevent invalid connection request segments from appearing in this connection. When TIME-WAIT lasts 2MSL, all the segments generated during the duration of this connection will disappear from the network, so that the old connection segments will not appear in the next connection. TCP finite state machineTCP finite state machine picture Application layerDNS DNS (Domain Name System) is a service of the Internet. It serves as a distributed database that maps domain names and IP addresses to each other, enabling people to access the Internet more conveniently. DNS uses TCP and UDP port 53. Currently, the limit for the length of each domain name is 63 characters, and the total length of the domain name cannot exceed 253 characters. domain name: Domain name :: = {&lt;third-level domain name&gt;.&lt;Second-level domain name&gt;.&lt;Top-level domain name&gt;}, for example: blog.huihut.com FTP FTP (File Transfer Protocol, file transfer protocol) is a set of standard protocols for file transfer on the network, using the client / server model, using TCP datagrams, providing interactive access, two-way transmission. TFTP (Trivial File Transfer Protocol) is a small and easy-to-implement file transfer protocol. It also uses the client-server method and uses UDP datagrams. It only supports file transfers and does not support interaction. User authentication TELNET The TELNET protocol is a member of the TCP / IP protocol family and is the standard protocol and main method of the Internet remote login service. It provides users with the ability to complete remote host work on the local computer. HTTP (HyperText Transfer Protocol) is a transfer protocol used to transfer hypertext from a WWW (World Wide Web, World Wide Web) server to a local browser. SMTP (Simple Mail Transfer Protocol) is a set of rules for transferring mail from the source address to the destination address, which controls the transfer method of the letter. The SMTP protocol belongs to the TCP / IP protocol suite, which helps each computer find the next destination when sending or transferring letters. Socket requires at least a pair of port numbers (Socket) to establish a network communication connection. Socket is essentially a programming interface (API), which encapsulates TCP / IP. TCP / IP also provides an interface that programmers can use for network development. This is the Socket programming interface. WWW WWW (World Wide Web, World Wide Web, World Wide Web) is a system composed of many hypertext links to each other, accessed via the Internet URL URL (Uniform Resource Locator) is a standard resource address (Address) on the Internet standard format: Protocol type: [// server address [: port number]] [/ resource level UNIX file path] file name [? Query] [# Clip ID] Complete format: Protocol type: [// [Credential information required to access resources @] server address [: port number]] [/ resource level UNIX file path] file name [? Query] [# segment ID] Among them [access credential information @ ;: port number ;? query; #fragment ID] are all optional itemsFor example: https://github.com/huihut/interview#cc HTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for distributed, collaborative, and hypermedia information systems. HTTP is the foundation of data communication for the World Wide Web. Request method Method meaning OPTIONS Request some option information to allow clients to view server performance GET Request the specified page information and return the entity body HEAD Similar to a get request, except that there is no specific content in the returned response, which is used to get the header POST Submits data to a specified resource for processing requests (such as submitting a form or uploading a file). The data is contained in the request body. POST requests may result in the creation of new resources and / or modification of existing resources PUT Data transmitted from the client to the server replaces the contents of the specified document DELETE request the server to delete the specified page TRACE echo requests received by the server, mainly for testing or diagnostics Status Code 1xx: indicates notification information, such as the request has been received or is being processed 100 Continue: Continue, the client should continue its request 101 Switching Protocols. The server switches protocols according to the client’s request. Can only switch to higher-level protocols, for example, to new versions of HTTP 2xx: indicates success, such as receiving or knowing 200 OK: The request was successful 3xx: indicates a redirect, and further action is required to complete the request 301 Moved Permanently: Move permanently. The requested resource has been permanently moved to the new URL, the returned information will include the new URL, and the browser will automatically be directed to the new URL. Any future requests should use the new URL instead 4xx: indicates a customer error, such as incorrect syntax in the request or inability to complete 400 Bad Request: The client requested a syntax error that the server could not understand 401 Unauthorized: request requires user authentication 403 Forbidden: The server understood the request from the requesting client, but refused to execute the request (insufficient permissions) 404 Not Found: The server cannot find the resource (web page) based on the client’s request. With this code, the website designer can set a personality page for “the resource you requested could not be found” 408 Request Timeout: The server waited too long for the request sent by the client, timed out 5xx: indicates a server error, such as the server failing to complete the request 500 Internal Server Error: Server internal error, unable to complete request 503 Service Unavailable: Due to overload or system maintenance, the server cannot temporarily process the client’s request. The length of the delay can be included in the server’s Retry-After header 504 Gateway Timeout: The server acting as a gateway or proxy, not receiving requests from the remote server in a timely manner More status codes: Rookie Tutorials. HTTP Status Codes Other agreements SMTP (Simple Main Transfer Protocol, Simple Mail Transfer Protocol) is a standard for transmitting Email over the Internet. It is a relatively simple text-based protocol. One or more recipients of a message are specified on top of it (confirmed to exist in most cases), and the message text is transmitted. You can easily test an SMTP server through a Telnet program. SMTP uses TCP port 25. DHCP (Dynamic Host Configuration Protocol) is a network protocol for a local area network. It uses the UDP protocol to work and has two main purposes: For internal network or network service provider to automatically assign IP addresses to users For internal network administrators as a means of central management of all computers SNMP (Simple Network Management Protocol) forms part of the Internet protocol family defined by the Internet Engineering Task Force (IETF). The protocol can support a network management system to monitor whether the devices connected to the network have any management concerns. 🌩 Network ProgrammingSocket Linux Socket Programming (unlimited Linux） Socket middle read()、write() function12ssize_t read(int fd, void *buf, size_t count);ssize_t write(int fd, const void *buf, size_t count); read() The read function is responsible for reading content from fd. When the read is successful, read returns the actual number of bytes read. If the returned value is 0, it means that the end of the file has been read, and if it is less than 0, an error has occurred. If the error is EINTR, the reading is caused by interruption; if it is ECONNREST, there is a problem with the network connection. write () The write function writes the contents of nbytes in buf to the file descriptor fd. Returns the number of bytes written when successful. On failure, it returns -1 and sets the errno variable. In network programs, there are two possibilities when we write to the socket file descriptor. (1) The return value of write is greater than 0, indicating that part or all of the data has been written. (2) The returned value is less than 0, and an error has occurred at this time. If the error is EINTR, it indicates that an interruption error occurred during writing; if it is EPIPE, it indicates that there is a problem with the network connection (the other party has closed the connection). TCP three-way handshake in socket to establish connectionWe know that TCP establishes a connection by performing a “three-way handshake”, that is, exchanging three packets. The general process is as follows: The client sends a SYN J to the server The server responds to the client with a SYN K, and confirms SYN J ACK J + 1 The client wants the server to send an acknowledgement ACK K + 1 Only the three-way handshake is finished, but what about the three-way handshake in the socket function? Please see the picture below: It can be seen from the figure: When the client calls connect, a connection request is triggered and a SYN J packet is sent to the server. At this time, connect enters a blocking state; The server listens to the connection request, that is, receives the SYN J packet, calls the accept function to receive the request and sends SYN K and ACK J + 1 to the client, then accept enters the blocking state; After the client receives the SYN K of the server, ACK J + 1, connect returns at this time, and confirms the SYN K; When the server receives ACK K + 1, accept returns, so that the three handshake is completed and the connection is established. TCP four-way handshake in socket to release connectionThe above describes the three-way handshake establishment process of TCP in socket and the socket functions involved. Now we introduce the process of releasing the connection by the four-way handshake in the socket, please see the following figure: The illustrated process is as follows: An application process first calls close to actively close the connection, then TCP sends a FIN M; After receiving the FIN M, the other end performs a passive close to confirm the FIN. Its reception is also passed to the application process as an end-of-file character, because the reception of FIN means that the application process can no longer receive additional data on the corresponding connection; After a period of time, the application process that received the end-of-file character calls close to close its socket. This causes its TCP to also send a FIN N; The source TCP that received the FIN confirms it. So there is a FIN and ACK in each direction. 💾 Database Part of the knowledge in this section comes from “Introduction to Database Systems (5th Edition)” basic concepts Data: Symbolic records describing things are called data. Database (DB): It is a collection of a large amount of organized, shareable data stored in a computer for a long time, and has three basic characteristics of permanent storage, organization, and shareability. Database Management System (DBMS): is a layer of data management software located between the user and the operating system. Database system (DBS): is a system consisting of a database, a database management system (and its application development tools), applications, and a database administrator (DBA) to store, manage, process, and maintain data. Entity: Objects that exist objectively and can be distinguished from each other are called entities. Attribute: An attribute of an entity is called an attribute. Key: The set of attributes that uniquely identify an entity is called a key. Entity type: Use entity name and its attribute name set to abstract and characterize similar entities, called entity type. Entity set: A set of the same entity type is called an entity set. Relationship: The relationship between entities usually refers to the connection between different sets of entities. Schema: A schema is also called a logical schema. It is a description of the logical structure and characteristics of the entire database data. It is a common data view for all users. External schema: External schema is also called subschema or user schema. It is a description of the logical structure and characteristics of local data that database users (including application programmers and end users) can see and use. A database user’s data view is a logical representation of data related to an application. Internal schema: Internal schema is also called storage schema. A database has only one internal schema. It is a description of the physical structure and storage of the data, and the way the database is organized within the database. Common data models Hierarchical model Network model Relational model Relation (relation): a relation corresponds to a table Tuple: a row in the table is a tuple Attribute (attribute): a column in the table is an attribute Key: A certain attribute group of a tuple can be uniquely identified in the table Domain (domain): a set of values of the same data type Component: an attribute value in a tuple Relation mode: description of the relationship, generally expressed as relation name (attribute 1, attribute 2, ..., attribute n) Object oriented data model Object relational data model Semistructured data model Common SQL Operations Object type Object Type of operation Database mode Mode CREATE SCHEMA Basic table CREATE SCHEMA , ALTER TABLE View CREATE VIEW Index CREATE INDEX Data Basic tables and views SELECT , INSERT , UPDATE , DELETE , REFERENCES , ALL PRIVILEGES Attribute column SELECT , INSERT , UPDATE , REFERENCES , ALL PRIVILEGES SQL Grammar Tutorial: runoob . SQL Tutorial Relational Database Basic relation operations: query (selection, projection, connection (equivalent connection, natural connection, outer connection (left outer connection, right outer connection)), division, union, difference, intersection, Cartesian product, etc.), insertion, deletion ,modify Three types of integrity constraints in the relationship model: entity integrity, referential integrity, user-defined integrity Index Database index: sequential index, B + tree index, hash index Data structure and algorithm principle behind MySQL index Database integrity Database integrity refers to the correctness and compatibility of data. Integrity: To prevent non-semantic (incorrect) data from the database. Security: In order to protect the database from malicious damage and illegal access. Trigger: is a special event-driven process defined by the user in the relational table. Relational data theory Data dependency is a constraint relationship between the internal attributes and attributes of a relationship. It is a correlation between data that is reflected by the equality of the values ​​between attributes. The most important data dependencies: function dependencies, multi-value dependencies. Paradigm First Normal Form (1NF): The attribute (field) is the smallest unit and cannot be separated. The second normal form (2NF): meet 1NF, each non-primary attribute completely depends on the primary key (eliminating the partial function dependence of 1NF non-primary attribute on the code). The third normal form (3NF): 2NF is satisfied, and any non-primary attribute does not depend on other non-primary attributes (eliminating the 2NF non-primary attribute’s transfer function dependence on the code). Bowies-Kode Normal Form (BCNF): Satisfy 3NF, any non-primary attribute cannot depend on the subset of primary keys (eliminating the 3NF primary attribute’s dependence on the code part and transfer function) The fourth normal form (4NF): meet 3NF, there must be non-trivial and non-functional dependent multi-value dependencies between attributes (eliminating 3NF non-trivial and non-functional multi-value dependencies). Database Recovery Transaction: It is a user-defined sequence of database operations. These operations are either all done or not done at all. It is an indivisible unit of work. ACID characteristics of things: atomicity, consistency, isolation, persistence. Implementation technology of recovery: establish redundant data-&gt; use redundant data to implement database recovery. Common techniques for establishing redundant data: data dumps (dynamic mass dumps, dynamic incremental dumps, static mass dumps, static incremental dumps), registration log files. Concurrency control Transactions are the basic unit of concurrency control. Data inconsistencies caused by concurrent operations include: lost modifications, non-repeatable reads, and “dirty” data reads. The main technologies of concurrency control: blocking, timestamp, optimistic control method, multi-version concurrency control, etc. Basic lock types: exclusive lock (X lock / write lock), shared lock (S lock / read lock). Livelock deadlock: Livelock: The transaction is always in a waiting state, which can be avoided through a first come, first served policy. Deadlock: Things can never end Prevention: one-time block method, sequential block method; Diagnosis: timeout method, waiting graph method; Cancel: Undo the transaction with the least deadlock cost and release all the locks of this transaction, so that other transactions can continue to run. Serializable scheduling: The concurrent execution of multiple transactions is correct if and only if the result is the same as when the transactions are executed serially in a certain order. Guidelines for correct scheduling of concurrent transactions when serializable. 📏 Design pattern Examples of major design patterns: CSDN column. C ++ Design Patterns series of blog posts Design Pattern Project Catalog Singleton modeSingleton Pattern Example Abstract factory patternAbstract Factory Pattern Example Adapter ModeAdapter pattern example Bridge modeBridge pattern example Observer modeExample of Observer Pattern Six Principles of Design Patterns Single Responsibility Principle (SRP) Liskov Substitution Principle (LSP) Dependence Inversion Principle (DIP) Interface Segregation Principle (ISP) Law of Demeter (LoD) Open Close Principle (OCP) ⚙️ Link Loading Library Part of the knowledge in this section comes from “Programmer’s Self-Cultivation-Link Loading Library” memory, stack, heapThe general application memory space has the following areas: Stack: Automatically allocated and released by the operating system, storing function parameter values, local variable values, etc., used to maintain the context of function calls Heap: Generally allocated and released by the programmer. If the programmer does not release, it may be recycled by the operating system at the end of the program to accommodate the dynamically allocated memory area of ​​the application. Executable image: Stores the image of the executable file in memory. Loading by the loader is to read or map the memory of the executable file here. Reserved area: The reserved area is not a single memory area, but a general term for memory areas that are protected from access in the memory. For example, in C, the invalid pointer is assigned a value of 0 (NULL), so the 0 address is normal. Impossible to access data efficiently stackThe stack stores the maintenance information required for a function call. It is often called a stack frame or an active record. It generally contains the following aspects: Function return address and parameters Temporary variables: including non-static local variables of functions and other temporary variables automatically generated by the compiler Save context: including registers that need to remain unchanged before and after function calls HeapHeap allocation algorithm: Free List Bitmap Object pool “Segment fault” or “Illegal operation, this memory address cannot be read / write”Errors caused by typical illegal pointer dereferencing. This error occurs when the pointer points to a memory address that is not allowed to read and write, and the program attempts to use the pointer to read or write that address. Common reasons: Initialize the pointer to NULL, then start using the pointer without giving it a reasonable value There is no need to initialize the pointer in the stack. The value of the pointer will generally be a random number. After that, the pointer is used directly. Compile and linkFile formats for each platform Platform Executables Objects Dynamic Libraries / Shared Objects Static Libraries Windows exe obj dll lib Unix/Linux ELF、out o so a Mac Mach-O o dylib、tbd、framework a、framework Compile and link process Pre-compilation (pre-compiler processes pre-compilation instructions such as # include, # define and generates .i or .ii files) Compile (the compiler performs lexical analysis, syntax analysis, semantic analysis, intermediate code generation, object code generation, optimization, and generation of .s files) Assembly (the assembler translates the assembly code into machine code and generates a .o file) Linking (connectors perform address and space allocation, symbol resolution, relocation, and generate .out files) The current version of GCC combines pre-compilation and compilation into one step, pre-compiled compiler cc1, assembler as, linker ld MSVC compilation environment, compiler cl, linker link, executable file viewer dumpbin target documentThe files generated by the compiler after compiling the source code are called object files. The object file is structurally speaking, it is a compiled executable file format, but the linking process has not yet been performed, and some symbols or addresses may not be adjusted. Executable files (.exe for Windows and ELF for Linux), dynamic link libraries (.dll for Windows and .so for Linux), static link libraries (.lib for Windows and Linux .A) are stored according to the executable file format (Windows according to PE-COFF, Linux according to ELF) Object file format Windows PE (Portable Executable), or PE-COFF, .obj format Linux’s ELF (Executable Linkable Format), .o format Intel / Microsoft OMF (Object Module Format) Unix a.out format MS-DOS .COM format PE and ELF are both COFF (Common File Format) variants Object file storage structure Segment Function File Header File header, describing the file attributes of the entire file (including whether the file is executable, is it statically linked or dynamically linked with the entry address, target hardware, target operating system, etc.) .text section Code section, machine code compiled by the execution statement .data section Data section, initialized global and local static variables .bss section BSS section (Block Started by Symbol), uninitialized global and local static variables (because the default value is 0, so it is only reserved here and does not take up space) .rodata section Read-only data section, which stores read-only data, generally read-only variables (such as const-modified variables) and string constants in the program .comment section Comment section for compiler version information .note.GNU-stack section Stack hint section Other paragraphs omitted Linked Interface-SymbolIn the link, the object files are actually a reference to the address between the object files, that is, a reference to the address of a function and a variable. We collectively refer to functions and variables as Symbols, and function names or variable names are Symbol Names. The following Symbol Table: Symbol (Symbol Name) Symbol Value (Address) main 0x100 Add 0x123 … … Shared Library for LinuxShared libraries under Linux are ordinary ELF shared objects. The shared library version update should ensure the compatibility of the binary interface ABI (Application Binary Interface) Namelibname.so.x.y.z x: major version number, libraries with different major version numbers are not compatible and need to be recompiled y: minor version number, higher version number is backward compatible with lower version number z: release version number, no interface changes, fully compatible pathMost open source systems, including Linux, follow the FHS (File Hierarchy Standard) standard. This standard specifies how system files are stored, including various directory structures, organizations, and roles. /lib: Stores the most critical and basic shared libraries of the system, such as dynamic linker, C language runtime library, math library, etc. /usr/lib: Stores key libraries required by non-system runtime, mainly development libraries /usr/local/lib: Stores libraries that are not very relevant to the operating system itself, mainly libraries for some third-party applications The dynamic linker looks for shared libraries in / lib, /usr/lib, and specified by the /etc/ld.so.conf configuration file Environment variables LD_LIBRARY_PATH: temporarily change the shared library search path of an application without affecting other applications LD_PRELOAD: specify some shared libraries or even object files that are pre-loaded LD_DEBUG: Turn on the debugging function of the dynamic linker So shared library writingWriting shared libraries with CLion Create a shared library named MySharedLib CMakeLists.txt 123456cmake_minimum_required(VERSION 3.10)project(MySharedLib)set(CMAKE_CXX_STANDARD 11)add_library(MySharedLib SHARED library.cpp library.h) library.h 12345678910111213141516171819#ifndef MYSHAREDLIB_LIBRARY_H#define MYSHAREDLIB_LIBRARY_H// print Hello World!void hello();// Sum using variable template parameterstemplate &lt;typename T&gt;T sum(T t){ return t;}template &lt;typename T, typename ...Types&gt;T sum(T first, Types ... rest){ return first + sum&lt;T&gt;(rest...);}#endif library.cpp 123456#include &lt;iostream&gt;#include &quot;library.h&quot;void hello() { std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;} use of so shared library (called by executable project)Use CLion to call a shared library Create an executable project named TestSharedLib CMakeLists.txt 12345678910111213141516171819cmake_minimum_required (VERSION 3.10)project (TestSharedLib)# C ++ 11 compileset (CMAKE_CXX_STANDARD 11)# Header file pathset (INC_DIR / home / xx / code / clion / MySharedLib)# Library file pathset (LIB_DIR / home / xx / code / clion / MySharedLib / cmake-build-debug)include_directories(${INC_DIR})link_directories(${LIB_DIR})link_libraries(MySharedLib)add_executable(TestSharedLib main.cpp)# link MySharedLib Librarytarget_link_libraries(TestSharedLib MySharedLib) main.cpp 12345678910111213#include &lt;iostream&gt;#include &quot;library.h&quot;using std::cout;using std::endl;int main() { hello(); cout &lt;&lt; &quot;1 + 2 = &quot; &lt;&lt; sum(1,2) &lt;&lt; endl; cout &lt;&lt; &quot;1 + 2 + 3 = &quot; &lt;&lt; sum(1,2,3) &lt;&lt; endl; return 0;} Results 123Hello, World!1 + 2 = 31 + 2 + 3 = 6 Windows Application entry function GUI（Graphical User Interface) application, linker options:/SUBSYSTEM:WINDOWS CUI（Console User Interface) application, linker options：/SUBSYSTEM:CONSOLE _tWinMain versus _tmain Function declaration 12345678910Int WINAPI _tWinMain( HINSTANCE hInstanceExe, HINSTANCE, PTSTR pszCmdLine, int nCmdShow);int _tmain( int argc, TCHAR *argv[], TCHAR *envp[]); Application Type Entry Point Function Embedded Startup Function GUI application for processing ANSI characters (strings) _tWinMain (WinMain) WinMainCRTSartup GUI application for handling Unicode characters (strings) _tWinMain (wWinMain) wWinMainCRTSartup CUI application that handles ANSI characters (strings) _tmain (Main) mainCRTSartup CUI application for handling Unicode characters (strings) _tmain (wMain) wmainCRTSartup Dynamic-Link Library DllMain _DllMainCRTStartup Dynamic-Link Library for Windows Part of the knowledge comes from “Windows Core Programming (Fifth Edition)” Uses Expanded application features Simplified project management Helps save memory Promote the sharing of resources Improved localization Helps resolve differences between platforms Can be used for special purposes Note Creating a DLL is actually creating a function that can be called by an executable module When a module provides a memory allocation function (malloc, new), it must also provide another memory release function (free, delete) When mixing C and C++, use the extern “C” modifier A DLL can export functions, variables (to avoid export), C++ classes (export and import need to be the same as the compiler, otherwise avoid export) DLL module: __declspec (dllexport) in the cpp file is written before the include header file Calling DLL’s executable module: __declspec (dllimport) of the cpp file should not define MYLIBAPI before Search order for loading Windows programs Directory containing executable files The system directory of Windows can be obtained through GetSystemDirectory 16-bit system directory, the System subdirectory in the Windows directory The Windows directory can be obtained through GetWindowsDirectory The current directory of the process Directories listed in the PATH environment variable DLL Entry functionDllMain function 123456789101112131415161718192021222324BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved){ switch(fdwReason) { case DLL_PROCESS_ATTACH: // Called when mapping a DLL to the process address space for the first time // The DLL is being mapped into the process' address space. break; case DLL_THREAD_ATTACH: // When the process creates a thread, it is used to tell the DLL to perform thread-related initialization (non-main thread execution) // A thread is bing created. break; case DLL_THREAD_DETACH: // The system calls ExitThread before the thread exits, the thread that is about to be terminated performs thread-related cleanup by telling the DLL // A thread is exiting cleanly. break; case DLL_PROCESS_DETACH: // Called when a DLL is removed from the process's address space // The DLL is being unmapped from the process' address space. break; } return (TRUE); // Used only for DLL_PROCESS_ATTACH} Load and unload libraryLoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread Function declaration 123456789101112131415161718192021222324// load libraryHMODULE WINAPI LoadLibrary ( _In_ LPCTSTR lpFileName);HMODULE LoadLibraryExA ( LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);// To load a Win32 DLL in a Universal Windows Platform (UWP) application, you need to call LoadPackagedLibrary instead of LoadLibrary or LoadLibraryExHMODULE LoadPackagedLibrary ( LPCWSTR lpwLibFileName, DWORD Reserved);// uninstall libraryBOOL WINAPI FreeLibrary ( _In_ HMODULE hModule);// Unload the library and exit the threadVOID WINAPI FreeLibraryAndExitThread( _In_ HMODULE hModule, _In_ DWORD dwExitCode); Display link to export symbolGetProcAddress function declaration 1234FARPROC GetProcAddress ( HMODULE hInstDll, PCSTR pszSymbolName // Can only accept ANSI strings, not Unicode); DumpBin.exe View DLL informationUse DumpBin.exe in the VS Developer Command Prompt to view the exported section of the DLL library (exported variables, functions, symbols of class names), relative virtual addresses (RVA). Such as: 1DUMPBIN -exports D: \\ mydll.dll Flow chart of LoadLibrary and FreeLibraryLoadLibrary and FreeLibrary flowchart LoadLibrary FreeLibrary Writing of DLL library (export a DLL module)Writing DLL library (export a DLL module)DLL header file 123456789101112131415161718192021// MyLib.h#ifdef MYLIBAPI// MYLIBAPI should be defined before include &quot;Mylib.h&quot; in all DLL source files// All functions / variables are being exported#else// This header file is included by an exe source code module, which means that all functions / variables are imported#define MYLIBAPI extern &quot;C&quot; __declspec (dllimport)#endif// Define any data structure and symbol here// Define exported variables (avoid exporting variables)MYLIBAPI int g_nResult;// Define the prototype of the exported functionMYLIBAPI int Add(int nLeft, int nRight); DLL source files 12345678910111213141516171819// MyLibFile1.cpp// Contains standard Windows and C runtime header files#include &lt;windows.h&gt;// Functions and variables exported from DLL source files#define MYLIBAPI extern &quot;C&quot; __declspec (dllexport)// Contains exported data structures, symbols, functions, variables#include &quot;MyLib.h&quot;// Put the code of this DLL source code file hereint g_nResult;int Add(int nLeft, int nRight){ g_nResult = nLeft + nRight; return g_nResult;} Use of DLL library (dynamic link DLL at runtime)Use of DLL libraries (dynamically linking DLLs at runtime) 123456789101112131415161718192021222324252627282930313233343536373839404142// A simple program that uses LoadLibrary and // GetProcAddress to access myPuts from Myputs.dll. #include &lt;windows.h&gt; #include &lt;stdio.h&gt; typedef int (__cdecl *MYPROC)(LPWSTR); int main( void ) { HINSTANCE hinstLib; MYPROC ProcAdd; BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; // Get a handle to the DLL module. hinstLib = LoadLibrary(TEXT(&quot;MyPuts.dll&quot;)); // If the handle is valid, try to get the function address. if (hinstLib != NULL) { ProcAdd = (MYPROC) GetProcAddress(hinstLib, &quot;myPuts&quot;); // If the function address is valid, call the function. if (NULL != ProcAdd) { fRunTimeLinkSuccess = TRUE; (ProcAdd) (L&quot;Message sent to the DLL function\\n&quot;); } // Free the DLL module. fFreeResult = FreeLibrary(hinstLib); } // If unable to call the DLL function, use an alternative. if (! fRunTimeLinkSuccess) printf(&quot;Message printed from executable\\n&quot;); return 0;} Runtime（Runtime Library）Typical program operation steps The operating system creates a process and passes control to the entry point of the program (often an entry function in the runtime library) The entry function initializes the runtime library and program running environment (including heap, I / O, threads, global variable construction, etc.). After the entry function is initialized, the main function is called to officially start executing the main part of the program. After the main function finishes executing, return to the entry function for cleanup (including global variable destruction, heap destruction, closing I / O, etc.), and then make a system call to end the process. I / O of a program refers to the interaction between the program and the outside world, including files, management programs, network, command line, signals, etc. More broadly, I / O refers to what the operating system understands as a “file.” glibc entry_start-&gt; __libc_start_main-&gt; exit-&gt; _exit The main (argc, argv, __environ) function is executed in __libc_start_main. MSVC CRT Entryint mainCRTStartup (void) Do the following: Initialize global variables related to the OS version. Initialize the heap. Initialize I / O. Get command line parameters and environment variables. Initialize some data of the C library. Call main and record the return value. Check for errors and return the return value of main. C Language Runtime (CRT)It contains the following functions: Start and exit: including entry functions and other functions on which entry functions depend. Standard functions: There are functions implemented by the C language standard library specified by the C language standard. I/O: Encapsulation and implementation of I / O functions. Heap: Encapsulation and implementation of the heap. Language implementation: implementation of some special functions in the language. Debugging: Code that implements debugging functions. C Language Standard Library (ANSI C)contain: Standard input and output (stdio.h) File operations (stdio.h) Character manipulation (ctype.h) String operations (string.h) Mathematical functions (math.h) Resource Management (stdlib.h) Format conversion (stdlib.h) Time / Date (time.h) Assertions (assert.h) Constants on various types (limits.h &amp; float.h) Variable length parameter (stdarg.h) Non-local jump (setjmp.h) 📚 Books huihut/CS-Books：📚 Computer Technology Books PDF Language “C ++ Primer” “Effective C ++” “More Effective C ++” “Exploring the C ++ Object Model” “Understanding C ++ 11” “Anatomy of STL Source Code” Algorithm “Sword Finger Offer” “Programming Pearls” “Programmer Interview Collection” System “Understanding Computer Systems” “Windows Core Programming” “Advanced Programming in the Unix Environment” The internet “Unix Network Programming” “Detailed Explanation of TCP / IP” Other “The Self-Cultivation of Programmers” 🔱 C / C ++ Development Direction The development direction of C / C ++ is very wide, including not limited to the following directions. The following are some of the requirements for recruiting positions of big factories and schools. Backend / Server[Backend Development] Solid basic programming skills, master C / C ++ / JAVA and other development languages, commonly used algorithms and data structures; Familiar with TCP / UDP network protocol and related programming, inter-process communication programming; Understanding Python, Shell, Perl and other scripting languages; Understand MYSQL, SQL language, programming, NoSQL, key-value storage principle; Comprehensive and solid software knowledge structure, mastering professional knowledge of operating systems, software engineering, design patterns, data structures, database systems, and network security; Understand the knowledge of distributed system design and development, load balancing technology, system disaster recovery design, and high availability systems. Desktop Client[PC client development] Bachelor degree or above in computer software, majoring in programming, solid foundation, understanding of algorithms and data structure; Familiar with memory management, file system, process thread scheduling of windows operating system; Familiar with MFC / windows interface implementation mechanism, proficient in VC, proficient in C / C ++, proficient in STL, and network programming experience under Windows; Familiar with Windows client development and debugging, Windows application software development experience is preferred; Passionate about innovation and solving challenging problems, with good algorithm foundation and system analysis ability. Graphics / Game / VR / AR[Game Client Development] Bachelor degree or above in computer science / engineering major, passion for programming, solid foundation, understanding of algorithms, data structure, software design related knowledge; At least one programming language commonly used in game development, C ++ / C # programming experience is preferred; Experience with game engines (such as Unity, Unreal) is preferred; Knowledge of game client technology (such as graphics, audio, animation, physics, artificial intelligence, network synchronization) is preferred; Passionate about innovation and solving challenging problems, strong learning ability, analytical and problem solving skills, and a good sense of teamwork; Ability to read English technical documents; Love games. Test Development[Test Development] Bachelor degree or above in computer or related field; One to two years of programming experience in C / C ++ / Python or other computer languages; Ability to write test plans, test cases, and achieve performance and safety tests; Ability to implement automated systems; Ability to locate and investigate product defects and code-level debugging defects; Work proactively, have a sense of responsibility, and have a good team spirit. Cyber Security / Reverse[safety technology] Love the Internet, have a passionate pursuit of operating systems and network security, and professionalism is not limited; Familiar with vulnerability mining, network security attack and defense technologies, and common hacking techniques; Master basic development skills and be proficient in C / C ++ language; Have a good grasp of database, operating system and network principles; Experience in software reverse, network security attack and defense or security system development is preferred. Embedded / IoT[Embedded Application Development] Have a good programming foundation, proficient in C / C ++ language; Master the necessary knowledge for software development such as operating system and data structure; Strong communication and understanding ability and good teamwork awareness; Development experience on Linux / Android system platform is preferred. Audio / Video / Streaming / SDK[Audio and video codec] Master’s degree or above, computer, signal processing, mathematics, information and related majors and directions; Solid video coding and decoding foundation, familiar with commonly used HEVC or H264, have a good digital signal processing foundation; Master C / C ++, strong code ability, familiar with an assembly language is preferred; Strong English literature reading ability; Strong learning ability, teamwork spirit, and strong resistance to stress. Computer Vision / Machine Learning[Computer Vision Research] Computer, applied mathematics, pattern recognition, artificial intelligence, automatic control, statistics, operations research, bioinformatics, physics / quantum computing, neuroscience, sociology / psychology and other majors, image processing, pattern recognition, machine learning related research Direction, undergraduate and above, doctoral degree is preferred; Proficient in basic algorithms and applications related to computer vision and image processing; Strong algorithm implementation ability, proficient in C / C ++ programming, familiar with at least one programming language of Shell / Python / Matlab; Publication of papers in computer vision, pattern recognition and other academic conferences or journals, awards in relevant international competitions, and related patents are preferred. 💯 Review brush question website cplusplus cppreference runoob leetcode | leetcode-cn lintcode nowcoder 📝 Interview Question Experience Newcoder.com’s summary of the 2020 autumn tricks! (Post division) 【Preparation for Autumn Moves】 Raiders for 2020 Autumn Moves 2019 School Recruitment Summary! 【Daily Update】 2019 School Recruitment Technology Posts Summary [Technology] 2018 School Recruitment Questions Summary 2017 Autumn Campus Recruitment Pen and Face Summaries The most complete collection of 2017 spring tricks in history!! Interview questions are here Knowing.. On the Internet job search, what well-written and attentive face have you seen? It is best to share your own facial and mental journey. Know. What are the most common interview algorithm questions for internet companies? CSDN. C ++ Interview Questions Completely Organized CSDN. Baidu R &amp; D interview questions (C ++ direction) CSDN. C ++ 30 common interview questions CSDN. Tencent 2016 intern interview experience (already got offer) cnblogs. C ++ Interview Collection (Questions Asked for Interview) cnblogs. C / C ++ written and interview questions summary cnblogs. Summary of common C ++ interview questions and basic knowledge points (1) segmentfault. Summary of common interview questions in C ++ 📆 Recruiting time posts Niuke.com 2020 School Recruitment | 2020 IT Enterprise Recruitment Schedule 👍 Recommend Github. CyC2018 / Job-Recommend: 🔎 Internet internal push information (social recruitment, school recruitment, internship) Github. Amusi / AI-Job-Recommend: direction of artificial intelligence of domestic companies (including machine learning, deep learning, computer vision and natural language processing) Job recruitment information (including full-time, internship and school recruitment) 👬 Contributor 🍭 Support sponsorshipAvalive - A avatar role-playing software for facial capture. 📜 LicenseThis repository follows the CC BY-NC-SA 4.0 (signed-non-commercial use-shared in the same way) agreement, please indicate the source when reprinting, and should not be used for commercial purposes.","link":"/2020/12/08/%E7%BD%91%E7%BB%9C%E4%B8%93%E4%B8%9A%E7%9B%B8%E5%85%B3_en/"}],"tags":[{"name":"Notes","slug":"Notes","link":"/tags/Notes/"},{"name":"Programming","slug":"Programming","link":"/tags/Programming/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Literal","slug":"Literal","link":"/tags/Literal/"},{"name":"Probabilism","slug":"Probabilism","link":"/tags/Probabilism/"},{"name":"Learn","slug":"Learn","link":"/tags/Learn/"},{"name":"office","slug":"office","link":"/tags/office/"}],"categories":[{"name":"Learn","slug":"Learn","link":"/categories/Learn/"},{"name":"A-SOUL","slug":"A-SOUL","link":"/categories/A-SOUL/"},{"name":"Literal","slug":"Literal","link":"/categories/Literal/"},{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Misc","slug":"Misc","link":"/categories/Misc/"},{"name":"UJN","slug":"UJN","link":"/categories/UJN/"}],"pages":[]}